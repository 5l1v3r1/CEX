// The GPL version 3 License (GPLv3)
// 
// Copyright (c) 2018 vtdev.com
// This file is part of the CEX Cryptographic library.
// 
// This program is free software : you can redistribute it and / or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
//
// 
// Implementation Details:
// An implementation of a block cipher Counter mode Generator
// Written by John Underhill, November 21, 2015
// Updated October 23, 2016
// Updated April 18, 2017
// Contact: develop@vtdev.com


#ifndef CEX_BCG_H
#define CEX_BCG_H

#include "IDrbg.h"
#include "BlockCipherExtensions.h"
#include "BlockCiphers.h"
#include "Digests.h"
#include "IBlockCipher.h"
#include "IKdf.h"
#include "ParallelOptions.h"

NAMESPACE_DRBG

using Enumeration::BlockCiphers;
using Enumeration::BlockCipherExtensions;
using Cipher::Symmetric::Block::IBlockCipher;
using Kdf::IKdf;
using Common::ParallelOptions;

/// <summary>
/// An implementation of a Block cipher Counter mode Generator DRBG
/// </summary> 
/// 
/// <example>
/// <description>Generate an array of pseudo random bytes:</description>
/// <code>
/// BCG rng(BlockCiphers::RHX, Digests::SHA512, [Providers::CSP]);
/// // initialize
/// rng.Initialize(Seed, [Nonce], [Info]);
/// // generate bytes
/// rng.Generate(Output, [Offset], [Length]);
/// </code>
/// </example>
/// 
/// <remarks>
/// <description><B>Overview:</B></description>
/// <para>The Counter mode generates a key-stream by encrypting successive values of an incrementing Big Endian ordered 128bit counter array (nonce). \n
/// In parallel mode, the generators counter is increased by a number factored from the number of input blocks, allowing for a multi-threaded operation. \n
/// The implementation is further parallelized by constructing a larger 'staggered' counter array, and processing large blocks using 128 or 256 SIMD instructions.</para>
/// 
/// <description><B>Description:</B></description>
/// <para><EM>Legend:</EM> \n 
/// <B>C</B>=pseudo-random, <B>K</B>=seed, <B>E</B>=encrypt \n
/// <EM>Generate</EM> \n
/// R0 ← IV. For 1 ≤ j ≤ t, Cj ← EK(Cj), C+1.</para> \n
///
/// <description><B>Initialization and Update:</B></description>
/// <para>The Initialize functions have three different parameter options: the Seed which is the primary key, 
/// the Nonce used to initialize the internal counter, and the Info which is used in the Generate function. \n
/// The Seed value must be one of the LegalKeySizes() in length, and must be a secret and random value. \n
/// The supported seed-sizes are calculated based on the block ciphers functions internal block size, and can vary depending on which cipher is used to instantiate the generator. \n
/// The 16 byte (NonceSize) Nonce value is another secret value, used to initialize the counter to a non-zero random value. \n
/// The Info parameter maps to the DistributionCode() property of an extended HX cipher, but is ignored when a standard cipher implementation is used. \n
/// The DistributionCode is recommended, and for best security, should be secret, random, and equal in length to the DistributionCodeMax() property \n 
/// The Update function uses the seed value to re-key the cipher via the internal key derivation function. \n
/// The update functions Seed parameter, must be a random seed value equal in length to the seed used to initialize the generator.</para>
///
/// <description><B>Multi-Threading:</B></description>
/// <para>The transformation function in a CTR generator is not limited by a dependency chain; this mode can be both SIMD pipelined and multi-threaded. \n
/// Output from the parallelized functions aligns with the output from a standard sequential CTR implementation processing an all zeroes input array. \n
/// Parallelism is achieved by pre-calculating the counters positional offset over multiple 'chunks' of key-stream, which are then generated independently across threads. \n 
/// The key stream generated by encrypting the counter array(s), is output as the source of pseudo-random.</para>
///
/// <description><B>Predictive Resistance:</B></description>
/// <para>Predictive and backtracking resistance prevent an attacker who has gained knowledge of generator state at some time from predicting future or previous outputs from the generator. \n
/// The optional resistance mechanism uses an entropy provider to add seed material to the generator, this new seed material is passed through a KDF2 generator along with the current state, 
/// the output is used to reseed the generator. \n
/// The interval at which this reseeding occurs is 1mb by default, but can be set using the ReseedThreshold() property; once this number of bytes or greater has been generated, the seed is regenerated. \n 
/// Predictive resistance is strongly recommended when producing large amounts of pseudo-random (10kb or greater).</para>
///
/// <description>Implementation Notes:</description>
/// <list type="bullet">
/// <item><description>The class constructor can either be initialized with a block cipher instance, or using the block ciphers enumeration name.</description></item>
/// <item><description>A block cipher or entropy provider instance created using the enumeration constructor, is automatically deleted when the class is destroyed.</description></item>
/// <item><description>An entropy provider can be specified through the constructor, which provides a continues stream of entropy to the reseed and generate functions, this is stronly recommended with large (+10kb) outputs.</description></item>
/// <item><description>The generator can be initialized with either a SymmetricKey key container class, or with a Seed and optional inputs of Nonce and Info.</description></item>
/// <item><description>The LegalKeySizes() property contains a list of supported seed sizes.</description></item>
/// <item><description>The LegalKeySizes() property contains a list of the supported seed sizes; note that if using the Nonce parameter of the Initialize function the combined (Seed + Nonce) must equal a legal size.</description></item>
/// <item><description>There are three LegalKeySizes, minimum, recommended, and maximum, with BCG, the middle value is the recommended seed length for best security; i.e. LegalKeySizes()[1].</description></item>
/// <item><description>The Generate() methods can not be used until an Initialize() function has been called, and the generator is seeded.</description></item>
/// <item><description>In a block cipher counter based generator, the encryption function can be both pipelined (SSE3-128 or AVX-256), and multi-threaded.</description></item>
/// <item><description>If the system supports Parallel processing, IsParallel() is set to true; passing an output block of ParallelBlockSize() to the Generate function.</description></item>
/// <item><description>The ParallelThreadsMax() property is the thread count in the parallel loop (pre-configured automatically); this must be either 1 (IsParallel=false), or an even number no greater than the number of processer cores on the system.</description></item>
/// <item><description>ParallelBlockSize() is calculated automatically based on the processor(s) L1 data cache size, this property can be user defined, and must be evenly divisible by ParallelMinimumSize().</description></item>
/// <item><description>The ParallelBlockSize() can be changed through the ParallelProfile() property</description></item>
/// <item><description>Parallel block calculation ex. <c>ParallelBlockSize = N - (N % .ParallelMinimumSize);</c></description></item>
/// </list>
/// 
/// <description>Guiding Publications:</description>
/// <list type="number">
/// <item><description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>: Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
/// <item><description>NIST <a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Fips 140-2</a>: Security Requirments For Cryptographic Modules.</description></item>
/// <item><description>NIST <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">SP800-22 1a</a>: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
/// <item><description>NIST <a href="http://eprint.iacr.org/2006/379.pdf">Security Bounds</a> for the Codebook-based: Deterministic Random Bit Generator.</description></item>
/// </list>
/// </remarks>
class BCG final : public IDrbg
{
private:

	static const size_t BLOCK_SIZE = 16;
	static const std::string CLASS_NAME;
	static const size_t COUNTER_SIZE = 16;
	static const size_t DEF_CYCTHRESH = 1024 * 1000;
	static const ulong MAX_OUTPUT = 35184372088832;
	static const size_t MAX_PRLALLOC = 100000000;
	static const size_t MAX_REQUEST = 65536;
	static const size_t MAX_RESEED = 536870912;
	static const size_t PRC_DATACACHE = 1024 * 16;

	std::unique_ptr<IBlockCipher> m_blockCipher;
	BlockCiphers m_cipherType;
	std::vector<byte> m_ctrVector;
	bool m_destroyEngine;
	std::vector<byte> m_distCode;
	size_t m_distCodeMax;
	bool m_isDestroyed;
	bool m_isEncryption;
	bool m_isInitialized;
	std::unique_ptr<IKdf> m_kdfEngine;
	BlockCipherExtensions m_kdfEngineType;
	std::vector<SymmetricKeySize> m_legalKeySizes;
	ParallelOptions m_parallelProfile;
	bool m_prdResistant;
	std::unique_ptr<IProvider> m_providerSource;
	Providers m_providerType;
	size_t m_reseedCounter;
	size_t m_reseedRequests;
	size_t m_reseedThreshold;
	size_t m_secStrength;
	size_t m_seedSize;

public:

	//~~~Constructor~~~//

	/// <summary>
	/// Copy constructor: copy is restricted, this function has been deleted
	/// </summary>
	BCG(const BCG&) = delete;

	/// <summary>
	/// Copy operator: copy is restricted, this function has been deleted
	/// </summary>
	BCG& operator=(const BCG&) = delete;

	/// <summary>
	/// Instantiate the class using a block cipher type-name, an optional entropy source type, and optional kdf hash-engine
	/// </summary>
	///
	/// <param name="CipherType">The block cipher type to instantiate as the primary generator.
	/// <para>The primary pseudo-random function, the default is AHX/RHX.</para></param>
	/// <param name="CipherExtensionType">The block-cipher extension, used to initialize an extended cipher
	/// The default is HKDF(SHA2-256).</para></param>
	/// <param name="ProviderType">The random provider-type, used to instantiate the entropy source. 
	/// <para>Adding a random provider enables predictive resistance, and is recommended for large data (>= 1MB).</para></param>
	/// <param name="Parallel">Enable/disable the multi-threading engine; default is false.
	/// <para>Parallel processing configuration can be tuned via the ParallelProfile accessor function.</para></param>
	///
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if an unrecognized block cipher type name is used</exception>
	explicit BCG(BlockCiphers CipherType = BlockCiphers::AHX, BlockCipherExtensions CipherExtensionType = BlockCipherExtensions::HKDF256, Providers ProviderType = Providers::None, bool Parallel = false);

	/// <summary>
	/// Instantiate the class using a block cipher instance and an optional entropy source
	/// </summary>
	/// 
	/// <param name="Cipher">The block cipher instance, acting as the primary pseudo random function</param>
	/// <param name="Kdf">The [optional] KDF instance used by the key extraction function.
	/// <para>Used at seed recycling intervals to extract keying material, and as an HX ciphers HKDF engine.</para></param>
	/// <param name="Provider">The [optional] entropy source, enabling predictive resistance; can be set to nullptr.
	/// <para>Adding a random provider enables predictive resistance, and is strongly recommended.</para></param>
	/// <param name="Parallel">Enable/disable the multi-threading engine; default is false.
	/// <para>Parallel processing configuration can be tuned via the ParallelProfile accessor function.</para></param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if a null block cipher is used</exception>
	explicit BCG(IBlockCipher* Cipher, IKdf* Kdf = nullptr, IProvider* Provider = nullptr, bool Parallel = false);

	/// <summary>
	/// Destructor: finalize this class
	/// </summary>
	~BCG() override;

	//~~~Accessors~~~//

	/// <summary>
	/// Read/Write: Reads or Sets the personalization string value in the KDF initialization parameters.
	/// <para>Must be set before <see cref="Initialize(ISymmetricKey)"/> is called.
	/// Changing this code will create a unique distribution of the generator.
	/// Code can be sized as either a zero byte array, or any length up to the DistributionCodeMax size.
	/// For best security, the distribution code should be random, secret, and equal in length to the DistributionCodeMax() size.</para>
	/// </summary>
	std::vector<byte> &DistributionCode() override;

	/// <summary>
	/// Read Only: The maximum size of the distribution code in bytes.
	/// <para>The distribution code can be used as a secondary source of entropy (secret) in an HX ciphers HKDF key expansion function.
	/// For best security, the distribution code should be random, secret, and equal in size to this value.</para>
	/// </summary>
	const size_t DistributionCodeMax() override;

	/// <summary>
	/// Read Only: The Drbg generators type name
	/// </summary>
	const Drbgs Enumeral() override;

	/// <summary>
	/// Read Only: Generator is ready to produce random
	/// </summary>
	const bool IsInitialized() override;

	/// <summary>
	/// Read Only: Processor parallelization availability.
	/// <para>Indicates whether parallel processing is available on this system.
	/// If parallel capable, the internal buffer is generated using multiple parallel streams.</para>
	/// </summary>
	const bool IsParallel();

	/// <summary>
	/// Read Only: Available Encryption Key Sizes in bytes
	/// </summary>
	std::vector<SymmetricKeySize> LegalKeySizes() const override;

	/// <summary>
	/// Read Only: The maximum number of bytes that can be generated with a generator instance
	/// </summary>
	const ulong MaxOutputSize() override;

	/// <summary>
	/// Read Only: The maximum number of bytes that can be generated in a single request
	/// </summary>
	const size_t MaxRequestSize() override;

	/// <summary>
	/// Read Only: The maximum number of times the generator can be reseeded
	/// </summary>
	const size_t MaxReseedCount() override;

	/// <summary>
	/// Read Only: The Drbg generators class name
	/// </summary>
	const std::string Name() override;

	/// <summary>
	/// Read Only: The size of the nonce counter value in bytes
	/// </summary>
	const size_t NonceSize() override;

	/// <summary>
	/// Read Only: Parallel block size; the byte-size of the requested output data array passed from the Generate function that triggers parallel processing.
	/// <para>This value can be changed through the ParallelProfile class.</para>
	/// </summary>
	const size_t ParallelBlockSize();

	/// <summary>
	/// Read/Write: Parallel and SIMD capability flags and sizes 
	/// <para>The maximum number of threads allocated when using multi-threaded processing can be set with the ParallelMaxDegree() property.
	/// The ParallelBlockSize() property is auto-calculated, but can be changed; the value must be evenly divisible by ParallelMinimumSize().
	/// Changes to these values must be made before the <see cref="Initialize(SymmetricKey)"/> function is called.</para>
	/// </summary>
	ParallelOptions &ParallelProfile();

	/// <summary>
	/// Read/Write: Generating this amount or greater, triggers seed regeneration
	/// </summary>
	size_t &ReseedThreshold() override;

	/// <summary>
	/// Read Only: The security strength in bits
	/// </summary>
	const size_t SecurityStrength() override;

	//~~~Public Functions~~~//

	/// <summary>
	/// Generate a block of pseudo random bytes
	/// </summary>
	/// 
	/// <param name="Output">Output array filled with random bytes</param>
	/// 
	/// <returns>The number of bytes generated</returns>
	size_t Generate(std::vector<byte> &Output) override;

	/// <summary>
	/// Generate pseudo random bytes using offset and length parameters
	/// </summary>
	/// 
	/// <param name="Output">Output array filled with random bytes</param>
	/// <param name="OutOffset">The starting position within the Output array</param>
	/// <param name="Length">The number of bytes to generate</param>
	/// 
	/// <returns>The number of bytes generated</returns>
	size_t Generate(std::vector<byte> &Output, size_t OutOffset, size_t Length) override;

	/// <summary>
	/// Initialize the generator with a SymmetricKey structure containing the key, and optional nonce, and info string.
	/// </summary>
	/// 
	/// <param name="GenParam">The SymmetricKey containing the generators keying material</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the seed is not a legal seed size</exception>
	void Initialize(ISymmetricKey &GenParam) override;

	/// <summary>
	/// Initialize the generator with a key.
	/// </summary>
	/// 
	/// <param name="Seed">The primary key array used to seed the generator</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the seed is not a legal seed size</exception>
	void Initialize(const std::vector<byte> &Seed) override;

	/// <summary>
	/// Initialize the generator with key and nonce arrays.
	/// <para>The combined Seed and Nonce length must equal a LegalSeedSize.</para>
	/// </summary>
	/// 
	/// <param name="Seed">The primary key array used to seed the generator</param>
	/// <param name="Nonce">The nonce value containing an additional source of entropy</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the seed is not a legal seed size</exception>
	void Initialize(const std::vector<byte> &Seed, const std::vector<byte> &Nonce) override;

	/// <summary>
	/// Initialize the generator with a key, a nonce array, and an information string.
	/// <para>The combined Seed and Nonce length must equal a LegalSeedSize.
	/// The Info parameter maps to an extended HX cipher DistributionCode property. 
	/// For best security this value should be secret, random and DistributionCodeMax in length.
	/// If a standard cipher is used, the Info parameter is ignored.</para>
	/// </summary>
	/// 
	/// <param name="Seed">The primary key array used to seed the generator</param>
	/// <param name="Nonce">The nonce value used as an additional source of entropy</param>
	/// <param name="Info">The information string or nonce used to create a unique distribution or as a third source of entropy</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the key is not a legal size</exception>
	void Initialize(const std::vector<byte> &Seed, const std::vector<byte> &Nonce, const std::vector<byte> &Info) override;

	/// <summary>
	/// Set the maximum number of threads allocated when using multi-threaded processing.
	/// <para>When set to zero, thread count is set automatically. If set to 1, runs in sequential mode. 
	/// Thread count must be an even number, and not exceed the number of processor cores (times 2 for hyperthreading).</para>
	/// </summary>
	///
	/// <param name="Degree">The desired number of threads</param>
	///
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if an invalid degree setting is used</exception>
	void ParallelMaxDegree(size_t Degree);

	/// <summary>
	/// Update the generators seed value.
	/// <para>Triggers a reseed with the new seed. The seed value must be equal in size to the seed used to initialize the generator</para>
	/// </summary>
	/// 
	/// <param name="Seed">The secret seed array</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the seed is too small</exception>
	void Update(const std::vector<byte> &Seed) override;

private:

	void Derive(std::vector<byte> &Seed);
	void GenerateBlock(std::vector<byte> &Output, size_t OutOffset, size_t Length);
	void Transform(std::vector<byte> &Output, const size_t OutOffset, const size_t Length, std::vector<byte> &Counter);
};

NAMESPACE_DRBGEND
#endif
