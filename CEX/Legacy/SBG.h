// The MIT License (MIT)
// 
// Copyright (c) 2016 vtdev.com
// This file is part of the CEX Cryptographic library.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// Implementation Details:
// An implementation of a Salsa20 Counter based Deterministic Random Byte Generator (SBG)
// Written by John Underhill, November 21, 2014
// Updated: September 25, 2016
// Contact: develop@vtdev.com

#ifndef _CEXENGINE_SBG_H
#define _CEXENGINE_SBG_H

#include "IDrbg.h"

NAMESPACE_DRBG

/// <summary>
/// An implementation of a Salsa20 Based Generator (SBG)
/// </summary>
/// 
/// <example>
/// <description>Generate an array of pseudo random bytes:</description>
/// <code>
/// SBG rnd(20);
/// // initialize
/// rnd.Initialize(Seed, [Nonce], [Info]);
/// // generate bytes
/// rnd.Generate(Output, [Offset], [Size]);
/// </code>
/// </example>
/// 
/// <remarks>
/// <description><B>Overview:</B></description>
/// <para>The Salsa20 DRBG generates a key-stream by encrypting successive values of an incrementing 32bit unsigned integer counter array.<BR></BR>
/// In parallel mode, the counter is increased by a number factored from the number of input blocks, allowing for a multi-threaded operation.<BR></BR>
/// The implementation is further parallelized by constructing a larger 'staggered' counter array, and processing large blocks using 128 or 256 SIMD instructions.</para>
/// 
/// <description><B>Description:</B></description>
/// <para><EM>Legend:</EM><BR></BR> 
/// <B>C</B>=pseudo-random, <B>K</B>=seed, <B>E</B>=encrypt<BR></BR>
/// <EM>Generate</EM><BR></BR>
/// C0 ← IV. For 1 ≤ j ≤ t, Cj ← EK(Cj), C+1.<BR></BR></para>
///
/// <description><B>Multi-Threading:</B></description>
/// <para>The transformation function used by Salsa is not limited by a dependency chain; this mode can be both SIMD pipelined and multi-threaded.<BR></BR>
/// This is acheived by pre-calculating the counters positional offset over multiple 'chunks' of key-stream, which are then generated independently across threads.<BR></BR> 
/// The key stream generated by encrypting the counter array(s), is output as a source of random.</para>
///
/// <description>Implementation Notes:</description>
/// <list type="bullet">
/// <item><description>Valid Seed sizes are 24 and 40 bytes.</description></item>
/// <item><description>Block size is 64 bytes wide.</description></item>
/// <item><description>Valid rounds are 8 through 30 in increments of 2.</description></item>
/// <item><description>Encryption can both be pipelined (SSE3-128 or AVX-256), and multi-threaded.</description></item>
/// <item><description>The Generate functions are virtual, and can be accessed from an IDrbg instance.</description></item>
/// <item><description>The Generate methods can not be called until the Initialize(KeyParams) function has been called.</description></item>
/// <item><description>Parallel processing is enabled by setting IsParallel() to true.</description></item>
/// <item><description>The ParallelThreadsMax() property is used as the thread count in the parallel loop; this must be an even number no greater than the number of processer cores on the system.</description></item>
/// <item><description>ParallelBlockSize() is calculated automatically based on processor(s) cache size but can be user defined, but must be evenly divisible by ParallelMinimumSize().</description></item>
/// </list>
/// 
/// <description>Guiding Publications:</description>
/// <list type="number">
/// <item><description>Salsa20 <a href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</a>.</description></item>
/// <item><description>Salsa20 <a href="http://cr.yp.to/snuffle/design.pdf">Design</a>.</description></item>
/// <item><description>Salsa20 <a href="http://cr.yp.to/snuffle/security.pdf">Security</a>.</description></item>
/// </list>
/// 
/// </remarks>
class SBG : public IDrbg
{
private:

	SBG(const SBG&) = delete;
	SBG& operator=(const SBG&) = delete;
	SBG& operator=(SBG&&) = delete;

	static constexpr size_t BLOCK_SIZE = 64;
	static constexpr size_t CTR_SIZE = 8;
	static constexpr size_t DEFAULT_ROUNDS = 20;
	static constexpr size_t KEY_SIZE = 24;
	static constexpr size_t MAX_PRLALLOC = 100000000;
	static constexpr size_t MAX_ROUNDS = 30;
	static constexpr size_t MIN_ROUNDS = 8;
	static constexpr size_t PRC_DATACACHE = 32000;
	static constexpr const char *SIGMA = "expand 32-byte k";
	static constexpr size_t CYC_THRESHOLD = 10;

	std::vector<uint> m_ctrVector;
	size_t m_reseedCounter;
	size_t m_reseedThreshold;
	bool m_destroyEngine;
	std::vector<byte> m_dstCode;
	IProvider* m_entSource;
	Providers m_entropyType;
	bool m_hasAVX2;
	bool m_hasSSE;
	bool m_isDestroyed;
	bool m_isInitialized;
	bool m_isParallel;
	std::vector<size_t> m_legalSeedSizes;
	std::vector<size_t> m_legalRounds;
	size_t m_parallelBlockSize;
	size_t m_parallelMaxDegree;
	size_t m_parallelMinimumSize;
	bool m_prdResistant;
	size_t m_processorCount;
	size_t m_rndCount;
	size_t m_secStrength;
	std::vector<uint> m_wrkState;

public:

	//~~~Properties~~~//

	/// <summary>
	/// Get/Set: The maximum output generated between seed recycling
	/// </summary>
	virtual size_t &ReseedThreshold() { return m_reseedCounter; }

	/// <summary>
	/// Get: The generators type name
	/// </summary>
	virtual const Drbgs Enumeral() { return Drbgs::SBG; }

	/// <summary>
	/// Get: Generator is ready to produce random
	/// </summary>
	virtual const bool IsInitialized() { return m_isInitialized; }

	/// <summary>
	/// Get/Set: Automatic processor parallelization
	/// </summary>
	bool &IsParallel() { return m_isParallel; }

	/// <summary>
	/// Get: Available Encryption Key Sizes in bytes
	/// </summary>
	virtual const std::vector<size_t> &LegalSeedSizes() { return m_legalSeedSizes; };

	/// <summary>
	/// Get: Available diffusion round assignments
	/// </summary>
	const std::vector<size_t> &LegalRounds() { return m_legalRounds; }

	/// <summary>
	/// Get: Cipher name
	/// </summary>
	virtual const char *Name() { return "SBG"; }

	/// <summary>
	/// Get/Set: Parallel block size. Must be a multiple of <see cref="ParallelMinimumSize"/>.
	/// </summary>
	size_t &ParallelBlockSize() { return m_parallelBlockSize; }

	/// <summary>
	/// Get: Maximum input size with parallel processing
	/// </summary>
	const size_t ParallelMaximumSize() { return MAX_PRLALLOC; }

	/// <summary>
	/// Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
	/// </summary>
	const size_t ParallelMinimumSize() { return m_parallelMinimumSize; }

	/// <summary>
	/// Get: The maximum number of threads allocated when using multi-threaded processing
	/// </summary>
	const size_t ParallelThreadsMax() { return m_parallelMaxDegree; }

	/// <remarks>
	/// Get: Processor count
	/// </remarks>
	const size_t ProcessorCount() { return m_processorCount; }

	/// <summary>
	/// Get: The security strength in bits
	/// </summary>
	virtual const size_t SecurityStrength() { return m_secStrength; }

	//~~~Constructor~~~//

	/// <summary>
	/// Initialize the SP20 generator with an optional entropy source type
	/// </summary>
	/// 
	/// <param name="Rounds">The number of transformation rounds</param>
	/// <param name="ProviderType">The enumeration type name of an entropy source; enables predictive resistance</param>
	explicit SBG(size_t Rounds = 20, Providers ProviderType = Providers::None)
		:
		m_ctrVector(2, 0),
		m_reseedCounter(1),
		m_reseedThreshold(CYC_THRESHOLD),
		m_destroyEngine(true),
		m_dstCode(0),
		m_entropyType(ProviderType),
		m_hasAVX2(false),
		m_hasSSE(false),
		m_isDestroyed(false),
		m_isInitialized(false),
		m_isParallel(false),
		m_parallelBlockSize(0),
		m_parallelMaxDegree(0),
		m_parallelMinimumSize(0),
		m_rndCount(Rounds),
		m_wrkState(14, 0)
	{
		if (Rounds < 8 || Rounds > 30 || Rounds % 2 != 0)
			throw CryptoGeneratorException("SBG:Ctor", "The rounds parameter must be an even number between 8 and 30!");

		if (m_entropyType != Providers::None)
			m_entSource = LoadProvider(ProviderType);

		m_prdResistant = m_entropyType != Providers::None;
		m_legalSeedSizes = { 24, 40 };
		m_legalRounds = { 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30 };
		Scope();
	}

	/// <summary>
	/// Initialize the SP20 generator an optional entropy source instance
	/// </summary>
	/// 
	/// <param name="ProviderType">Provides an entropy source enabling predictive resistance, can be null</param>
	/// <param name="Rounds">The number of transformation rounds</param>
	explicit SBG(size_t Rounds, IProvider* Entropy)
		:
		m_ctrVector(2, 0),
		m_reseedCounter(1),
		m_reseedThreshold(CYC_THRESHOLD),
		m_destroyEngine(false),
		m_dstCode(0),
		m_entSource(Entropy),
		m_hasAVX2(false),
		m_hasSSE(false),
		m_isDestroyed(false),
		m_isInitialized(false),
		m_isParallel(false),
		m_parallelBlockSize(0),
		m_parallelMaxDegree(0),
		m_parallelMinimumSize(0),
		m_rndCount(Rounds),
		m_wrkState(14, 0)
	{
		if (Rounds < 8 || Rounds > 30 || Rounds % 2 != 0)
			throw CryptoGeneratorException("SBG:Ctor", "The rounds parameter must be an even number between 8 and 30!");

		if (m_entSource != 0)
			m_entropyType = m_entSource->Enumeral();

		m_prdResistant = m_entropyType != Providers::None;
		m_legalSeedSizes = { 24, 40 };
		m_legalRounds = { 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30 };
		Scope();
	}

	/// <summary>
	/// Finalize objects
	/// </summary>
	virtual ~SBG()
	{
		Destroy();
	}

	//~~~Public Methods~~~//

	/// <summary>
	/// Release all resources associated with the object
	/// </summary>
	virtual void Destroy();

	/// <summary>
	/// Generate a block of pseudo random bytes
	/// </summary>
	/// 
	/// <param name="Output">Output array filled with random bytes</param>
	/// 
	/// <returns>The number of bytes generated</returns>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the output array is too small</exception>
	virtual size_t Generate(std::vector<byte> &Output);

	/// <summary>
	/// Generate pseudo random bytes using offset and length parameters
	/// </summary>
	/// 
	/// <param name="Output">Output array filled with random bytes</param>
	/// <param name="OutOffset">The starting position within the Output array</param>
	/// <param name="Length">The number of bytes to generate</param>
	/// 
	/// <returns>The number of bytes generated</returns>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the output array is too small</exception>
	virtual size_t Generate(std::vector<byte> &Output, size_t OutOffset, size_t Length);

	/// <summary>
	/// Initialize the generator with a RngParams structure containing the key, and optional nonce, and info string.
	/// <para>The combined length of the keying material must be a legal key size; 24 or 40 bytes.</para>
	/// </summary>
	/// 
	/// <param name="GenParam">The RngParams containing the generators keying material</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the key is not a legal size</exception>
	virtual void Initialize(const RngParams &GenParam);

	/// <summary>
	/// Initialize the generator with a key.
	/// <para>The key length must be a legal key size; 24 or 40 bytes.</para>
	/// </summary>
	/// 
	/// <param name="Seed">The primary key array used to seed the generator</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the key is not a legal size</exception>
	virtual void Initialize(const std::vector<byte> &Seed);

	/// <summary>
	/// Initialize the generator with key and nonce arrays.
	/// <para>The combined length of the keying material must be a legal key size; 24 or 40 bytes.</para>
	/// </summary>
	/// 
	/// <param name="Seed">The primary key array used to seed the generator</param>
	/// <param name="Nonce">The nonce value containing an additional source of entropy</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the key is not a legal size</exception>
	virtual void Initialize(const std::vector<byte> &Seed, const std::vector<byte> &Nonce);

	/// <summary>
	/// Initialize the generator with a key, a nonce array, and an information string or nonce.
	/// <para>The combined length of the keying material must be a legal key size; 24 or 40 bytes.</para>
	/// </summary>
	/// 
	/// <param name="Seed">The primary key array used to seed the generator</param>
	/// <param name="Nonce">The nonce value used as an additional source of entropy</param>
	/// <param name="Info">The information string or nonce used as a third source of entropy</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the key is not a legal size</exception>
	virtual void Initialize(const std::vector<byte> &Seed, const std::vector<byte> &Nonce, const std::vector<byte> &Info);

	/// <summary>
	/// Set the maximum number of threads allocated when using multi-threaded processing.
	/// <para>When set to zero, thread count is set automatically. If set to 1, sets IsParallel() to false and runs in sequential mode. 
	/// Thread count must be an even number, and not exceed the number of processor cores.</para>
	/// </summary>
	///
	/// <param name="Degree">The desired number of threads</param>
	///
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if an invalid degree setting is used</exception>
	void ParallelMaxDegree(size_t Degree);

	/// <summary>
	/// Update the generators seed value.
	/// <para>If the nonce array size is equal to a legal key size, the key and counter are replaced with the new values.
	/// If the nonce array size is equal to the counter value (8 bytes), the counter is replaced.</para>
	/// </summary>
	/// 
	/// <param name="Seed">The new nonce value array</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the seed is too small</exception>
	virtual void Update(const std::vector<byte> &Seed);

private:
	void Detect();
	void Expand(const std::vector<byte> &Seed, const std::vector<byte> &Iv);
	void Generate(std::vector<byte> &Output, const size_t OutOffset, std::vector<uint> &Counter, const size_t Length);
	void Increase(const std::vector<uint> &Input, std::vector<uint> &Output, const size_t Length);
	void Increment(std::vector<uint> &Counter);
	IProvider* LoadProvider(Providers ProviderType);
	void Process(std::vector<byte> &Output, const size_t OutOffset, const size_t Length);
	void Scope();
};

NAMESPACE_DRBGEND
#endif
