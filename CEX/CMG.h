// The GPL version 3 License (GPLv3)
// 
// Copyright (c) 2017 vtdev.com
// This file is part of the CEX Cryptographic library.
// 
// This program is free software : you can redistribute it and / or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.If not, see <http://www.gnu.org/licenses/>.
//
// 
// Implementation Details:
// An implementation of a Counter based Deterministic Random Byte Generator (CMG)
// Written by John Underhill, November 21, 2015
// Updated October 23, 2016
// Contact: develop@vtdev.com

#ifndef _CEX_CMG_H
#define _CEX_CMG_H

#include "IDrbg.h"
#include "BlockCiphers.h"
#include "Digests.h"
#include "IBlockCipher.h"
#include "IDigest.h"
#include "ParallelOptions.h"

NAMESPACE_DRBG

using Enumeration::BlockCiphers;
using Enumeration::Digests;
using Cipher::Symmetric::Block::IBlockCipher;
using Digest::IDigest;

using Common::ParallelOptions;

/// <summary>
/// An implementation of a block cipher Counter Mode Generator (CMG)
/// </summary> 
/// 
/// <example>
/// <description>Generate an array of pseudo random bytes:</description>
/// <code>
/// CMG rng(BlockCiphers::RHX, Digests::SHA512, [Providers::CSP]);
/// // initialize
/// rng.Initialize(Seed, [Nonce], [Info]);
/// // generate bytes
/// rng.Generate(Output, [Offset], [Length]);
/// </code>
/// </example>
/// 
/// <remarks>
/// <description><B>Overview:</B></description>
/// <para>The Counter mode generates a key-stream by encrypting successive values of an incrementing Big Endian ordered 128bit counter array (nonce).<BR></BR>
/// In parallel mode, the generators counter is increased by a number factored from the number of input blocks, allowing for a multi-threaded operation.<BR></BR>
/// The implementation is further parallelized by constructing a larger 'staggered' counter array, and processing large blocks using 128 or 256 SIMD instructions.</para>
/// 
/// <description><B>Description:</B></description>
/// <para><EM>Legend:</EM><BR></BR> 
/// <B>C</B>=pseudo-random, <B>K</B>=seed, <B>E</B>=encrypt<BR></BR>
/// <EM>Generate</EM><BR></BR>
/// R0 ← IV. For 1 ≤ j ≤ t, Cj ← EK(Cj), C+1.</para><BR></BR>
///
/// <description><B>Initialization and Update:</B></description>
/// <para>The Initialize functions have three different parameter options: the Seed which is the primary key, 
/// the Nonce used to initialize the internal counter, and the Info which is used in the Generate function.<BR></BR>
/// The Seed value must be one of the LegalKeySizes() in length, and must be a secret and random value.<BR></BR>
/// The supported seed-sizes are calculated based on the block ciphers functions internal block size, and can vary depending on which cipher is used to instantiate the generator.<BR></BR>
/// The 16 byte (NonceSize) Nonce value is another secret value, used to initialize the counter to a non-zero random value.<BR></BR>
/// The Info parameter maps to the DistributionCode() property of an extended HX cipher, but is ignored when a standard cipher implementation is used.<BR></BR>
/// The DistributionCode is recommended, and for best security, should be secret, random, and equal in length to the DistributionCodeMax() property<BR></BR> 
/// The Update function uses the seed value to re-key the cipher via the internal key derivation function.<BR></BR>
/// The update functions Seed parameter, must be a random seed value equal in length to the seed used to initialize the generator.</para>
///
/// <description><B>Multi-Threading:</B></description>
/// <para>The transformation function in a CTR generator is not limited by a dependency chain; this mode can be both SIMD pipelined and multi-threaded.<BR></BR>
/// Output from the parallelized functions aligns with the output from a standard sequential CTR implementation processing an all zeroes input array.<BR></BR>
/// Parallelism is achieved by pre-calculating the counters positional offset over multiple 'chunks' of key-stream, which are then generated independently across threads.<BR></BR> 
/// The key stream generated by encrypting the counter array(s), is output as the source of pseudo-random.</para>
///
/// <description><B>Predictive Resistance:</B></description>
/// <para>Predictive and backtracking resistance prevent an attacker who has gained knowledge of generator state at some time from predicting future or previous outputs from the generator.<BR></BR>
/// The optional resistance mechanism uses an entropy provider to add seed material to the generator, this new seed material is passed through a KDF2 generator along with the current state, 
/// the output is used to reseed the generator.<BR></BR>
/// The interval at which this reseeding occurs is 1mb by default, but can be set using the ReseedThreshold() property; once this number of bytes or greater has been generated, the seed is regenerated.<BR></BR> 
/// Predictive resistance is strongly recommended when producing large amounts of pseudo-random (10kb or greater).</para>
///
/// <description>Implementation Notes:</description>
/// <list type="bullet">
/// <item><description>The class constructor can either be initialized with a block cipher instance, or using the block ciphers enumeration name.</description></item>
/// <item><description>A block cipher or entropy provider instance created using the enumeration constructor, is automatically deleted when the class is destroyed.</description></item>
/// <item><description>An entropy provider can be specified through the constructor, which provides a continues stream of entropy to the reseed and generate functions, this is stronly recommended with large (+10kb) outputs.</description></item>
/// <item><description>The generator can be initialized with either a SymmetricKey key container class, or with a Seed and optional inputs of Nonce and Info.</description></item>
/// <item><description>The LegalKeySizes() property contains a list of supported seed sizes.</description></item>
/// <item><description>The LegalKeySizes() property contains a list of the supported seed sizes; note that if using the Nonce parameter of the Initialize function the combined (Seed + Nonce) must equal a legal size.</description></item>
/// <item><description>There are three LegalKeySizes, minimum, recommended, and maximum, with CMG, the middle value is the recommended seed length for best security; i.e. LegalKeySizes()[1].</description></item>
/// <item><description>The Generate() methods can not be used until an Initialize() function has been called, and the generator is seeded.</description></item>
/// <item><description>In a block cipher counter based generator, the encryption function can be both pipelined (SSE3-128 or AVX-256), and multi-threaded.</description></item>
/// <item><description>If the system supports Parallel processing, IsParallel() is set to true; passing an output block of ParallelBlockSize() to the Generate function.</description></item>
/// <item><description>The ParallelThreadsMax() property is the thread count in the parallel loop (pre-configured automatically); this must be either 1 (IsParallel=false), or an even number no greater than the number of processer cores on the system.</description></item>
/// <item><description>ParallelBlockSize() is calculated automatically based on the processor(s) L1 data cache size, this property can be user defined, and must be evenly divisible by ParallelMinimumSize().</description></item>
/// <item><description>The ParallelBlockSize() can be changed through the ParallelProfile() property</description></item>
/// <item><description>Parallel block calculation ex. <c>ParallelBlockSize = N - (N % .ParallelMinimumSize);</c></description></item>
/// </list>
/// 
/// <description>Guiding Publications:</description>
/// <list type="number">
/// <item><description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>: Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
/// <item><description>NIST <a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Fips 140-2</a>: Security Requirments For Cryptographic Modules.</description></item>
/// <item><description>NIST <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">SP800-22 1a</a>: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
/// <item><description>NIST <a href="http://eprint.iacr.org/2006/379.pdf">Security Bounds</a> for the Codebook-based: Deterministic Random Bit Generator.</description></item>
/// </list>
/// </remarks>
class CMG : public IDrbg
{
private:

	static const size_t COUNTER_SIZE = 16;
	static const size_t DEF_CYCTHRESH = 1024 * 1000;
	const uint64_t MAX_OUTPUT = 35184372088832;
	const size_t MAX_PRLALLOC = 100000000;
	const size_t MAX_REQUEST = 65536;
	const size_t MAX_RESEED = 536870912;
	const size_t PRC_DATACACHE = 1024 * 16;

	IBlockCipher* m_blockCipher;
	size_t m_blockSize;
	BlockCiphers m_cipherType;
	std::vector<byte> m_ctrVector;
	bool m_destroyEngine;
	std::vector<byte> m_distributionCode;
	size_t m_distributionCodeMax;
	bool m_isDestroyed;
	bool m_isEncryption;
	bool m_isInitialized;
	IDigest* m_kdfEngine;
	Digests m_kdfEngineType;
	std::vector<byte> m_kdfInfo;
	std::vector<SymmetricKeySize> m_legalKeySizes;
	ParallelOptions m_parallelProfile;
	bool m_prdResistant;
	IProvider* m_providerSource;
	Providers m_providerType;
	size_t m_reseedCounter;
	size_t m_reseedRequests;
	size_t m_reseedThreshold;
	size_t m_secStrength;
	size_t m_seedSize;

public:

	CMG(const CMG&) = delete;
	CMG& operator=(const CMG&) = delete;
	CMG& operator=(CMG&&) = delete;

	//~~~Properties~~~//

	/// <summary>
	/// Get/Set: Reads or Sets the personalization string value in the KDF initialization parameters.
	/// <para>Must be set before <see cref="Initialize(ISymmetricKey)"/> is called.
	/// Changing this code will create a unique distribution of the generator.
	/// Code can be sized as either a zero byte array, or any length up to the DistributionCodeMax size.
	/// For best security, the distribution code should be random, secret, and equal in length to the DistributionCodeMax() size.</para>
	/// </summary>
	virtual std::vector<byte> &DistributionCode() { return m_distributionCode; }

	/// <summary>
	/// Get: The maximum size of the distribution code in bytes.
	/// <para>The distribution code can be used as a secondary source of entropy (secret) in an HX ciphers HKDF key expansion function.
	/// For best security, the distribution code should be random, secret, and equal in size to this value.</para>
	/// </summary>
	virtual const size_t DistributionCodeMax() { return m_distributionCodeMax; }

	/// <summary>
	/// Get: The Drbg generators type name
	/// </summary>
	virtual const Drbgs Enumeral() { return Drbgs::CMG; }

	/// <summary>
	/// Get: Generator is ready to produce random
	/// </summary>
	virtual const bool IsInitialized() { return m_isInitialized; }

	/// <summary>
	/// Get: Processor parallelization availability.
	/// <para>Indicates whether parallel processing is available on the system.</para>
	/// </summary>
	const bool IsParallel() { return m_parallelProfile.IsParallel(); }

	/// <summary>
	/// Get: Available Encryption Key Sizes in bytes
	/// </summary>
	virtual std::vector<SymmetricKeySize> LegalKeySizes() const { return m_legalKeySizes; };

	/// <summary>
	/// Get: The maximum number of bytes that can be generated with a generator instance
	/// </summary>
	virtual const uint64_t MaxOutputSize() { return MAX_OUTPUT; }

	/// <summary>
	/// Get: The maximum number of bytes that can be generated in a single request
	/// </summary>
	virtual const size_t MaxRequestSize() { return MAX_REQUEST; }

	/// <summary>
	/// Get: The maximum number of times the generator can be reseeded
	/// </summary>
	virtual const size_t MaxReseedCount() { return MAX_RESEED; }

	/// <summary>
	/// Get: The Drbg generators class name
	/// </summary>
	virtual const std::string Name() { return "CMG"; }

	/// <summary>
	/// Get: The size of the nonce counter value in bytes
	/// </summary>
	virtual const size_t NonceSize() { return COUNTER_SIZE; }

	/// <summary>
	/// Get: Parallel block size; the byte-size of the input/output data arrays passed to a transform that trigger parallel processing.
	/// <para>This value can be changed through the ParallelProfile class.<para>
	/// </summary>
	const size_t ParallelBlockSize() { return m_parallelProfile.ParallelBlockSize(); }

	/// <summary>
	/// Get/Set: Parallel and SIMD capability flags and sizes 
	/// <para>The maximum number of threads allocated when using multi-threaded processing can be set with the ParallelMaxDegree() property.
	/// The ParallelBlockSize() property is auto-calculated, but can be changed; the value must be evenly divisible by ParallelMinimumSize().
	/// Changes to these values must be made before the <see cref="Initialize(SymmetricKey)"/> function is called.</para>
	/// </summary>
	ParallelOptions &ParallelProfile() { return m_parallelProfile; }

	/// <summary>
	/// Get/Set: Generating this amount or greater, triggers seed regeneration
	/// </summary>
	virtual size_t &ReseedThreshold() { return m_reseedThreshold; }

	/// <summary>
	/// Get: The security strength in bits
	/// </summary>
	virtual const size_t SecurityStrength() { return m_secStrength; }

	//~~~Constructor~~~//

	/// <summary>
	/// Instantiate the class using a block cipher type-name, an optional entropy source type, and optional kdf hash-engine
	/// </summary>
	///
	/// <param name="CipherType">The block cipher type to instantiate as the primary generator.
	/// <para>The primary pseudo random function, the default is AHX/RHX,</para></param>
	/// <param name="KdfEngineType">The KDF2 key derivation functions hash engine-type.
	/// <para>Used at seed recycling intervals to extract keying material, and as an HX ciphers HKDF engine.</para></param>
	/// <param name="ProviderType">The random provider-type, used to instantiate the entropy source. 
	/// <para>Adding a random provider enables predictive resistance, and is strongly recommended.</para></param>
	///
	/// <exception cref="Exception::CryptoCipherModeException">Thrown if an unrecognized block cipher type name is used</exception>
	explicit CMG(BlockCiphers CipherType = BlockCiphers::AHX, Digests KdfEngineType = Digests::SHA512, Providers ProviderType = Providers::CSP);

	/// <summary>
	/// Instantiate the class using a block cipher instance and an optional entropy source
	/// </summary>
	/// 
	/// <param name="Cipher">The block cipher instance, acting as the primary pseudo random function</param>
	/// <param name="KdfEngine">The [optional] message digest instance used by the key extraction function.
	/// <para>Used at seed recycling intervals to extract keying material, and as an HX ciphers HKDF engine.</para></param>
	/// <param name="Provider">The [optional] entropy source, enabling predictive resistance; can be set to null.
	/// <para>Adding a random provider enables predictive resistance, and is strongly recommended.</para></param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if a null block cipher is used</exception>
	explicit CMG(IBlockCipher* Cipher, IDigest* KdfEngine = 0, IProvider* Provider = 0);

	/// <summary>
	/// Finalize objects
	/// </summary>
	virtual ~CMG();

	//~~~Public Functions~~~//

	/// <summary>
	/// Release all resources associated with the object
	/// </summary>
	virtual void Destroy();

	/// <summary>
	/// Generate a block of pseudo random bytes
	/// </summary>
	/// 
	/// <param name="Output">Output array filled with random bytes</param>
	/// 
	/// <returns>The number of bytes generated</returns>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the output array is too small</exception>
	virtual size_t Generate(std::vector<byte> &Output);

	/// <summary>
	/// Generate pseudo random bytes using offset and length parameters
	/// </summary>
	/// 
	/// <param name="Output">Output array filled with random bytes</param>
	/// <param name="OutOffset">The starting position within the Output array</param>
	/// <param name="Length">The number of bytes to generate</param>
	/// 
	/// <returns>The number of bytes generated</returns>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the output array is too small</exception>
	virtual size_t Generate(std::vector<byte> &Output, size_t OutOffset, size_t Length);

	/// <summary>
	/// Initialize the generator with a SymmetricKey structure containing the key, and optional nonce, and info string.
	/// </summary>
	/// 
	/// <param name="GenParam">The SymmetricKey containing the generators keying material</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the key is not a legal size</exception>
	virtual void Initialize(ISymmetricKey &GenParam);

	/// <summary>
	/// Initialize the generator with a key.
	/// </summary>
	/// 
	/// <param name="Seed">The primary key array used to seed the generator</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the key is not a legal size</exception>
	virtual void Initialize(const std::vector<byte> &Seed);

	/// <summary>
	/// Initialize the generator with key and nonce arrays.
	/// <para>The combined Seed and Nonce length must equal a LegalSeedSize.</para>
	/// </summary>
	/// 
	/// <param name="Seed">The primary key array used to seed the generator</param>
	/// <param name="Nonce">The nonce value containing an additional source of entropy</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the key is not a legal size</exception>
	virtual void Initialize(const std::vector<byte> &Seed, const std::vector<byte> &Nonce);

	/// <summary>
	/// Initialize the generator with a key, a nonce array, and an information string.
	/// <para>The combined Seed and Nonce length must equal a LegalSeedSize.
	/// The Info parameter maps to an extended HX cipher DistributionCode property. 
	/// For best security this value should be secret, random and DistributionCodeMax in length.
	/// If a standard cipher is used, the Info parameter is ignored.</para>
	/// </summary>
	/// 
	/// <param name="Seed">The primary key array used to seed the generator</param>
	/// <param name="Nonce">The nonce value used as an additional source of entropy</param>
	/// <param name="Info">The information string or nonce used to create a unique distribution or as a third source of entropy</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the key is not a legal size</exception>
	virtual void Initialize(const std::vector<byte> &Seed, const std::vector<byte> &Nonce, const std::vector<byte> &Info);

	/// <summary>
	/// Set the maximum number of threads allocated when using multi-threaded processing.
	/// <para>When set to zero, thread count is set automatically. If set to 1, runs in sequential mode. 
	/// Thread count must be an even number, and not exceed the number of processor cores.</para>
	/// </summary>
	///
	/// <param name="Degree">The desired number of threads</param>
	///
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if an invalid degree setting is used</exception>
	void ParallelMaxDegree(size_t Degree);

	/// <summary>
	/// Update the generators seed value.
	/// <para>Triggers a reseed with the new seed. The seed value must be equal in size to the seed used to initialize the generator</para>
	/// </summary>
	/// 
	/// <param name="Seed">The secret seed array</param>
	/// 
	/// <exception cref="Exception::CryptoGeneratorException">Thrown if the seed is too small</exception>
	virtual void Update(const std::vector<byte> &Seed);

private:

	void Derive(std::vector<byte> &Seed);
	void Generate(std::vector<byte> &Output, size_t OutOffset);
	void Transform(std::vector<byte> &Output, const size_t OutOffset, const size_t Length, std::vector<byte> &Counter);
};

NAMESPACE_DRBGEND
#endif
