// The GPL version 3 License (GPLv3)
// 
// Copyright (c) 2016 vtdev.com
// This file is part of the CEX Cryptographic library.
// 
// This program is free software : you can redistribute it and / or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.If not, see <http://www.gnu.org/licenses/>.
//
// 
// Principal Algorithms:
// This cipher is based on the ChaCha stream cipher designed by Daniel J. Bernstein:
// ChaCha: <a href="http://cr.yp.to/chacha/chacha-20080128.pdf"/>
// 
// Implementation Details:
// ChaCha20: An implementation of the ChaCha stream cipher
// Written by John Underhill, October 21, 2014
// Updated September 24, 2016
// Contact: develop@vtdev.com

#ifndef _CEX_CHACHA20_H
#define _CEX_CHACHA20_H

#include "IStreamCipher.h"

NAMESPACE_STREAM

/// <summary>
/// A parallelized ChaCha stream cipher implementation
/// </summary>
/// 
/// <example>
/// <description>Encrypting using parallel processing:</description>
/// <code>
/// SymmetricKey kp(Key, Nonce);
/// ChaCha20 cipher();
/// // set to false to run in sequential mode
/// cipher.IsParallel() = true;
/// // calculated automatically based on cache size, but overridable
/// cipher.ParallelBlockSize() = cipher.ProcessorCount() * 32000;
/// cipher.Initialize(kp);
/// cipher.Transform(Input, Output);
/// </code>
/// </example>
/// 
/// <remarks>
/// <description><B>Overview:</B></description>
/// <para>The ChaCha stream cipher generates a key-stream by encrypting successive values of an incrementing 32bit unsigned integer counter array.<br>
/// The key-stream is then XOR'd with the input message block to create the cipher-text output.<br>
/// In parallel mode, the counter is increased by a number factored from the number of input blocks, allowing for a multi-threaded operation.<br>
/// The implementation is further parallelized by constructing a larger 'staggered' counter array, and processing large blocks using 128 or 256 SIMD instructions.</para>
/// 
/// <description><B>Description:</B></description>
/// <para><EM>Legend:</EM><br> 
/// <B>C</B>=ciphertext, <B>P</B>=plaintext, <B>K</B>=key, <B>E</B>=encrypt, <B>^</B>=XOR<br>
/// <EM>Encryption</EM><br>
/// C0 ← IV. For 1 ≤ j ≤ t, Cj ← EK(Cj) ^ Pj, C+1.</para><br>
///
/// <description><B>Multi-Threading:</B></description>
/// <para>The transformation function used by ChaCha is not limited by a dependency chain; this mode can be both SIMD pipelined and multi-threaded.<br>
/// This is acheived by pre-calculating the counters positional offset over multiple 'chunks' of key-stream, which are then generated independently across threads.<br> 
/// The key stream generated by encrypting the counter array(s), is used as a source of random, and XOR'd with the message input to produce the cipher text.</para>
///
/// <description>Implementation Notes:</description>
/// <list type="bullet">
/// <item><description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description></item>
/// <item><description>Block size is 64 bytes wide.</description></item>
/// <item><description>Valid rounds are 8 through 30 in increments of 2.</description></item>
/// <item><description>Encryption can both be pipelined (SSE3-128 or AVX2-256), and multi-threaded.</description></item>
/// <item><description>The Transform functions are virtual, and can be accessed from an ICipherMode instance.</description></item>
/// <item><description>The transformation methods can not be called until the Initialize(SymmetricKey) function has been called.</description></item>
/// <item><description>Parallel processing is enabled by setting IsParallel() to true, and passing an input block of ParallelBlockSize() to the transform.</description></item>
/// <item><description>The ParallelThreadsMax() property is used as the thread count in the parallel loop; this must be an even number no greater than the number of processer cores on the system.</description></item>
/// <item><description>ParallelBlockSize() is calculated automatically based on processor(s) cache size but can be user defined, but must be evenly divisible by ParallelMinimumSize().</description></item>
/// <item><description>Parallel block calculation ex. <c>ParallelBlockSize() = data.size() - (data.size() % cipher.ParallelMinimumSize());</c></description></item>
/// </list>
/// 
/// <description>Guiding Publications:</description>
/// <list type="number">
/// <item><description>ChaCha20 <a href="http://cr.yp.to/chacha/chacha-20080128.pdf">Specification</a>.</description></item>
/// <item><description>Salsa20 <a href="http://cr.yp.to/snuffle/design.pdf">Design</a>.</description></item>
/// <item><description>Salsa20 <a href="http://cr.yp.to/snuffle/security.pdf">Security</a>.</description></item>
/// </list>
/// </remarks>
class ChaCha20 : public IStreamCipher
{
private:

	const size_t BLOCK_SIZE = 64;
	const size_t CTR_SIZE = 8;
	const size_t DEF_ROUNDS = 20;
	const size_t MAX_ROUNDS = 30;
	const size_t MAX_PRLALLOC = 100000000;
	const size_t MIN_ROUNDS = 8;
	const size_t PARALLEL_CHUNK = 1024;
	const size_t PRC_DATACACHE = 32000;
	const char *SIGMA = "expand 32-byte k";
	const size_t STATE_SIZE = 16;
	const char *TAU = "expand 16-byte k";

	std::vector<uint> m_ctrVector;
	std::vector<byte> m_dstCode;
	bool m_hasAVX2;
	bool m_hasSSE;
	bool m_isInitialized;
	bool m_isParallel;
	bool m_isDestroyed;
	std::vector<SymmetricKeySize> m_legalKeySizes;
	std::vector<size_t> m_legalRounds;
	size_t m_parallelBlockSize;
	size_t m_parallelMaxDegree;
	size_t m_parallelMinimumSize;
	size_t m_processorCount;
	size_t m_rndCount;
	std::vector<uint> m_wrkState;

public:

	ChaCha20(const ChaCha20&) = delete;
	ChaCha20& operator=(const ChaCha20&) = delete;
	ChaCha20& operator=(ChaCha20&&) = delete;

	//~~~Properties~~~//

	/// <summary>
	/// Get: Unit block size of internal cipher in bytes.
	/// <para>Block size is 64 bytes wide.</para>
	/// </summary>
	virtual const size_t BlockSize() { return BLOCK_SIZE; }

	/// <summary>
	/// Get/Set: The salt value in the initialization parameters (Tau-Sigma).
	/// <para>This value can also be set with the Info parameter of an ISymmetricKey member, or use the default.
	/// Changing this code will create a unique distribution of the cipher.
	/// Code must be non-zero, 16 bytes in length, and sufficiently asymmetric.
	/// If the Info parameter of an ISymmetricKey is non-zero, it will overwrite the distribution code.</para>
	/// </summary>
	virtual std::vector<byte> &DistributionCode() { return m_dstCode; }

	/// <summary>
	/// Get: The stream ciphers type name
	/// </summary>
	virtual const StreamCiphers Enumeral() { return StreamCiphers::ChaCha20; }

	/// <summary>
	/// Get: Returns True if the cipher supports AVX intrinsics
	/// </summary>
	virtual const bool HasAVX2() { return m_hasAVX2; }

	/// <summary>
	/// Get: Returns True if the cipher supports SIMD intrinsics
	/// </summary>
	virtual const bool HasSSE() { return m_hasSSE; }

	/// <summary>
	/// Get: Cipher is ready to transform data
	/// </summary>
	virtual const bool IsInitialized() { return m_isInitialized; }

	/// <summary>
	/// Get: Initialization vector size
	/// </summary>
	virtual const size_t IvSize() { return CTR_SIZE; }

	/// <summary>
	/// Get: Available Encryption Key Sizes in bytes
	/// </summary>
	virtual std::vector<SymmetricKeySize> LegalKeySizes() const { return m_legalKeySizes; }

	/// <summary>
	/// Get: Available transformation round assignments
	/// </summary>
	virtual const std::vector<size_t> LegalRounds() { return m_legalRounds; }

	/// <summary>
	/// Get/Set: Automatic processor parallelization
	/// </summary>
	virtual bool &IsParallel() { return m_isParallel; }

	/// <summary>
	/// Get/Set: Parallel block size; must align (threads * n) with ParallelMinimumSize().
	/// <para>Changes to this value must be made before the <see cref="Initialize(SymmetricKey)"/> function is called.</para>
	/// </summary>
	virtual size_t &ParallelBlockSize() { return m_parallelBlockSize; }

	/// <summary>
	/// Get: Maximum input size with parallel processing
	/// </summary>
	virtual const size_t ParallelMaximumSize() { return MAX_PRLALLOC; }

	/// <summary>
	/// Get: The smallest parallel block size. 
	/// <para>Parallel blocks must be a multiple of this size.</para>
	/// </summary>
	virtual const size_t ParallelMinimumSize() { return m_parallelMinimumSize; }

	/// <summary>
	/// Get/Set: The maximum number of threads allocated when using multi-threaded processing.
	/// <para>Changes to this value must be made before the <see cref="Initialize(SymmetricKey)"/> function is called.</para>
	/// </summary>
	virtual size_t &ParallelThreadsMax() { return m_parallelMaxDegree; }

	/// <remarks>
	/// Get: Processor count
	/// </remarks>
	virtual const size_t ProcessorCount() { return m_processorCount; }

	/// <summary>
	/// Get: The stream ciphers class name
	/// </summary>
	virtual const std::string Name() { return "ChaCha20"; }

	/// <summary>
	/// Get: Number of rounds
	/// </summary>
	virtual const size_t Rounds() { return m_rndCount; }

	//~~~Constructor~~~//

	/// <summary>
	/// Initialize the class
	/// </summary>
	///
	/// <param name="Rounds">Number of transformation rounds. The <see cref="LegalRounds"/> property contains available sizes. Default is 20 rounds.</param>
	///
	/// <exception cref="Exception::CryptoSymmetricCipherException">Thrown if an invalid rounds count is chosen</exception>
	explicit ChaCha20(size_t Rounds = 20)
		:
		m_ctrVector(2, 0),
		m_hasAVX2(false),
		m_hasSSE(false),
		m_isDestroyed(false),
		m_isInitialized(false),
		m_isParallel(false),
		m_legalKeySizes(0),
		m_parallelBlockSize(0),
		m_parallelMaxDegree(0),
		m_parallelMinimumSize(0),
		m_rndCount(Rounds),
		m_wrkState(14, 0)
	{
		if (Rounds == 0 || (Rounds & 1) != 0)
			throw CryptoSymmetricCipherException("Salsa20:Ctor", "Rounds must be a positive even number!");
		if (Rounds < MIN_ROUNDS || Rounds > MAX_ROUNDS)
			throw CryptoSymmetricCipherException("Salsa20:Ctor", "Rounds must be between 8 and 30!");

		Scope();
	}

	/// <summary>
	/// Finalize objects
	/// </summary>
	virtual ~ChaCha20()
	{
		Destroy();
	}

	//~~~Public Methods~~~//

	/// <summary>
	/// Destroy of this class
	/// </summary>
	virtual void Destroy();

	/// <summary>
	/// Initialize the cipher
	/// </summary>
	/// 
	/// <param name="KeyParam">Cipher key container. 
	/// <para>Uses the Key and Nonce fields of KeyParam. The <see cref="LegalKeySizes"/> property contains valid Key sizes. 
	/// The Nonce must be 8 bytes in size.</para>
	/// </param>
	virtual void Initialize(ISymmetricKey &KeyParam);

	/// <summary>
	/// Set the maximum number of threads allocated when using multi-threaded processing.
	/// <para>When set to zero, thread count is set automatically. If set to 1, sets IsParallel() to false and runs in sequential mode. 
	/// Thread count must be an even number, and not exceed the number of processor cores.</para>
	/// </summary>
	///
	/// <param name="Degree">The desired number of threads</param>
	///
	/// <exception cref="Exception::CryptoCipherModeException">Thrown if an invalid degree setting is used</exception>
	virtual void ParallelMaxDegree(size_t Degree);

	/// <summary>
	/// Reset the primary internal counter
	/// </summary>
	virtual void Reset();

	/// <summary>
	/// Encrypt/Decrypt an array of bytes.
	/// <para><see cref="Initialize(SymmetricKey)"/> must be called before this method can be used.</para>
	/// </summary>
	/// 
	/// <param name="Input">The input array of bytes to transform</param>
	/// <param name="Output">The output array of transformed bytes</param>
	virtual void Transform(const std::vector<byte> &Input, std::vector<byte> &Output);

	/// <summary>
	/// Encrypt/Decrypt an array of bytes with offset parameters.
	/// <para><see cref="Initialize(SymmetricKey)"/> must be called before this method can be used.</para>
	/// </summary>
	/// 
	/// <param name="Input">The input array of bytes to transform</param>
	/// <param name="InOffset">Starting offset within the input array</param>
	/// <param name="Output">The output array of transformed bytes</param>
	/// <param name="OutOffset">Starting offset within the output array</param>
	virtual void Transform(const std::vector<byte> &Input, const size_t InOffset, std::vector<byte> &Output, const size_t OutOffset);

	/// <summary>
	/// Encrypt/Decrypt an array of bytes with offset and length parameters.
	/// <para><see cref="Initialize(SymmetricKey)"/> must be called before this method can be used.</para>
	/// </summary>
	/// 
	/// <param name="Input">The input array of bytes to transform</param>
	/// <param name="InOffset">Starting offset within the input array</param>
	/// <param name="Output">The output array of transformed bytes</param>
	/// <param name="OutOffset">Starting offset within the output array</param>
	/// <param name="Length">Number of bytes to process</param>
	virtual void Transform(const std::vector<byte> &Input, const size_t InOffset, std::vector<byte> &Output, const size_t OutOffset, const size_t Length);

private:
	void Detect();
	void Expand(const std::vector<byte> &Key, const std::vector<byte> &Iv);
	void Generate(std::vector<byte> &Output, const size_t OutOffset, std::vector<uint> &Counter, const size_t Length);
	void Increase(const std::vector<uint> &Input, std::vector<uint> &Output, const size_t Length);
	void Increment(std::vector<uint> &Counter);
	void Process(const std::vector<byte> &Input, const size_t InOffset, std::vector<byte> &Output, const size_t OutOffset, const size_t Length);
	void Scope();
};

NAMESPACE_STREAMEND
#endif

