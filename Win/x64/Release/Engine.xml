<?xml version="1.0"?>
<doc>
    <assembly>
        "Engine"
    </assembly>
    <members>
        <member name="M:CEX.Mac.CMAC.Update(System.Byte)">
            <summary>
Update the digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Mac.CMAC.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Mac.CMAC.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher MAC generator.
<para>Uses a Key and optional IV field to initialize the cipher.</para></summary>
            <param name="MacKey">A byte array containing the cipher Key. 
<para>Key size must be one of the <c>LegalKeySizes</c> of the underlying cipher.</para></param>
            <param name="IV">A byte array containing the CBC mode Initialization Vector.
<para>IV size must be the ciphers blocksize.</para></param>
            <exception cref="T:CEX.Exception.CryptoMacException">Thrown if an invalid Key size is chosen</exception>
        </member>
        <member name="M:CEX.Mac.CMAC.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Process the last block of data
</summary>
            <param name="Output">The hash value return</param>
            <param name="OutOffset">The offset in the data</param>
            <returns>The number of bytes processed</returns>
            <exception cref="T:CEX.Exception.CryptoMacException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:CEX.Mac.CMAC.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Mac.CMAC.ComputeMac(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Mac hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The output message code</param>
        </member>
        <member name="M:CEX.Mac.CMAC.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:CEX.Mac.CMAC.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Mac.CMAC.#ctor(CEX.Cipher.Symmetric.Block.IBlockCipher*,System.UInt32)">
            <summary>
Initialize the class
</summary>
            <param name="Cipher">Instance of the block cipher</param>
            <param name="MacBits">Expected MAC return size in Bits; must be less or equal to Cipher Block size in bits</param>
            <exception cref="T:CEX.Exception.CryptoMacException">Thrown if an invalid Mac or block size is used</exception>
        </member>
        <member name="M:CEX.Mac.CMAC.Name">
            <summary>
Get: Algorithm name
</summary>
        </member>
        <member name="M:CEX.Mac.CMAC.IsInitialized">
            <summary>
Get: Mac is ready to digest data
</summary>
        </member>
        <member name="M:CEX.Mac.CMAC.MacSize">
            <summary>
Get: Size of returned mac in bytes
</summary>
        </member>
        <member name="M:CEX.Mac.CMAC.Enumeral">
            <summary>
Get: The macs type name
</summary>
        </member>
        <member name="M:CEX.Mac.CMAC.BlockSize">
            <summary>
Get: The Macs internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Mac.CMAC">
            <summary>
An implementation of a Cipher based Message Authentication Code
</summary>
            <example>
                <description>Example generating a MAC code from an Input array</description>
                <code>
CEX::Cipher::Symmetric::Block::RDX* eng;
CEX::Mac::CMAC cmac1(eng);
hmac1.Initialize(key, [IV]);
hmac1.ComputeMac(Input, Output);
delete cpr;
</code>
            </example>
            <seealso cref="N:CEX.Cipher.Symmetric.Block" />
            <seealso cref="T:CEX.Cipher.Symmetric.Block.Mode.ICipherMode" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>MAC return size must be a divisible of 8.</description>
                    </item>
                    <item>
                        <description>MAC return size can be no longer than the Cipher Block size.</description>
                    </item>
                    <item>
                        <description>Valid Cipher block sizes are 8 and 16 byte wide.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">Rijndael ammended</a>.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdf">SP800-38B</a>: The CMAC Mode for Authentication.</description>
                    </item>
                    <item>
                        <description>RFC <a href="http://tools.ietf.org/html/rfc4493">4493</a>: The AES-CMAC Algorithm.</description>
                    </item>
                    <item>
                        <description>RFC <a href="http://tools.ietf.org/html/rfc4494">4494</a>: The AES-CMAC-96 Algorithm and Its Use with IPsec.</description>
                    </item>
                    <item>
                        <description>RFC <a href="http://tools.ietf.org/html/rfc4615">4493</a>: The AES-CMAC-PRF-128 Algorithm for the Internet Key Exchange Protocol (IKE).</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ZeroPad.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ZeroPad.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ZeroPad.AddPadding(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Add padding to input array
</summary>
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
            <exception cref="T:CEX.Exception.CryptoPaddingException">Thrown if the padding offset value is longer than the array length</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ZeroPad.Name">
            <summary>
Get: Padding name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ZeroPad.Enumeral">
            <summary>
Get: The padding modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ZeroPad.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ZeroPad.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Padding.ZeroPad">
            <summary>
The Zero Padding Scheme (Not Recommended).
</summary>
        </member>
        <member name="M:CEX.Helper.PrngFromName.GetInstance(&lt;unknown type&gt;)">
            <summary>
Get a Prng instance with default initialization parameters
</summary>
            <param name="PrngType">The prng enumeration name</param>
            <returns>An initialized prng</returns>
            <exception cref="T:CEX.Exception.CryptoException">Thrown if the enumeration name is not supported</exception>
        </member>
        <member name="T:CEX.Helper.PrngFromName">
            <summary>
PrngFromName: Get a Prng instance from it's enumeration name.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Transform a block of bytes with offset parameters. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Transform a block of bytes. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Encryption">True if cipher is used for encryption, false to decrypt</param>
            <param name="KeyParam">KeyParam containing key and vector</param>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt a block of bytes with offset parameters. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt a block of bytes. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Decrypt a block of bytes with offset parameters.
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Decrypt a single block of bytes.
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.#ctor(CEX.Cipher.Symmetric.Block.IBlockCipher*)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Cipher">Underlying encryption algorithm</param>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a null Cipher or valid block size is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Cipher.Symmetric.Block.Mode.ECB.ParallelMinimumSize" />.
<para>The parallel block size is calculated automatically based on the number of available processors on the system (n * 64kb).</para></summary>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, 
or block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.IV">
            <summary>
Get: The current state of the initialization Vector
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.IsParallel">
            <summary>
Get/Set: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.IsEncryption">
            <summary>
Get: Initialized for encryption, false for decryption
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.Enumeral">
            <summary>
Get: The cipher modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.Engine">
            <summary>
Get: Underlying Cipher
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ECB.BlockSize">
            <summary>
Get: Unit block size of internal cipher
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Mode.ECB">
            <summary>
Implements an Electronic Cookbook Mode: ECB (Insecure Mode; For Testing Only!)
</summary>
            <example>
                <description>Example using an <c>ICipherMode</c> interface:</description>
                <code>
ECB cipher(new RDX());
// initialize for encryption
cipher.Initialize(true, KeyParams(Key));
// encrypt a block
cipher.Transform(Input, Output);
</code>
            </example>
            <seealso cref="N:CEX.Cipher.Symmetric.Block" />
            <seealso cref="T:CEX.Cipher.Symmetric.Block.Mode.ICipherMode" />
            <seealso cref="T:CEX.Enumeration.BlockCiphers" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>ECB is not a secure mode, and should only be used for testing.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Prng.SP20Prng.Reset">
            <summary>
Reset the generator instance
</summary>
            <summary>
Reset the generator instance
</summary>
        </member>
        <member name="M:CEX.Prng.SP20Prng.NextLong(System.UInt64,System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random 64bit integer</returns>
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.SP20Prng.NextLong(System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random 64bit integer</returns>
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.SP20Prng.NextLong">
            <summary>
Get a pseudo random unsigned 64bit integer
</summary>
            <returns>Random 64bit integer</returns>
            <summary>
Get a pseudo random unsigned 64bit integer
</summary>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.SP20Prng.Next(System.UInt32,System.UInt32)">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random 32bit integer</returns>
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.SP20Prng.Next(System.UInt32)">
            <summary>
Get an pseudo random unsigned 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random 32bit integer</returns>
            <summary>
Get an pseudo random unsigned 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.SP20Prng.Next">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <returns>Random 32bit integer</returns>
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.SP20Prng.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
        </member>
        <member name="M:CEX.Prng.SP20Prng.GetBytes(System.UInt32)">
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
        </member>
        <member name="M:CEX.Prng.SP20Prng.Destroy">
            <summary>
Release all resources associated with the object
</summary>
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Prng.SP20Prng.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Prng.SP20Prng.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;,System.UInt32,System.UInt32)">
            <summary>
Initialize the class with a Seed; note: the same seed will produce the same random output
</summary>
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is key size + iv of 16 bytes)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="Rounds">The number of diffusion rounds to use when generating the key stream</param>
            <exception cref="T:CEX.Exception.CryptoRandomException">Thrown if the buffer or key size invalid, or rounds count is out of range</exception>
        </member>
        <member name="M:CEX.Prng.SP20Prng.#ctor(&lt;unknown type&gt;,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
Initialize the class
</summary>
            <param name="SeedEngine">The Seed engine used to create keyng material (default is CSPRsg)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="KeySize">The size of the seed to generate in bytes; can be 32 for a 128 bit key or 48 for a 256 bit key</param>
            <param name="Rounds">The number of diffusion rounds to use when generating the key stream</param>
            <exception cref="T:CEX.Exception.CryptoRandomException">Thrown if the buffer or key size invalid, or rounds count is out of range (rounds 10-30, min. buffer 64 bytes)</exception>
        </member>
        <member name="M:CEX.Prng.SP20Prng.Name">
            <summary>
Get: Algorithm name
</summary>
        </member>
        <member name="M:CEX.Prng.SP20Prng.Enumeral">
            <summary>
Get: The prngs type name
</summary>
        </member>
        <member name="T:CEX.Prng.SP20Prng">
            <summary>
SP20Prng: An implementation of a Encryption Counter based Deterministic Random Number Generator
</summary>
            <example>
                <description>Example of generating a pseudo random integer:</description>
                <code>
SP20Prng rnd([SeedGenerators], [Buffer Size], [Key Size], [Rounds Count]);
// get random int
int num = rnd.Next([Minimum], [Maximum]);
</code>
            </example>
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description>
                    </item>
                    <item>
                        <description>Block size is 64 bytes wide.</description>
                    </item>
                    <item>
                        <description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description>
                    </item>
                    <item>
                        <description>Parallel block size is 64,000 bytes by default; but is configurable.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>Salsa20 <a href="http://www.ecrypt.eu.org/stream/salsa20pf.html">eSTREAM Phase 3</a>.</description>
                    </item>
                    <item>
                        <description>Salsa20 <a href="http://cr.yp.to/snuffle/design.pdf">Design</a>.</description>
                    </item>
                    <item>
                        <description>Salsa20 <a href="http://cr.yp.to/snuffle/security.pdf">Security</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.Update(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Update the Salt material
</summary>
            <param name="Salt">Pseudo random seed material</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt value is too small</exception>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value; must be either 24 or 40 bytes</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt is too small</exception>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Generate pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">The starting position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            <returns>Number of bytes generated</returns>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Generate a block of pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.#ctor(System.UInt32)">
            <summary>
Initialize the SP20 generator
</summary>
            <param name="Rounds">The number of transformation rounds</param>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.VectorSize">
            <summary>
Get: Initialization vector size
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Generator.SP20Drbg.ParallelMinimumSize" />.
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.LegalRounds">
            <summary>
Get: Available diffusion round assignments
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.KeySize">
            <summary>
                <para>Minimum initialization key size in bytes; 
combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.IV">
            <summary>
Get: The current state of the initialization Vector
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.IsParallel">
            <summary>
Get/Set: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.IsInitialized">
            <summary>
Get: Generator is ready to produce data
</summary>
        </member>
        <member name="M:CEX.Generator.SP20Drbg.Enumeral">
            <summary>
Get: The generators type name
</summary>
        </member>
        <member name="T:CEX.Generator.SP20Drbg">
            <summary>
SP20Drbg: A parallelized Salsa20 deterministic random byte generator implementation
</summary>
            <example>
                <description>Generate an array of pseudo random bytes:</description>
                <code>
SP20Drbg rnd(20);
// initialize
rnd.Initialize(Salt, [Ikm], [Nonce]);
// generate bytes
rnd.Generate(Output, [Offset], [Size]);
</code>
            </example>
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description>
                    </item>
                    <item>
                        <description>Block size is 64 bytes wide.</description>
                    </item>
                    <item>
                        <description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description>
                    </item>
                    <item>
                        <description>Parallel block size is 64,000 bytes by default; but is configurable.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>Salsa20 <a href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</a>.</description>
                    </item>
                    <item>
                        <description>Salsa20 <a href="http://cr.yp.to/snuffle/design.pdf">Design</a>.</description>
                    </item>
                    <item>
                        <description>Salsa20 <a href="http://cr.yp.to/snuffle/security.pdf">Security</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Processing.MacStream.ComputeMac(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Process a length within the Input stream using an Offset
</summary>
            <returns>The Mac Code</returns>
            <param name="Input">The Input array to process</param>
            <param name="InOffset">The Input array starting offset</param>
            <param name="Length">The number of bytes to process</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if ComputeHash is called before Initialize(), or if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:CEX.Processing.MacStream.ComputeMac(CEX.IO.IByteStream*)">
            <summary>
Process the entire length of the Input Stream
</summary>
            <returns>The Mac Code</returns>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if ComputeHash is called before Initialize(), or if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:CEX.Processing.MacStream.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Processing.MacStream.#ctor(CEX.Mac.IMac*)">
            <summary>
Initialize the class with an initialized Mac instance
</summary>
            <param name="Mac">The initialized <see cref="T:CEX.Mac.IMac" /> instance</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if a null or uninitialized Mac is used</exception>
        </member>
        <member name="F:CEX.Processing.MacStream.ProgressPercent">
            <summary>
The Progress Percent event
</summary>
        </member>
        <member name="T:CEX.Processing.MacStream">
            <summary>
MAC stream helper class.
<para>Wraps Message Authentication Code (MAC) stream functions in an easy to use interface.</para></summary>
            <example>
                <description>Example of hashing a Stream:</description>
                <code>
SHA256* eng = new SHA256();
HMAC* mac = new HMAC(eng);
hmac-&gt;Initialize(Key, Iv);
MacStream ds(mac);
IByteStream* ms = new MemoryStream(Input);
Code = ds.ComputeMac(ms);
delete eng;
delete mac;
delete ms;
</code>
            </example>
            <seealso cref="T:CEX.Enumeration.Macs" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Uses any of the implemented Macs using the IMac interface.</description>
                    </item>
                    <item>
                        <description>Mac must be fully initialized before passed to the constructor.</description>
                    </item>
                    <item>
                        <description>Implementation has a Progress counter that returns total sum of bytes processed per either ComputeMac() calls.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Helper.SeedFromName.GetInstance(&lt;unknown type&gt;)">
            <summary>
Get a Seed Generator instance with default initialization parameters
</summary>
            <param name="SeedType">The seed generator enumeration name</param>
            <returns>An initialized seed generator</returns>
            <exception cref="T:CEX.Exception.CryptoException">Thrown if the enumeration name is not supported</exception>
        </member>
        <member name="T:CEX.Helper.SeedFromName">
            <summary>
SeedFromName: Get a seed generator instance from it's enumeration name
</summary>
        </member>
        <member name="M:CEX.Helper.StreamCipherFromName.GetInstance(&lt;unknown type&gt;,System.Int32)">
            <summary>
Get a stream cipher instance with specified initialization parameters
</summary>
            <param name="EngineType">The stream cipher enumeration name</param>
            <param name="RoundCount">The number of cipher rounds</param>
            <returns>An initialized stream cipher</returns>
            <exception cref="T:CEX.Exception.CryptoException">Thrown if the enumeration name is not supported</exception>
        </member>
        <member name="T:CEX.Helper.StreamCipherFromName">
            <summary>
StreamCipherFromName: Get a Stream Cipher instance from it's enumeration name.
</summary>
        </member>
        <member name="M:CEX.Processing.CipherStream.Write(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Process using byte arrays.
<para>The Input array is processed and returned by the Output array.</para></summary>
            <param name="Input">The Input array</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Output">The Output array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if Write is called before Initialize(), or if array sizes are misaligned</exception>
        </member>
        <member name="M:CEX.Processing.CipherStream.Write(CEX.IO.IByteStream*,CEX.IO.IByteStream*)">
            <summary>
Process using streams.
<para>The input stream is processed and returned in the output stream.</para></summary>
            <param name="InStream">The Input Stream</param>
            <param name="OutStream">The Output Stream</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if Write is called before Initialize(), or the Input stream is empty</exception>
        </member>
        <member name="M:CEX.Processing.CipherStream.Initialize(System.Boolean,CEX.Common.KeyParams*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the cipher processing engine
</summary>
            <param name="Encryption">The cipher is used for encryption</param>
            <param name="KeyParam">The KeyParams containing the cipher key and initialization vector</param>
        </member>
        <member name="M:CEX.Processing.CipherStream.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Processing.CipherStream.Dispose">
            <summary>
Destroy this class
</summary>
        </member>
        <member name="M:CEX.Processing.CipherStream.#ctor(CEX.Cipher.Symmetric.Stream.IStreamCipher*)">
            <summary>
Initialize the class with a Stream Cipher instance.
<para>This constructor requires an uninitialized CipherStream instance.</para></summary>
            <param name="Cipher">The uninitialized Stream Cipher instance</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if a null or uninitialized Stream Cipher is used</exception>
        </member>
        <member name="M:CEX.Processing.CipherStream.#ctor(CEX.Cipher.Symmetric.Block.Mode.ICipherMode*,CEX.Cipher.Symmetric.Block.Padding.IPadding*)">
            <summary>
Initialize the class with a Block Cipherand optional Padding instances.
<para>This constructor requires an uninitialized CipherMode instance.
If the PaddingMode parameter is null, X9.23 padding will be used if required.</para></summary>
            <param name="Cipher">The Block Cipher wrapped in a Cipher mode</param>
            <param name="Padding">The Block Cipher Padding instance</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if a null or uninitialized Cipher is used</exception>
        </member>
        <member name="M:CEX.Processing.CipherStream.#ctor(CEX.Common.CipherDescription*)">
            <summary>
Initialize the class with a CipherDescription Structure; containing the cipher implementation details.
<para>This constructor creates and configures cryptographic instances based on the cipher description contained in a CipherDescription. 
Cipher modes, padding, and engines are destroyed automatically through this classes Destruct() method.</para></summary>
            <param name="Header">A CipherDescription containing the cipher description</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if an invalid CipherDescription is used</exception>
        </member>
        <member name="M:CEX.Processing.CipherStream.#ctor(&lt;unknown type&gt;,System.Int32,&lt;unknown type&gt;,&lt;unknown type&gt;,System.Int32,&lt;unknown type&gt;)">
            <summary>
Initialize the class with a CipherDescription Structure; containing the cipher implementation details, and a KeyParams class containing the Key material.
<para>This constructor creates and configures cryptographic instances based on the cipher description contained in a CipherDescription. 
Cipher modes, padding, and engines are destroyed automatically through this classes Destroy() method.</para></summary>
            <param name="EngineType">The encryption engine type</param>
            <param name="RoundCount">The number of transformation rounds</param>
            <param name="CipherType">The cipher mode</param>
            <param name="PaddingType">The padding type</param>
            <param name="BlockSize">The cipher blocksize</param>
            <param name="KdfEngine">The HX ciphers key schedule engine</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if an invalid CipherDescription or KeyParams is used</exception>
        </member>
        <member name="M:CEX.Processing.CipherStream.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Processing.CipherStream.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Processing.CipherStream.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Processing.CipherStream.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Processing.CipherStream.ParallelMinimumSize" />.
</summary>
        </member>
        <member name="M:CEX.Processing.CipherStream.ParallelBlockProfile">
            <summary>
Get/Set: Determines how the size of a parallel block is calculated; using the <see cref="T:CEX.Processing.CipherStream.BlockProfiles">Block Profiles</see></summary>
        </member>
        <member name="M:CEX.Processing.CipherStream.IsParallel">
            <summary>
Get/Set: Automatic processor parallelization
</summary>
        </member>
        <member name="F:CEX.Processing.CipherStream.ProgressPercent">
            <summary>
The Progress Percent event
</summary>
        </member>
        <member name="F:UserDefined">
            <summary>
The block size is specified by the user
</summary>
        </member>
        <member name="F:SpeedProfile">
            <summary>
Set parallel block size for maximum possible speed
</summary>
        </member>
        <member name="F:ProgressProfile">
            <summary>
Set parallel block size as a division of 100 segments
</summary>
        </member>
        <member name="T:CEX.Processing.CipherStream.BlockProfiles">
            <summary>
ParallelBlockProfile enumeration
</summary>
        </member>
        <member name="T:CEX.Processing.CipherStream">
            <summary>
CipherStream: used to wrap a streams cryptographic transformation.
<para>Wraps encryption stream functions in an easy to use interface.</para></summary>
            <seealso cref="T:CEX.Common.CipherDescription" />
            <seealso cref="N:CEX.Cipher.Symmetric.Stream" />
            <seealso cref="T:CEX.Cipher.Symmetric.Block.Mode.ICipherMode" />
            <seealso cref="N:CEX.Cipher.Symmetric.Block" />
            <seealso cref="T:CEX.Enumeration.SymmetricEngines" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Uses any of the implemented Cipher Mode wrapped Block Ciphers, or any of the implemented Stream Ciphers.</description>
                    </item>
                    <item>
                        <description>Implementation has a Progress counter that returns total sum of bytes processed per any of the Write() calls.</description>
                    </item>
                    <item>
                        <description>Changes to the Cipher or CipherStream ParallelBlockSize must be set after initialization.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Digest.Keccak256.Update(System.Byte)">
            <summary>
Update the digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Digest.Keccak256.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak256.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Do final processing and get the hash value
</summary>
            <param name="Output">The Hash output value array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <returns>Size of Hash value</returns>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the output buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Keccak256.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak256.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The hash output value array</param>
        </member>
        <member name="M:CEX.Digest.Keccak256.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the input buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Keccak256.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak256.#ctor(System.Int32)">
            <summary>
Initialize the digest
</summary>
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:CEX.Digest.Keccak256.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak256.Enumeral">
            <summary>
Get: The digests type enumeration member
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak256.DigestSize">
            <summary>
Get: Size of returned digest in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak256.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Digest.Keccak256">
            <summary>
Keccak256: An implementation of the SHA-3 Keccak digest
</summary>
            <example>
                <description>Example using the ComputeHash method:</description>
                <code>
Keccak256 digest;
std:vector&lt;byte&gt; hash(digest.DigestSize(), 0);
// compute a hash
digest.ComputeHash(Input, hash);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Hash sizes are 28, 32, and 36 bytes (224, 256, and 288 bits).</description>
                    </item>
                    <item>
                        <description>Block sizes are 144, 128, and 136 bytes (1152, 1024, 1088 bits).</description>
                    </item>
                    <item>
                        <description>Use the <see cref="M:CEX.Digest.Keccak256.BlockSize" /> property to determine block sizes at runtime.</description>
                    </item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Keccak256.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> method wraps the <see cref="M:CEX.Digest.Keccak256.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)" /> and DoFinal methods.</description>/&gt;</item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Keccak256.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)" /> method resets the internal state.</description>
                    </item>
                </list>
                <list type="number">
                    <item>
                        <description>SHA3 <a href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="http://csrc.nist.gov/groups/ST/hash/sha-3/documents/Keccak-slides-at-NIST.pdf">Keccak Slides</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report</a> of the SHA-3 Cryptographic Hash Algorithm Competition.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Digest.Blake256.Update(System.Byte)">
            <summary>
Update the message digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Digest.Blake256.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Digest.Blake256.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Do final processing and get the hash value
</summary>
            <param name="Output">The Hash output value array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <returns>Size of Hash value</returns>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the output buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Blake256.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Digest.Blake256.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The hash output value array</param>
        </member>
        <member name="M:CEX.Digest.Blake256.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the input buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Blake256.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Digest.Blake256.#ctor(std.vector&lt;System.UInt32,std.allocator&lt;System.UInt32&gt;&gt;)">
            <summary>
Initialize the class with a salt value
</summary>
            <param name="Salt">The optional salt value; must be 4 unsigned ints in length</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the salt length is invalid</exception>
        </member>
        <member name="M:CEX.Digest.Blake256.#ctor">
            <summary>
Initialize the digest
</summary>
        </member>
        <member name="M:CEX.Digest.Blake256.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Digest.Blake256.Enumeral">
            <summary>
Get: The digests type enumeration member
</summary>
        </member>
        <member name="M:CEX.Digest.Blake256.DigestSize">
            <summary>
Get: Size of returned digest in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.Blake256.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Digest.Blake256">
            <summary>
Blake256: An implementation of the Blake digest with a 256 bit return size
</summary>
            <example>
                <description>Example using the ComputeHash method:</description>
                <code>
Blake256 digest;
std:vector&lt;byte&gt; hash(digest.DigestSize(), 0);
// compute a hash
digest.ComputeHash(Input, hash);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Block size is 32 bytes, (256 bits).</description>
                    </item>
                    <item>
                        <description>Digest size is 32 bytes, (256 bits).</description>
                    </item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Blake256.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> method wraps the <see cref="M:CEX.Digest.Blake256.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)" /> and DoFinal methods.</description>/&gt;</item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Blake256.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)" /> method resets the internal state.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="https://131002.net/blake">SHA3 Proposal Blake</a>.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">SHA3: Third-Round Report</a> of the SHA-3 Cryptographic Hash Algorithm Competition.</description>
                    </item>
                    <item>
                        <description>SHA3 Submission in C: <a href="https://131002.net/blake/blake_ref.c">blake_ref.c</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Prng.SecureRandom.Reset">
            <summary>
Reset the generator instance
</summary>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextUInt64(System.UInt64,System.UInt64)">
            <summary>
Get a random ulong integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextUInt64(System.UInt64)">
            <summary>
Get a random ulong integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextUInt64">
            <summary>
Get a random ulong integer
</summary>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextInt64(System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get a random long integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random Int64</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextInt64(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get a random long integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random Int64</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextInt64">
            <summary>
Get a random long integer
</summary>
            <returns>Random Int64</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextLong">
            <summary>
Get a random long integer
</summary>
            <returns>Random Int64</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextUInt32(System.UInt32,System.UInt32)">
            <summary>
Get a random unsigned integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextUInt32(System.UInt32)">
            <summary>
Get a random unsigned integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextUInt32">
            <summary>
Get a random unsigned 32bit integer
</summary>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextInt32(System.Int32,System.Int32)">
            <summary>
Get a random non-negative 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random Int32</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextInt32(System.Int32)">
            <summary>
Get a random non-negative 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random Int32</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextInt32">
            <summary>
Get a random non-negative 32bit integer
</summary>
            <returns>Random Int32</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.Next">
            <summary>
Get a random non-negative 32bit integer
</summary>
            <returns>Random Int32</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextUInt16(System.UInt16,System.UInt16)">
            <summary>
Get a random unsigned short integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt16</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextUInt16(System.UInt16)">
            <summary>
Get a random unsigned short integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt16</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextUInt16">
            <summary>
Get a random unsigned short integer
</summary>
            <returns>Random UInt16</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextInt16(System.Int16,System.Int16)">
            <summary>
Get a random non-negative short integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random Int16</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextInt16(System.Int16)">
            <summary>
Get a random non-negative short integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random Int16</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextInt16">
            <summary>
Get a random non-negative short integer
</summary>
            <returns>Random Int16</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextDouble">
            <summary>
Get a random double
</summary>
            <returns>Random double</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextUChar">
            <summary>
Get a random unsigned char
</summary>
            <returns>Random unsigned char</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.NextChar">
            <summary>
Get a random char
</summary>
            <returns>Random char</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
        </member>
        <member name="M:CEX.Prng.SecureRandom.GetBytes(System.UInt32)">
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
        </member>
        <member name="M:CEX.Prng.SecureRandom.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Prng.SecureRandom.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Prng.SecureRandom.#ctor(System.UInt32)">
            <summary>
Initialize this class
</summary>
            <param name="BufferSize">Size of the internal buffer; must be at least 64 bytes</param>
            <exception cref="T:CEX.Exception.CryptoRandomException">Thrown if buffer size is too small</exception>
        </member>
        <member name="T:CEX.Prng.SecureRandom">
            <summary>
An implementation of a Cryptographically Secure Pseudo Random Number Generator: SecureRandom. 

<para>Uses the default crypto random provider to generate random numbers.</para></summary>
            <example>
                <c>
SecureRandom rnd;
int x = rnd.NextInt32();
</c>
            </example>
        </member>
        <member name="M:CEX.IO.BitConverter.ToUInt64(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert bytes to an unsigned 64 bit integer value
</summary>
            <param name="Input">The Input byte array</param>
            <param name="InOffset">The starting position within the Input array</param>
            <returns>An unsigned 64 bit integer value</returns>
        </member>
        <member name="M:CEX.IO.BitConverter.ToInt64(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert bytes to a 64 bit integer value
</summary>
            <param name="Input">The Input byte array</param>
            <param name="InOffset">The starting position within the Input array</param>
            <returns>A 64 bit integer value</returns>
        </member>
        <member name="M:CEX.IO.BitConverter.ToUInt32(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert bytes to an unsigned 32 bit integer value
</summary>
            <param name="Input">The Input byte array</param>
            <param name="InOffset">The starting position within the Input array</param>
            <returns>An unsigned 32 bit integer value</returns>
        </member>
        <member name="M:CEX.IO.BitConverter.ToInt32(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert bytes to a 32 bit integer value
</summary>
            <param name="Input">The Input byte array</param>
            <param name="InOffset">The starting position within the Input array</param>
            <returns>A 32 bit integer value</returns>
        </member>
        <member name="M:CEX.IO.BitConverter.ToUInt16(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert bytes to an unsigned 16 bit integer value
</summary>
            <param name="Input">The Input byte array</param>
            <param name="InOffset">The starting position within the Input array</param>
            <returns>An unsigned 16 bit integer value</returns>
        </member>
        <member name="M:CEX.IO.BitConverter.ToInt16(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert bytes to a 16 bit integer value
</summary>
            <param name="Input">The Input byte array</param>
            <param name="InOffset">The starting position within the Input array</param>
            <returns>A 16 bit integer value</returns>
        </member>
        <member name="M:CEX.IO.BitConverter.ToFloat(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert bytes to a float value
</summary>
            <param name="Input">The Input byte array</param>
            <param name="InOffset">The starting position within the Input array</param>
            <returns>A float value</returns>
        </member>
        <member name="M:CEX.IO.BitConverter.ToDouble(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert bytes to a double value
</summary>
            <param name="Input">The Input byte array</param>
            <param name="InOffset">The starting position within the Input array</param>
            <returns>A double value</returns>
        </member>
        <member name="M:CEX.IO.BitConverter.ToUChar(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert bytes to an unsigned char value
</summary>
            <param name="Input">The Input byte array</param>
            <param name="InOffset">The starting position within the Input array</param>
            <returns>An unsigned char value</returns>
        </member>
        <member name="M:CEX.IO.BitConverter.ToChar(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert bytes to a char value
</summary>
            <param name="Input">The Input byte array</param>
            <param name="InOffset">The starting position within the Input array</param>
            <returns>A char value</returns>
        </member>
        <member name="T:CEX.IO.BitConverter">
            <summary>
Converts bytes to integers
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.Update(System.Byte)">
            <summary>
Update the message digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Digest.Skein512.SetVersion(System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the version string. Version must be between 0 and 3, inclusive.
</summary>
            <param name="Version">Version string</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if an invalid version is used</exception>
        </member>
        <member name="M:CEX.Digest.Skein512.SetTreeLeafSize(System.Byte!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the tree leaf size
</summary>
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:CEX.Digest.Skein512.SetTreeFanOutSize(System.Byte!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the tree fan out size
</summary>
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:CEX.Digest.Skein512.SetSchema(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the Schema. Schema must be 4 bytes.
</summary>
            <param name="Schema">Schema Configuration string</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if an invalid schema is used</exception>
        </member>
        <member name="M:CEX.Digest.Skein512.SetMaxTreeHeight(System.Byte!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the tree height. Tree height must be zero or greater than 1.
</summary>
            <param name="Height">Tree height</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if an invalid tree height is used</exception>
        </member>
        <member name="M:CEX.Digest.Skein512.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.Initialize(&lt;unknown type&gt;)">
            <summary>
Used to re-initialize the digest state.
<para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
This does not start a new UBI block type, and must be done manually.</para></summary>
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:CEX.Digest.Skein512.GenerateConfiguration(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;)">
            <summary>
Generate a configuration using a state key
</summary>
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:CEX.Digest.Skein512.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Do final processing and get the hash value
</summary>
            <param name="Output">The Hash output value array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <returns>Size of Hash value</returns>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the output buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Skein512.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The hash output value array</param>
        </member>
        <member name="M:CEX.Digest.Skein512.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the input buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Skein512.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.#ctor(&lt;unknown type&gt;)">
            <summary>
Initialize the digest
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.GetUbiParameters">
            <summary>
Ubi Tweak parameters
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.GetStateSize">
            <summary>
Get the state size in bits
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.GetInitializationType">
            <summary>
Get the initialization type
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.GetConfigValue">
            <summary>
Get the post-chain configuration value
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.GetConfigString">
            <summary>
Get the pre-chain configuration string
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.Enumeral">
            <summary>
Get: The digests type enumeration member
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.DigestSize">
            <summary>
Get: Size of returned digest in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.Skein512.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Digest.Skein512">
            <summary>
Skein512: An implementation of the Skein digest with a 512 bit digest return size.
<para>SHA-3 finalist: The Skein digest</para></summary>
            <example>
                <description>Example using the ComputeHash method:</description>
                <code>
Skein512 digest;
std:vector&lt;byte&gt; hash(digest.DigestSize(), 0);
// compute a hash
digest.ComputeHash(Input, hash);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Block size is 64 bytes, (512 bits).</description>
                    </item>
                    <item>
                        <description>Digest size is 64 bytes, (512 bits).</description>
                    </item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Skein512.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> method wraps the <see cref="M:CEX.Digest.Skein512.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)" /> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Skein512.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)" /> method does NOT reset the internal state; call <see cref="M:CEX.Digest.Skein512.Reset" /> to reinitialize.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>Skein <a href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">The Skein digest</a>.</description>
                    </item>
                    <item>
                        <description>The Skein Hash Function Family <a href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</a>.</description>
                    </item>
                    <item>
                        <description>Skein <a href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</a> Support for the Skein Hash Family.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">SHA3 Third-Round Report</a> of the SHA-3 Cryptographic Hash Algorithm Competition&gt;.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Digest.SHA256.Update(System.Byte)">
            <summary>
Update the message digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Digest.SHA256.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Digest.SHA256.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Do final processing and get the hash value
</summary>
            <param name="Output">The Hash output value array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <returns>Size of Hash value</returns>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the output buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.SHA256.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Digest.SHA256.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The hash output value array</param>
        </member>
        <member name="M:CEX.Digest.SHA256.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the input buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.SHA256.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Digest.SHA256.#ctor">
            <summary>
Initialize the digest
</summary>
        </member>
        <member name="M:CEX.Digest.SHA256.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Digest.SHA256.Enumeral">
            <summary>
Get: The digests type enumeration member
</summary>
        </member>
        <member name="M:CEX.Digest.SHA256.DigestSize">
            <summary>
Get: Size of returned digest in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.SHA256.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Digest.SHA256">
            <summary>
SHA256: An implementation of the SHA-2 digest with a 256 bit digest return size
</summary>
            <example>
                <description>Example using the ComputeHash method:</description>
                <code>
SHA256 digest;
std:vector&lt;byte&gt; hash(digest.DigestSize(), 0);
// compute a hash
digest.ComputeHash(Input, hash);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Block size is 64 bytes, (512 bits).</description>
                    </item>
                    <item>
                        <description>Digest size is 32 bytes, (256 bits).</description>
                    </item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.SHA256.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> method wraps the <see cref="M:CEX.Digest.SHA256.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)" /> and DoFinal methods.</description>/&gt;</item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.SHA256.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)" /> method resets the internal state.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">SHA-2 Specification</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Seed.ISCRsg.Reset">
            <summary>
Reinitialize the internal state using existing state as a seed
</summary>
        </member>
        <member name="M:CEX.Seed.ISCRsg.Next">
            <summary>
Returns the next pseudo random 32bit integer
</summary>
        </member>
        <member name="M:CEX.Seed.ISCRsg.Initialize(System.Boolean)">
            <summary>
initializes the generator with new state
</summary>
            <param name="MixState">Mix with the initial state values</param>
        </member>
        <member name="M:CEX.Seed.ISCRsg.GetBytes(System.Int32)">
            <summary>
Get a pseudo random seed byte array
</summary>
            <param name="Size">The size of the expected seed returned</param>
            <returns>A pseudo random seed</returns>
        </member>
        <member name="M:CEX.Seed.ISCRsg.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill the buffer with random bytes
</summary>
            <param name="Output">The array to fill</param>
        </member>
        <member name="M:CEX.Seed.ISCRsg.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Seed.ISCRsg.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Seed.ISCRsg.#ctor(std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize this class using a seed value
</summary>
            <param name="Seed">The initial state values; must be between 2 and 256, 32bit values</param>
            <exception cref="T:CEX.Exception.CryptoRandomException">Thrown if an invalid seed size is used</exception>
        </member>
        <member name="M:CEX.Seed.ISCRsg.#ctor">
            <summary>
Initialize this class using a seed generated by the default random provider
</summary>
        </member>
        <member name="M:CEX.Seed.ISCRsg.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Seed.ISCRsg.Enumeral">
            <summary>
Get: The seed generators type name
</summary>
        </member>
        <member name="T:CEX.Seed.ISCRsg">
            <summary>
ISCRsg: Generates seed material using an ISAAC random number generator.
<para>A high speed, cryptographically secure pseudo random provider.</para></summary>
            <example>
                <description>Example of getting a seed value:</description>
                <code>
ISCRsg gen(Seed);
gen.GetSeed(Output);
</code>
            </example>
            <remarks>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>ISAAC a fast cryptographic <a href="http://www.burtleburtle.net/bob/rand/isaacafa.html">Random Number Generator</a>.</description>
                    </item>
                    <item>
                        <description>Rossettacode <a href="http://rosettacode.org/wiki/The_ISAAC_Cipher">Example implementations</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Digest.Skein1024.Update(System.Byte)">
            <summary>
Update the message digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Digest.Skein1024.SetVersion(System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the version string. Version must be between 0 and 3, inclusive.
</summary>
            <param name="Version">Version string</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if an invalid version is used</exception>
        </member>
        <member name="M:CEX.Digest.Skein1024.SetTreeLeafSize(System.Byte!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the tree leaf size
</summary>
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:CEX.Digest.Skein1024.SetTreeFanOutSize(System.Byte!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the tree fan out size
</summary>
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:CEX.Digest.Skein1024.SetSchema(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the Schema. Schema must be 4 bytes.
</summary>
            <param name="Schema">Schema Configuration string</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if an invalid schema is used</exception>
        </member>
        <member name="M:CEX.Digest.Skein1024.SetMaxTreeHeight(System.Byte!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the tree height. Tree height must be zero or greater than 1.
</summary>
            <param name="Height">Tree height</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if an invalid tree height is used</exception>
        </member>
        <member name="M:CEX.Digest.Skein1024.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.Initialize(&lt;unknown type&gt;)">
            <summary>
Used to re-initialize the digest state.
<para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
This does not start a new UBI block type, and must be done manually.</para></summary>
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:CEX.Digest.Skein1024.GenerateConfiguration(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;)">
            <summary>
Generate a configuration using a state key
</summary>
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:CEX.Digest.Skein1024.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Do final processing and get the hash value
</summary>
            <param name="Output">The Hash output value array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <returns>Size of Hash value</returns>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the output buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Skein1024.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The hash output value array</param>
        </member>
        <member name="M:CEX.Digest.Skein1024.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the input buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Skein1024.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.#ctor(&lt;unknown type&gt;)">
            <summary>
Initialize the digest
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.GetUbiParameters">
            <summary>
Ubi Tweak parameters
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.GetStateSize">
            <summary>
Get the state size in bits
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.GetInitializationType">
            <summary>
Get the initialization type
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.GetConfigString">
            <summary>
Get the pre-chain configuration string
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.GetConfigValue">
            <summary>
Get the post-chain configuration value
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.Enumeral">
            <summary>
Get: The digests type enumeration member
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.DigestSize">
            <summary>
Get: Size of returned digest in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.Skein1024.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Digest.Skein1024">
            <summary>
Skein1024: An implementation of the Skein digest with a 1024 bit digest return size.
<para>SHA-3 finalist: The Skein digest</para></summary>
            <example>
                <description>Example using the ComputeHash method:</description>
                <code>
Skein1024 digest;
std:vector&lt;byte&gt; hash(digest.DigestSize(), 0);
// compute a hash
digest.ComputeHash(Input, hash);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Block size is 128 bytes, (1024 bits).</description>
                    </item>
                    <item>
                        <description>Digest size is 128 bytes, (1024 bits).</description>
                    </item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Skein1024.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> method wraps the <see cref="M:CEX.Digest.Skein1024.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)" /> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Skein1024.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)" /> method does NOT reset the internal state; call <see cref="M:CEX.Digest.Skein1024.Reset" /> to reinitialize.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>Skein <a href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">The Skein digest</a>.</description>
                    </item>
                    <item>
                        <description>The Skein Hash Function Family <a href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</a>.</description>
                    </item>
                    <item>
                        <description>Skein <a href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</a> Support for the Skein Hash Family.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">SHA3 Third-Round Report</a> of the SHA-3 Cryptographic Hash Algorithm Competition&gt;.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:Keccak.TransformBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Process a block of bytes
</summary>
            <param name="Input">The input array</param>
            <param name="Offset">The offset index</param>
            <param name="State">The state array</param>
            <param name="Size">The size of the transform</param>
        </member>
        <member name="T:Keccak">
            <summary>
Keccak methods and constants
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak512.Update(System.Byte)">
            <summary>
Update the digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Digest.Keccak512.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak512.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Do final processing and get the hash value
</summary>
            <param name="Output">The Hash output value array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <returns>Size of Hash value</returns>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the output buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Keccak512.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak512.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The hash output value array</param>
        </member>
        <member name="M:CEX.Digest.Keccak512.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the input buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Keccak512.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak512.#ctor(System.Int32)">
            <summary>
Initialize the digest
</summary>
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:CEX.Digest.Keccak512.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak512.Enumeral">
            <summary>
Get: The digests type enumeration member
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak512.DigestSize">
            <summary>
Get: Size of returned digest in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.Keccak512.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Digest.Keccak512">
            <summary>
Keccak512: An implementation of the SHA-3 Keccak digest
</summary>
            <example>
                <description>Example using an <c>IDigest</c> interface:</description>
                <code>
Keccak512 digest;
std:vector&lt;byte&gt; hash(digest.DigestSize(), 0);
// compute a hash
digest.ComputeHash(Input, hash);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Hash sizes are 48 and 64 bytes (384 and 512 bits).</description>
                    </item>
                    <item>
                        <description>Block sizes are 104, and 72 bytes (832, 576 bits).</description>
                    </item>
                    <item>
                        <description>Use the <see cref="M:CEX.Digest.Keccak512.BlockSize" /> property to determine block sizes at runtime.</description>
                    </item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Keccak512.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> method wraps the <see cref="M:CEX.Digest.Keccak512.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)" /> and DoFinal methods.</description>/&gt;</item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Keccak512.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)" /> method resets the internal state.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>SHA3 <a href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="http://csrc.nist.gov/groups/ST/hash/sha-3/documents/Keccak-slides-at-NIST.pdf">Keccak Slides</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report</a> of the SHA-3 Cryptographic Hash Algorithm Competition.</description>
                    </item>
                </list>&gt;
</remarks>
        </member>
        <member name="M:CEX.Prng.DGCPrng.Reset">
            <summary>
Reset the generator instance
</summary>
            <summary>
Reset the generator instance
</summary>
        </member>
        <member name="M:CEX.Prng.DGCPrng.NextLong(System.UInt64,System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random 64bit integer</returns>
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.DGCPrng.NextLong(System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random 64bit integer</returns>
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.DGCPrng.NextLong">
            <summary>
Get a pseudo random unsigned 64bit integer
</summary>
            <returns>Random 64bit integer</returns>
            <summary>
Get a pseudo random unsigned 64bit integer
</summary>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.DGCPrng.Next(System.UInt32,System.UInt32)">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random 32bit integer</returns>
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.DGCPrng.Next(System.UInt32)">
            <summary>
Get an pseudo random unsigned 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random 32bit integer</returns>
            <summary>
Get an pseudo random unsigned 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.DGCPrng.Next">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <returns>Random 32bit integer</returns>
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.DGCPrng.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
        </member>
        <member name="M:CEX.Prng.DGCPrng.GetBytes(System.UInt32)">
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
        </member>
        <member name="M:CEX.Prng.DGCPrng.Destroy">
            <summary>
Release all resources associated with the object
</summary>
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Prng.DGCPrng.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Prng.DGCPrng.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;,&lt;unknown type&gt;,System.UInt32)">
            <summary>
Initialize the class with a Seed; note: the same seed will produce the same random output
</summary>
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is digest blocksize + 8)</param>
            <param name="DigestEngine">The digest that powers the rng (default is Keccak512)</param>
            <param name="BufferSize">The size of the internal state buffer in bytes; must be at least 128 bytes size (default is 1024)</param>
            <exception cref="T:CEX.Exception.CryptoRandomException">Thrown if the seed is null or buffer size is too small; (min. seed = digest blocksize + 8)</exception>
        </member>
        <member name="M:CEX.Prng.DGCPrng.#ctor(&lt;unknown type&gt;,&lt;unknown type&gt;,System.UInt32)">
            <summary>
Initialize the class
</summary>
            <param name="DigestEngine">The digest that powers the rng (default is Keccak512)</param>
            <param name="SeedEngine">The Seed engine used to create the salt (default is CSPRsg)</param>
            <param name="BufferSize">The size of the internal state buffer in bytes; must be at least 128 bytes size (default is 1024)</param>
            <exception cref="T:CEX.Exception.CryptoRandomException">Thrown if the buffer size is too small (min. 64)</exception>
        </member>
        <member name="M:CEX.Prng.DGCPrng.Name">
            <summary>
Get: Algorithm name
</summary>
        </member>
        <member name="M:CEX.Prng.DGCPrng.Enumeral">
            <summary>
Get: The prngs type name
</summary>
        </member>
        <member name="T:CEX.Prng.DGCPrng">
            <summary>
DGCPrng: An implementation of a Digest Counter based Random Number Generator
</summary>
            <example>
                <description>Example of generating a pseudo random integer:</description>
                <code>
DGCPrng rnd([Digests], [SeedGenerators], [Buffer Size]);
int num = rnd.Next([Minimum], [Maximum]);
</code>
            </example>
            <seealso cref="N:CEX.Digest" />
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Can be initialized with any digest.</description>
                    </item>
                    <item>
                        <description>Can use either a random seed generator for initialization, or a user supplied Seed array.</description>
                    </item>
                    <item>
                        <description>Numbers generated with the same seed will produce the same random output.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf">SP800-90A</a>: Appendix E1.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>: Recommendation for the Entropy Sources Used for Random Bit Generation.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Fips 140-2</a>: Security Requirments For Cryptographic Modules.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">SP800-22 1a</a>: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://eprint.iacr.org/2006/379.pdf">Security Bounds</a> for the NIST Codebook-based: Deterministic Random Bit Generator.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Digest.SHA512.Update(System.Byte)">
            <summary>
Update the message digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Digest.SHA512.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Digest.SHA512.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Do final processing and get the hash value
</summary>
            <param name="Output">The Hash output value array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <returns>Size of Hash value</returns>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the output buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.SHA512.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Digest.SHA512.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The hash output value array</param>
        </member>
        <member name="M:CEX.Digest.SHA512.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the input buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.SHA512.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Digest.SHA512.#ctor">
            <summary>
Initialize the digest
</summary>
        </member>
        <member name="M:CEX.Digest.SHA512.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Digest.SHA512.Enumeral">
            <summary>
Get: The digests type enumeration member
</summary>
        </member>
        <member name="M:CEX.Digest.SHA512.DigestSize">
            <summary>
Get: Size of returned digest in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.SHA512.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Digest.SHA512">
            <summary>
SHA512: An implementation of the SHA-2 digest with a 512 bit digest return size
</summary>
            <example>
                <description>Example using the ComputeHash method:</description>
                <code>
SHA512 digest;
std:vector&lt;byte&gt; hash(digest.DigestSize(), 0);
// compute a hash
digest.ComputeHash(Input, hash);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Block size is 128 bytes, (1024 bits).</description>
                    </item>
                    <item>
                        <description>Digest size is 64 bytes, (512 bits).</description>
                    </item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.SHA512.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> method wraps the <see cref="M:CEX.Digest.SHA512.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)" /> and DoFinal methods.</description>/&gt;</item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.SHA512.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)" /> method resets the internal state.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">SHA-2 Specification</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt a block of bytes with offset parameters.
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt a block of bytes.
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Decrypt a block of bytes with offset parameters.
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Decrypt a single block of bytes.
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Transform a block of bytes with offset parameters. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Transform a block of bytes. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Encryption">True if cipher is used for encryption, false to decrypt</param>
            <param name="KeyParam">KeyParams containing key and std::vector</param>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.#ctor(CEX.Cipher.Symmetric.Block.IBlockCipher*,System.UInt32)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="BlockSizeBits">Block size in bits; minimum is 8, or 1 byte. Maximum is Cipher block size in bits</param>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a null Cipher or valid block size is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Cipher.Symmetric.Block.Mode.CFB.ParallelMinimumSize" />.
<para>The parallel block size is calculated automatically based on the number of available processors on the system (n * 64kb).</para></summary>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, 
or block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.IV">
            <summary>
Get: The current state of the initialization Vector
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.IsParallel">
            <summary>
Get/Set: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.IsEncryption">
            <summary>
Get: Initialized for encryption, false for decryption
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.Enumeral">
            <summary>
Get: The cipher modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.Engine">
            <summary>
Get: Underlying Cipher
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CFB.BlockSize">
            <summary>
Get: Unit block size of internal cipher
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Mode.CFB">
            <summary>
Implements a Cipher FeedBack Mode: CFB
</summary>
            <example>
                <description>Example using an <c>ICipherMode</c> interface:</description>
                <code>
CFB cipher(new RDX());
// initialize for encryption
cipher.Initialize(true, KeyParams(Key, IV));
// encrypt a block
cipher.Transform(Input, Output);
</code>
            </example>
            <seealso cref="N:CEX.Cipher.Symmetric.Block" />
            <seealso cref="T:CEX.Cipher.Symmetric.Block.Mode.ICipherMode" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>In CFB mode, only decryption can be processed in parallel.</description>
                    </item>
                    <item>
                        <description>Parallel processing is enabled on decryption by passing a block size of ParallelBlockSize to the transform.</description>
                    </item>
                    <item>
                        <description>ParallelBlockSize must be divisible by ParallelMinimumSize.</description>
                    </item>
                    <item>
                        <description>Parallel block calculation ex. <c>int blocklen = (data.size() / cipher.ParallelMinimumSize()) * 100</c></description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Transform one block of bytes with offset parameters.  
<para>Parallel capable function if Output array length is at least equal to <see cref="M:CEX.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize" />. 
Method will process a single block from the array of either ParallelBlockSize or Blocksize depending on IsParallel property setting.
Partial blocks are permitted with both parallel and linear operation modes.
Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Transformed bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Process an array of bytes. 
<para>Parallel capable function if Output array length is at least equal to <see cref="M:CEX.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize" />. 
This method processes the entire array; used when processing small data or buffers from a larger source.
Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Encryption">True if cipher is used for encryption, false to decrypt</param>
            <param name="KeyParam">The KeyParams containing key and std::vector</param>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.#ctor(CEX.Cipher.Symmetric.Block.IBlockCipher*)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Cipher">Underlying encryption algorithm</param>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize" />.
<para>The parallel block size is calculated automatically based on the number of available processors on the system (n * 64kb).</para></summary>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, 
or block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.IV">
            <summary>
Get: The current state of the initialization Vector
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.IsParallel">
            <summary>
Get/Set: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.IsEncryption">
            <summary>
Get: Initialized for encryption, false for decryption
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.Enumeral">
            <summary>
Get: The cipher modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.Engine">
            <summary>
Get: Underlying Cipher
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CTR.BlockSize">
            <summary>
Get: Unit block size of internal cipher
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Mode.CTR">
            <summary>
Implements a Parallel Segmented Counter Mode: CTR
</summary>
            <example>
                <description>Example using an <c>ICipherMode</c> interface:</description>
                <code>
CTR cipher(new RDX());
// initialize for encryption
cipher.Initialize(true, KeyParams(Key, IV));
// encrypt a block
cipher.Transform(Input, Output);
</code>
            </example>
            <seealso cref="N:CEX.Cipher.Symmetric.Block" />
            <seealso cref="T:CEX.Cipher.Symmetric.Block.Mode.ICipherMode" />
            <seealso cref="T:CEX.Enumeration.BlockCiphers" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>In CTR mode, both encryption and decryption can be processed in parallel.</description>
                    </item>
                    <item>
                        <description>Parallel processing is enabled by passing a block size of <see cref="M:CEX.Cipher.Symmetric.Block.Mode.CTR.ParallelBlockSize" /> to the transform.</description>
                    </item>
                    <item>
                        <description>ParallelBlockSize must be divisible by <see cref="M:CEX.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize" />.</description>
                    </item>
                    <item>
                        <description>Parallel block calculation ex. <c>int blocklen = (data.size() / cipher.ParallelMinimumSize()) * 100</c></description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Helper.CipherModeFromName.GetInstance(&lt;unknown type&gt;,CEX.Cipher.Symmetric.Block.IBlockCipher*)">
            <summary>
Get an Cipher Mode instance by name using default parameters
</summary>
            <param name="CipherType">The cipher mode enumeration name</param>
            <param name="Engine">The block cipher instance</param>
            <returns>An initialized digest</returns>
            <exception cref="T:CEX.Exception.CryptoException">Thrown if the enumeration name is not supported</exception>
        </member>
        <member name="T:CEX.Helper.CipherModeFromName">
            <summary>
CipherModeFromName: Get a Cipher Mode instance from it's enumeration name.
</summary>
        </member>
        <member name="M:CEX.Prng.PPBPrng.Reset">
            <summary>
Reset the generator instance
</summary>
            <summary>
Reset the generator instance
</summary>
        </member>
        <member name="M:CEX.Prng.PPBPrng.NextLong(System.UInt64,System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random 64bit integer</returns>
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.PPBPrng.NextLong(System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random 64bit integer</returns>
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.PPBPrng.NextLong">
            <summary>
Get a pseudo random unsigned 64bit integer
</summary>
            <returns>Random 64bit integer</returns>
            <summary>
Get a pseudo random unsigned 64bit integer
</summary>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.PPBPrng.Next(System.UInt32,System.UInt32)">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random 32bit integer</returns>
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.PPBPrng.Next(System.UInt32)">
            <summary>
Get an pseudo random unsigned 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random 32bit integer</returns>
            <summary>
Get an pseudo random unsigned 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.PPBPrng.Next">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <returns>Random 32bit integer</returns>
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.PPBPrng.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
        </member>
        <member name="M:CEX.Prng.PPBPrng.GetBytes(System.UInt32)">
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
        </member>
        <member name="M:CEX.Prng.PPBPrng.Destroy">
            <summary>
Release all resources associated with the object
</summary>
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Prng.PPBPrng.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Prng.PPBPrng.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,&lt;unknown type&gt;,System.UInt32)">
            <summary>
Initialize the class with a Seed; note: the same seed will produce the same random output
</summary>
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is digest blocksize + 8)</param>
            <param name="Iterations">The number of transformation iterations performed by the digest with PBKDF2 (default is 10,000)</param>
            <param name="DigestEngine">The digest that powers the rng (default is Keccak512)</param>
            <param name="BufferSize">The size of the internal state buffer in bytes; must be at least 128 bytes size (default is 1024)</param>
            <exception cref="T:CEX.Exception.CryptoRandomException">Thrown if the seed or buffer size is too small; (min. seed = 2* digest hash size, min. buffer 64 bytes)</exception>
        </member>
        <member name="M:CEX.Prng.PPBPrng.Name">
            <summary>
Get: Algorithm name
</summary>
        </member>
        <member name="M:CEX.Prng.PPBPrng.Enumeral">
            <summary>
Get: The prngs type name
</summary>
        </member>
        <member name="T:CEX.Prng.PPBPrng">
            <summary>
PBPRng: An implementation of a passphrase based PKCS#5 random number generator
</summary>
            <example>
                <description>Example of generating a pseudo random integer:</description>
                <code>
PBPRng rnd(new SHA512(), PassPhrase, Salt);
int x = rnd.Next();
</code>
            </example>
            <seealso cref="T:CEX.Mac.HMAC" />
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>RFC <a href="http://tools.ietf.org/html/rfc2898">2898</a>: Password-Based Cryptography Specification Version 2.0.</description>
                    </item>
                    <item>
                        <description>RFC <a href="http://tools.ietf.org/html/rfc2898">2898</a>: Specification.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">SP800-22 1a</a>, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>: Recommendation for the Entropy Sources Used for Random Bit Generation.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Fips 140-2</a>: Security Requirments For Cryptographic Modules.</description>
                    </item>
                    <item>
                        <description>RFC <a href="http://www.ietf.org/rfc/rfc4086.txt">4086</a>: Randomness Requirements for Security.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Generator.PBKDF2.Update(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Update the Salt material
</summary>
            <param name="Salt">Pseudo random seed material</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt value is too small</exception>
        </member>
        <member name="M:CEX.Generator.PBKDF2.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
        </member>
        <member name="M:CEX.Generator.PBKDF2.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
        </member>
        <member name="M:CEX.Generator.PBKDF2.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value; minimum size is 2* the digests output size</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt is too small</exception>
        </member>
        <member name="M:CEX.Generator.PBKDF2.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Generate pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">The starting position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            <returns>Number of bytes generated</returns>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:CEX.Generator.PBKDF2.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Generate a block of pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:CEX.Generator.PBKDF2.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Generator.PBKDF2.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Generator.PBKDF2.#ctor(CEX.Mac.HMAC*,System.UInt32)">
            <summary>
Creates a PBKDF2 Bytes Generator based on the given hash function
</summary>
            <param name="Hmac">The Hmac instance</param>
            <param name="Iterations">The number of cycles used to produce output</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if a null Digest or invalid Iterations count is used</exception>
        </member>
        <member name="M:CEX.Generator.PBKDF2.#ctor(CEX.Digest.IDigest*,System.UInt32)">
            <summary>
Creates a PBKDF2 Bytes Generator based on the given hash function
</summary>
            <param name="Digest">The digest instance</param>
            <param name="Iterations">The number of cycles used to produce output</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if a null Digest or Iterations count is used</exception>
        </member>
        <member name="M:CEX.Generator.PBKDF2.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Generator.PBKDF2.KeySize">
            <summary>
                <para>Minimum initialization key size in bytes; 
combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="M:CEX.Generator.PBKDF2.IV">
            <summary>
Get: The current state of the initialization Vector
</summary>
        </member>
        <member name="M:CEX.Generator.PBKDF2.IsInitialized">
            <summary>
Get: Generator is ready to produce data
</summary>
        </member>
        <member name="M:CEX.Generator.PBKDF2.Enumeral">
            <summary>
Get: The generators type name
</summary>
        </member>
        <member name="M:CEX.Prng.CTRPrng.Reset">
            <summary>
Reset the generator instance
</summary>
            <summary>
Reset the generator instance
</summary>
        </member>
        <member name="M:CEX.Prng.CTRPrng.NextLong(System.UInt64,System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random 64bit integer</returns>
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.CTRPrng.NextLong(System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random 64bit integer</returns>
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.CTRPrng.NextLong">
            <summary>
Get a pseudo random unsigned 64bit integer
</summary>
            <returns>Random 64bit integer</returns>
            <summary>
Get a pseudo random unsigned 64bit integer
</summary>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.CTRPrng.Next(System.UInt32,System.UInt32)">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random 32bit integer</returns>
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.CTRPrng.Next(System.UInt32)">
            <summary>
Get an pseudo random unsigned 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random 32bit integer</returns>
            <summary>
Get an pseudo random unsigned 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.CTRPrng.Next">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <returns>Random 32bit integer</returns>
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.CTRPrng.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
        </member>
        <member name="M:CEX.Prng.CTRPrng.GetBytes(System.UInt32)">
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
        </member>
        <member name="M:CEX.Prng.CTRPrng.Destroy">
            <summary>
Release all resources associated with the object
</summary>
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Prng.CTRPrng.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Prng.CTRPrng.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,&lt;unknown type&gt;,System.UInt32)">
            <summary>
Initialize the class with a Seed; note: the same seed will produce the same random output
</summary>
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is key size + counter 16)</param>
            <param name="BlockEngine">The block cipher that powers the rng (default is RDX)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <exception cref="T:CEX.Exception.CryptoRandomException">Thrown if the seed is null or too small</exception>
        </member>
        <member name="M:CEX.Prng.CTRPrng.#ctor(&lt;unknown type&gt;,&lt;unknown type&gt;,System.UInt32,System.UInt32)">
            <summary>
Initialize this class
</summary>
            <param name="BlockEngine">The block cipher that powers the rng (default is RDX)</param>
            <param name="SeedEngine">The Seed engine used to create keyng material (default is CSPRsg)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="KeySize">The key size (in bytes) of the symmetric cipher; a <c>0</c> value will auto size the key</param>
            <exception cref="T:CEX.Exception.CryptoRandomException">Thrown if the buffer size is too small (min. 64)</exception>
        </member>
        <member name="M:CEX.Prng.CTRPrng.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Prng.CTRPrng.Enumeral">
            <summary>
Get: The prngs type name
</summary>
        </member>
        <member name="M:CEX.Processing.DigestStream.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Process a length within the Input stream using an Offset
</summary>
            <returns>The Message Digest</returns>
            <param name="Input">The Input array to process</param>
            <param name="InOffset">The Input array starting offset</param>
            <param name="Length">The number of bytes to process</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if ComputeHash is called before Initialize(), or if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:CEX.Processing.DigestStream.ComputeHash(CEX.IO.IByteStream*)">
            <summary>
Process the entire length of the Input Stream
</summary>
            <returns>The Message Digest</returns>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if ComputeHash is called before Initialize(), or if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:CEX.Processing.DigestStream.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Processing.DigestStream.#ctor(&lt;unknown type&gt;)">
            <summary>
Initialize the class with a digest enumeration
</summary>
            <param name="Digest">The digest enumeration member</param>
        </member>
        <member name="M:CEX.Processing.DigestStream.#ctor(CEX.Digest.IDigest*)">
            <summary>
Initialize the class with a digest instance
<para>Digest must be fully initialized before calling this method.</para></summary>
            <param name="Digest">The initialized Digest instance</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if a null Digest is used</exception>
        </member>
        <member name="F:CEX.Processing.DigestStream.ProgressPercent">
            <summary>
The Progress Percent event
</summary>
        </member>
        <member name="T:CEX.Processing.DigestStream">
            <summary>
Digest stream helper class.
<para>Wraps Message Digest stream functions in an easy to use interface.</para></summary>
            <example>
                <description>Example of hashing a Stream:</description>
                <code>
SHA512* eng = new SHA512();
StreamDigest dstrm(eng);
// get the hash code
hash = dstrm.ComputeHash(Input);
delete eng;
</code>
            </example>
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Uses any of the implemented Digests using either the IDigest interface, or a Digests enumeration member.</description>
                    </item>
                    <item>
                        <description>Implementation has a Progress counter that returns total sum of bytes processed per either of the ComputeHash() calls.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Common.KeyGenerator.Reset">
            <summary>
Reset the seed Seed Generators and the Digest engine
</summary>
        </member>
        <member name="M:CEX.Common.KeyGenerator.GetBytes(System.UInt32)">
            <summary>
Return an array with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
        </member>
        <member name="M:CEX.Common.KeyGenerator.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:CEX.Common.KeyGenerator.GetKeyParams(System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32)">
            <summary>
Create a populated KeyParams class
</summary>
            <param name="KeySize">Size of Key to generate in bytes</param>
            <param name="IVSize">Size of IV to generate in bytes</param>
            <param name="IKMSize">Size of IKM to generate in bytes</param>
            <returns>A populated <see cref="T:CEX.Common.KeyParams" /> class</returns>
        </member>
        <member name="M:CEX.Common.KeyGenerator.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Common.KeyGenerator.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Common.KeyGenerator.#ctor(&lt;unknown type&gt;!System.Runtime.CompilerServices.IsConst,&lt;unknown type&gt;!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the class and generators
</summary>
            <param name="SeedType">The Seed generator that supplies the seed material to the hash function</param>
            <param name="DigestType">The Digest type used to post-process the pseudo random seed material</param>
            <param name="Counter">The user supplied counter variable in bytes; setting to a <c>0</c> value, produces a counter generated by the default random provider; 
valid values are <c>0</c>, or between <c>4-32</c> bytes</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the counter is not <c>0</c>, or a value between <c>4</c> and <c>32</c></exception>
        </member>
        <member name="M:CEX.Common.KeyGenerator.#ctor(&lt;unknown type&gt;,&lt;unknown type&gt;)">
            <summary>
Initialize this class.
<para>Initializes the class with default generators; SHA-2 512, and CSPPrng.
The digest counter mechanism is set to <c>O</c> (disabled) by default.</para></summary>
            <param name="SeedType">The Seed Generators that supplies the seed material to the hash function</param>
            <param name="DigestType">The Digest type used to post-process the pseudo random seed material</param>
        </member>
        <member name="T:CEX.Common.KeyGenerator">
            <summary>
A helper class for generating cryptographically strong keying material.
<para>Generates an array or a populated KeyParams class, using a definable Digest(Prng()) dual stage generator.
The first stage of the generator gets seed material from the Prng provider, the second hashes the seed and adds the result to the state array.
A counter array can be prepended to the seed array, sized between 4 and 32 bytes. 
The counter is incremented and prepended to the seed value before each hash call. 
If the Counter size parameter is <c>0</c> in the constructor, or the default constructor is used, 
the counter is provided by the default random provider.</para></summary>
            <example>
                <description>Create an array of pseudo random keying material:</description>
                <code>
KeyGenerator* gen = new KeyGenerator([Prng], [Digest], [Counter Size]))
// generate pseudo random bytes
std:vector&lt;byte&gt; prnd = gen.Generate(Size);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <seealso cref="N:CEX.Seed" />
            <seealso cref="T:CEX.Seed.ISeed" />
            <seealso cref="T:CEX.Enumeration.SeedGenerators" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>SHA-2 Generates key material using a two stage Hmac_k(Prng()) process.</description>
                    </item>
                    <item>
                        <description>Blake, Keccak, and Skein also use a two stage generation method; Hash(Prng()).</description>
                    </item>
                    <item>
                        <description>Seed provider can be any of the <see cref="T:CEX.Enumeration.SeedGenerators" /> generators.</description>
                    </item>
                    <item>
                        <description>Hash can be any of the <see cref="T:CEX.Enumeration.Digests" /> digests.</description>
                    </item>
                    <item>
                        <description>Default Prng is CSPPrng, default digest is SHA512.</description>
                    </item>
                    <item>
                        <description>Resources are disposed of automatically.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Processing.Factory.KeyFactory.Extract(CEX.Processing.Structure.CipherKey*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEX.Common.KeyParams*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Extract a KeyParams and CipherKey
</summary>
            <param name="KeyHeader">The CipherKey that receives the cipher description, key id, and extension key</param>
            <param name="KeyParam">The KeyParams container that receives the key material from the file</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if the key file could not be found or a Header parameter does not match the keystream length</exception>
        </member>
        <member name="M:CEX.Processing.Factory.KeyFactory.Create(CEX.Common.KeyParams*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,&lt;unknown type&gt;,System.Int32,&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;,System.Int32,&lt;unknown type&gt;)">
            <summary>
Create a single use Key file using a manual description of the cipher parameters.
</summary>
            <param name="KeyParam">An initialized and populated key material container</param>
            <param name="EngineType">The Cryptographic Engine type</param>
            <param name="KeySize">The cipher Key Size in bytes</param>
            <param name="IvSize">Size of the cipher Initialization Vector</param>
            <param name="CipherType">The type of Cipher Mode</param>
            <param name="PaddingType">The type of cipher Padding Mode</param>
            <param name="BlockSize">The cipher Block Size</param>
            <param name="Rounds">The number of diffusion Rounds</param>
            <param name="KdfEngine">The Digest engine used to power the key schedule Key Derivation Function in HX ciphers</param>
            <param name="MacSize">The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key</param>
            <param name="MacEngine">The HMAC Digest engine used to authenticate a message file encrypted with this key</param>
        </member>
        <member name="M:CEX.Processing.Factory.KeyFactory.Create(CEX.Common.CipherDescription*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEX.Common.KeyParams*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Create a single use key file using a KeyParams containing the key material, and a CipherDescription containing the cipher implementation details
</summary>
            <param name="Description">The Cipher Description containing the cipher details</param>
            <param name="KeyParam">An initialized and populated key material container</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if a KeyParams member is null, but specified in the Header or a Header parameter does not match a KeyParams value</exception>
        </member>
        <member name="M:CEX.Processing.Factory.KeyFactory.Create(CEX.Common.CipherDescription*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,&lt;unknown type&gt;,&lt;unknown type&gt;)">
            <summary>
Create a single use key file using automatic key material generation.
<para>The Key, and optional IV and IKM are generated automatically using the cipher description contained in the CipherDescription.
This overload creates keying material using the seed and digest engines specified with the KeyGenerator class</para></summary>
            <param name="Description">The Cipher Description containing the cipher implementation details</param>
            <param name="SeedEngine">The Random Generator used to create the stage I seed material during key generation.</param>
            <param name="HashEngine">The Digest Engine used in the stage II phase of key generation.</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if a KeyParams member is null, but specified in the Header</exception>
        </member>
        <member name="M:CEX.Processing.Factory.KeyFactory.Dispose">
            <summary>
Finalizer: ensure resources are destroyed
</summary>
        </member>
        <member name="M:CEX.Processing.Factory.KeyFactory.#ctor(CEX.IO.MemoryStream*)">
            <summary>
Initialize this class with a memory stream; key will be written to the stream
</summary>
            <param name="KeyStream">The fully qualified path to the key file to be read or created</param>
        </member>
        <member name="T:CEX.Processing.Factory.KeyFactory">
            <summary>
KeyFactory: Used to create or extract a CipherKey file.

<list type="bullet"><item><description>The Constructor requires a pointer to a MemoryStream for reading or writing; using Create() objects are written to the stream, with Extract() objects are read from the stream.</description></item><item><description>The Create(CipherDescription, KeyParams) method requires a populated CipherDescription and KeyParams class.</description></item><item><description>The Create(CipherDescription, SeedGenerators, Digests) method will auto-generate keying material.</description></item><item><description>The Extract() method retrieves a populated cipher key (CipherKey), and key material (KeyParams), from the key stream.</description></item></list></summary>
            <example>
                <description>Example using the Create() and Extract methods:</description>
                <code>
KeyGenerator kg;
KeyParams kp = *kg.GetKeyParams(192, 16, 64);
// out-bound funcs use pointer
MemoryStream* m = new MemoryStream;
CEX::Processing::KeyFactory kf(m);

CipherDescription ds(
	SymmetricEngines::RHX,
	192,
	IVSizes::V128,
	CipherModes::CTR,
	PaddingModes::PKCS7,
	BlockSizes::B128,
	RoundCounts::R22,
	Digests::Skein512,
	64,
	Digests::SHA512);

kf.Create(ds, kp);
KeyParams kp2;
m-&gt;Seek(0, CEX::IO::SeekOrigin::Begin);
CEX::Processing::CipherKey ck;
kf.Extract(ck, kp2);

if (!ds.Equals(ck.Description()))
	throw;
if (!kp.Equals(kp2))
	throw;

delete m;
</code>
            </example>
            <seealso cref="T:CEX.Processing.Structure.CipherKey" />
            <seealso cref="T:CEX.Common.CipherDescription" />
            <seealso cref="T:CEX.Enumeration.Prngs" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <seealso cref="T:CEX.Common.KeyParams" />
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.Equals(CEX.Processing.Structure.CipherKey*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Compare this object instance with another
</summary>
            <param name="Obj">Object to compare</param>
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.GetHashCode">
            <summary>
Get the hash code for this object
</summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.SetKeyId(CEX.IO.MemoryStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the Key Id
</summary>
            <param name="KeyStream">The stream containing a cipher key</param>
            <param name="KeyId">Array of 16 bytes containing the key id</param>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.SetExtensionKey(CEX.IO.MemoryStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the ExtensionKey
</summary>
            <param name="KeyStream">The stream containing a cipher key</param>
            <param name="ExtensionKey">Array of 16 bytes containing the ExtensionKey</param>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.SetCipherDescription(CEX.IO.MemoryStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEX.Common.CipherDescription*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the CipherDescription structure
</summary>
            <param name="KeyStream">The stream containing a key package</param>
            <param name="Description">The CipherDescription structure</param>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.GetKeyId(CEX.IO.MemoryStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the key id (16 bytes)
</summary>
            <param name="KeyStream">The stream containing a cipher key</param>
            <returns>The file extension key</returns>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.GetExtensionKey(CEX.IO.MemoryStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the extension key (16 bytes)
</summary>
            <param name="KeyStream">The stream containing the cipher key</param>
            <returns>The file extension key</returns>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.GetCipherDescription(CEX.IO.MemoryStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the cipher description header
</summary>
            <param name="KeyStream">The stream containing a key package</param>
            <returns>CipherDescription structure</returns>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.GetHeaderSize">
            <summary>
Get the header Size in bytes
</summary>
            <returns>Header size</returns>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.ToStream">
            <summary>
Convert the CipherKey structure to a MemoryStream
</summary>
            <returns>The MemoryStream containing the CipherKey</returns>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.ToBytes">
            <summary>
Convert the CipherKey structure as a byte array
</summary>
            <returns>The byte array containing the CipherKey</returns>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.Reset">
            <summary>
Reset all members of the CipherKey structure, including the CipherDescription
</summary>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the CipherKey structure using a byte array
</summary>
            <param name="KeyArray">The byte array containing the CipherKey</param>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.#ctor(CEX.IO.MemoryStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the CipherKey structure using a Stream
</summary>
            <param name="KeyStream">The Stream containing the CipherKey</param>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.#ctor(CEX.Common.CipherDescription*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
CipherKey structure constructor.
<para>KeyID and ExtRandom values must each be 16 bytes in length.
If they are not specified they will be populated automatically.</para></summary>
            <param name="Description">The CipherDescriptionstructure containing a complete description of the cipher instance</param>
            <param name="KeyId">The unique 16 byte ID field used to identify this key. A null value auto generates this field</param>
            <param name="ExtensionKey">An array of random bytes used to encrypt a message file extension. A null value auto generates this field</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if either the KeyId or ExtensionKey fields are null or invalid</exception>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.#ctor">
            <summary>
Default constructor
</summary>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.ExtensionKey">
            <summary>
An array of random bytes used to encrypt a message file extension. A null value auto generates this field
</summary>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.KeyId">
            <summary>
The unique 16 byte ID field used to identify this key. A null value auto generates this field
</summary>
        </member>
        <member name="M:CEX.Processing.Structure.CipherKey.Description">
            <summary>
The CipherDescription structure containing a complete description of the cipher instance
</summary>
        </member>
        <member name="T:CEX.Processing.Structure.CipherKey">
            <summary>
The CipherKey structure.
<para>Used in conjunction with the CipherStream class. 
This structure is used as the header for a single use key and vector set.</para></summary>
            <example>
                <description>Example of populating a CipherKey structure:</description>
                <code>
CipherKey ck = new CipherKey(description);
</code>
            </example>
            <seealso cref="T:CEX.Common.CipherDescription" />
        </member>
        <member name="M:CEX.Common.CipherDescription.Equals(CEX.Common.CipherDescription*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Compare this object instance with another
</summary>
            <param name="Obj">Object to compare</param>
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:CEX.Common.CipherDescription.GetHashCode">
            <summary>
Get the hash code for this object
</summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:CEX.Common.CipherDescription.ToStream">
            <summary>
Convert the CipherDescription structure to a MemoryStream
</summary>
            <returns>The MemoryStream containing the CipherDescription</returns>
        </member>
        <member name="M:CEX.Common.CipherDescription.ToBytes">
            <summary>
Convert the CipherDescription structure to a byte array
</summary>
            <returns>The byte array containing the CipherDescription</returns>
        </member>
        <member name="M:CEX.Common.CipherDescription.Reset">
            <summary>
Reset all struct members
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.GetHeaderSize">
            <summary>
Get the header Size in bytes
</summary>
            <returns>Header size</returns>
        </member>
        <member name="M:CEX.Common.CipherDescription.#ctor(CEX.IO.MemoryStream!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the CipherDescription structure using a Stream
</summary>
            <param name="DescriptionStream">The Stream containing the CipherDescription</param>
        </member>
        <member name="M:CEX.Common.CipherDescription.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the CipherDescription structure using a byte array
</summary>
            <param name="DescriptionArray">The byte array containing the CipherDescription</param>
        </member>
        <member name="M:CEX.Common.CipherDescription.#ctor(&lt;unknown type&gt;,System.UInt32,&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;,&lt;unknown type&gt;,System.UInt32,&lt;unknown type&gt;)">
            <summary>
CipherDescription constructor
</summary>
            <param name="EngineType">The Cryptographic Engine type</param>
            <param name="KeySize">The cipher Key Size in bytes</param>
            <param name="IvSize">Size of the cipher Initialization Vector</param>
            <param name="CipherType">The type of Cipher Mode</param>
            <param name="PaddingType">The type of cipher Padding Mode</param>
            <param name="BlockSize">The cipher Block Size</param>
            <param name="RoundCount">The number of diffusion Rounds</param>
            <param name="KdfEngine">The Digest engine used to power the key schedule Key Derivation Function in HX and M series ciphers</param>
            <param name="MacSize">The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key</param>
            <param name="MacEngine">The HMAC Digest engine used to authenticate a message file encrypted with this key</param>
        </member>
        <member name="M:CEX.Common.CipherDescription.#ctor">
            <summary>
Default constructor
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.MacEngine">
            <summary>
The HMAC Digest engine used to authenticate a message file encrypted with this key
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.MacSize">
            <summary>
The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.KdfEngine">
            <summary>
The Digest engine used to power the key schedule Key Derivation Function in HX and M series ciphers
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.RoundCount">
            <summary>
The number of diffusion Rounds
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.BlockSize">
            <summary>
The cipher Block Size
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.PaddingType">
            <summary>
The type of cipher Padding Mode
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.CipherType">
            <summary>
The type of Cipher Mode
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.IvSize">
            <summary>
Size of the cipher Initialization Vector
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.KeySize">
            <summary>
Get: The cipher Key Size
</summary>
            <summary>
Set: The cipher Key Size
</summary>
        </member>
        <member name="M:CEX.Common.CipherDescription.EngineType">
            <summary>
The Cryptographic Engine type
</summary>
        </member>
        <member name="T:CEX.Common.CipherDescription">
            <summary>
The CipherDescription structure.
<para>Used in conjunction with the CipherStream class.
Contains all the necessary settings required to recreate a cipher instance.</para></summary>
            <example>
                <description>Example of populating a <c>CipherDescription</c> structure:</description>
                <code>
   CipherDescription dsc(
       Engines.RHX,             // cipher engine
       192,                     // key size in bytes
       IVSizes.V128,            // cipher iv size enum
       CipherModes.CTR,         // cipher mode enum
       PaddingModes.X923,       // cipher padding mode enum
       BlockSizes.B128,         // block size enum
       RoundCounts.R18,         // diffusion rounds enum
       Digests.Skein512,        // cipher kdf engine
       64,                      // mac size
       Digests.Keccak);         // mac digest
</code>
            </example>
            <seealso cref="T:CEX.Enumeration.BlockSizes" />
            <seealso cref="T:CEX.Enumeration.CipherModes" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <seealso cref="T:CEX.Enumeration.IVSizes" />
            <seealso cref="T:CEX.Enumeration.PaddingModes" />
            <seealso cref="T:CEX.Enumeration.RoundCounts" />
            <seealso cref="T:CEX.Enumeration.SymmetricEngines" />
        </member>
        <member name="T:CEX.Enumeration.SymmetricEngines">
            <summary>
Symmetric Encryption Ciphers
</summary>
        </member>
        <member name="T:CEX.Enumeration.RoundCounts">
            <summary>
Rounds Count. Can be cast as round count integers, 
i.e. (int ct = RoundCounts.R12) is equal to 12.
</summary>
        </member>
        <member name="F:R64">
            <summary>
64 Rounds: SHX
</summary>
        </member>
        <member name="F:R56">
            <summary>
56 Rounds: SHX
</summary>
        </member>
        <member name="F:R48">
            <summary>
48 Rounds: SHX
</summary>
        </member>
        <member name="F:R40">
            <summary>
40 Rounds: SHX
</summary>
        </member>
        <member name="F:R38">
            <summary>
38 Rounds, RHX
</summary>
        </member>
        <member name="F:R34">
            <summary>
34 Rounds, RHX
</summary>
        </member>
        <member name="F:R32">
            <summary>
32 Rounds: RHX, SHX, THX
</summary>
        </member>
        <member name="F:R30">
            <summary>
30 Rounds: ChaCha, RHX, THX
</summary>
        </member>
        <member name="F:R28">
            <summary>
28 Rounds: ChaCha, RHX, THX
</summary>
        </member>
        <member name="F:R26">
            <summary>
26 Rounds: ChaCha, RHX, THX
</summary>
        </member>
        <member name="F:R24">
            <summary>
24 Rounds: ChaCha, RHX, THX
</summary>
        </member>
        <member name="F:R22">
            <summary>
22 Rounds: ChaCha, RHX, THX
</summary>
        </member>
        <member name="F:R20">
            <summary>
20 Rounds: ChaCha, RHX, THX
</summary>
        </member>
        <member name="F:R18">
            <summary>
18 Rounds: ChaCha, RHX, THX
</summary>
        </member>
        <member name="F:R16">
            <summary>
16 Rounds: ChaCha, RHX, THX
</summary>
        </member>
        <member name="F:R14">
            <summary>
14 Rounds: ChaCha, RHX
</summary>
        </member>
        <member name="F:R12">
            <summary>
12 Rounds: ChaCha, RHX
</summary>
        </member>
        <member name="F:R10">
            <summary>
10 Rounds: ChaCha, RHX
</summary>
        </member>
        <member name="F:R8">
            <summary>
8 Rounds: ChaCha
</summary>
        </member>
        <member name="T:CEX.Enumeration.IVSizes">
            <summary>
                <para>IV Sizes in bits. Can be cast as IV byte size integers, 
i.e. (int sz = IVSizes.V128) is equal to 16.</para>
            </summary>
        </member>
        <member name="F:V256">
            <summary>
256 bit IV
</summary>
        </member>
        <member name="F:V128">
            <summary>
128 bit IV
</summary>
        </member>
        <member name="F:V64">
            <summary>
64 bit IV
</summary>
        </member>
        <member name="T:CEX.Enumeration.BlockSizes">
            <summary>
                <para>Block cipher sizes in bits. Can be cast as Block byte size integers, 
i.e. (int sz = BlockSizes.B512) is equal to 64.</para>
            </summary>
        </member>
        <member name="F:B1024">
            <summary>
1024 bit block size
</summary>
        </member>
        <member name="F:B512">
            <summary>
512 bit block size
</summary>
        </member>
        <member name="F:B256">
            <summary>
256 bit block size
</summary>
        </member>
        <member name="F:B128">
            <summary>
128 bit block size
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Transform a block of bytes with offset parameters.
<para> Parallel capable in Decryption mode.
Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Transform a block of bytes. Parallel capable in Decryption mode.
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Encryption">True if cipher is used for encryption, false to decrypt</param>
            <param name="KeyParam">KeyParam containing key and std::vector</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt a block of bytes with offset parameters. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt a block of bytes. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Decrypt a block of bytes with offset parameters. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Decrypt a block of bytes.
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.#ctor(CEX.Cipher.Symmetric.Block.IBlockCipher*)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Cipher">Underlying encryption cipher</param>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Cipher.Symmetric.Block.Mode.CBC.ParallelMinimumSize" />.
<para>The parallel block size is calculated automatically based on the number of available processors on the system (n * 64kb).</para></summary>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, 
or block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.IV">
            <summary>
Get: The current state of the initialization Vector
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.IsParallel">
            <summary>
Get/Set: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.IsEncryption">
            <summary>
Get: Initialized for encryption, false for decryption
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.Enumeral">
            <summary>
Get: The cipher modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.Engine">
            <summary>
Get: Underlying Cipher
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.CBC.BlockSize">
            <summary>
Get: Unit block size of internal cipher
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Mode.CBC">
            <summary>
Implements a Cipher Block Chaining Mode: CBC
</summary>
            <example>
                <description>Example using an <c>ICipherMode</c> interface:</description>
                <code>
CBC cipher(new RDX());
// initialize for encryption
cipher.Initialize(true, KeyParams(Key, IV));
// encrypt a block
cipher.Transform(Input, Output);
</code>
            </example>
            <seealso cref="N:CEX.Cipher.Symmetric.Block" />
            <seealso cref="T:CEX.Cipher.Symmetric.Block.Mode.ICipherMode" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>In CFB mode, only decryption can be processed in parallel.</description>
                    </item>
                    <item>
                        <description>Parallel processing is enabled on decryption by passing a block size of ParallelBlockSize to the transform.</description>
                    </item>
                    <item>
                        <description>ParallelBlockSize must be divisible by ParallelMinimumSize.</description>
                    </item>
                    <item>
                        <description>Parallel block calculation ex. <c>int blocklen = (data.size() / cipher.ParallelMinimumSize()) * 100</c></description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt/Decrypt an array of bytes with offset and length parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Stream.ChaCha.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
            <param name="Length">Number of bytes to process</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt/Decrypt an array of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Stream.ChaCha.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt/Decrypt an array of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Stream.ChaCha.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Reset">
            <summary>
Reset the primary internal counter
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher
</summary>
            <param name="KeyParam">Cipher key container. 
<para>Uses the Key and IV fields of KeyParam. 
The <see cref="M:CEX.Cipher.Symmetric.Stream.ChaCha.LegalKeySizes" /> property contains valid Key sizes. 
IV must be 8 bytes in size.</para></param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Destroy">
            <summary>
Destroy of this class
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.#ctor(System.UInt32)">
            <summary>
Initialize the class
</summary>
            <param name="Rounds">Number of diffusion rounds. The <see cref="M:CEX.Cipher.Symmetric.Stream.ChaCha.LegalRounds" /> property contains available sizes. Default is 20 rounds.</param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.VectorSize">
            <summary>
Get: Initialization vector size
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Rounds">
            <summary>
Get: Number of rounds
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. 
<para>Parallel blocks must be a multiple of this size.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Cipher.Symmetric.Stream.ChaCha.ParallelMinimumSize" />.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.IsParallel">
            <summary>
Get/Set: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.LegalRounds">
            <summary>
Get: Available diffusion round assignments
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Enumeral">
            <summary>
Get: The stream ciphers type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.DistributionCode">
            <summary>
Get/Set: Sets the Nonce value in the initialization parameters (Tau-Sigma).
<para>Must be set before <see cref="M:CEX.Cipher.Symmetric.Stream.ChaCha.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> is called.
Changing this code will create a unique distribution of the cipher.
Code must be 16 bytes in length and sufficiently asymmetric (no more than 2 repeating characters, at a distance of 2 intervals).</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.Counter">
            <summary>
Get the current counter value
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.ChaCha.BlockSize">
            <summary>
Get: Unit block size of internal cipher in bytes.
<para>Block size is 64 bytes wide.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt/Decrypt an array of bytes with offset and length parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Stream.Salsa20.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
            <param name="Length">Number of bytes to process</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt/Decrypt an array of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Stream.Salsa20.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt/Decrypt an array of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Stream.Salsa20.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Reset">
            <summary>
Reset the primary internal counter
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher
</summary>
            <param name="KeyParam">Cipher key container. 
<para>Uses the Key and IV fields of KeyParam. 
The <see cref="M:CEX.Cipher.Symmetric.Stream.Salsa20.LegalKeySizes" /> property contains valid Key sizes. 
IV must be 8 bytes in size.</para></param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Destroy">
            <summary>
Destroy of this class
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.#ctor(System.UInt32)">
            <summary>
Initialize the class
</summary>
            <param name="Rounds">Number of diffusion rounds. The <see cref="M:CEX.Cipher.Symmetric.Stream.Salsa20.LegalRounds" /> property contains available sizes. Default is 20 rounds.</param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.VectorSize">
            <summary>
Get: Initialization vector size
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Rounds">
            <summary>
Get: Number of rounds
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Cipher.Symmetric.Stream.Salsa20.ParallelMinimumSize" />.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.LegalRounds">
            <summary>
Get: Available diffusion round assignments
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.IsParallel">
            <summary>
Get: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Enumeral">
            <summary>
Get: The stream ciphers type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.DistributionCode">
            <summary>
Get/Set: Sets the Nonce value in the initialization parameters (Tau-Sigma).
<para>Must be set before <see cref="M:CEX.Cipher.Symmetric.Stream.Salsa20.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> is called.
Changing this code will create a unique distribution of the cipher.
Code must be 16 bytes in length and sufficiently asymmetric (no more than 2 repeating characters, at a distance of 2 intervals).</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.Counter">
            <summary>
Get the current counter value
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.Salsa20.BlockSize">
            <summary>
Get: Unit block size of internal cipher in bytes.
<para>Block size is 64 bytes wide.</para></summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Stream.Salsa20">
            <summary>
Salsa20+: A parallelized Salsa20 stream cipher implementation
</summary>
            <example>
                <description>Encrypt an array with Salsa20:</description>
                <code>
KeyParams kp(key, iv);
Salsa20 cipher(20);
// linear encrypt
cipher.Initialize(kp);
cipher.IsParallel() = false;
cipher.Transform(Input, Output);
</code>
            </example>
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description>
                    </item>
                    <item>
                        <description>Block size is 64 bytes wide.</description>
                    </item>
                    <item>
                        <description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description>
                    </item>
                    <item>
                        <description>Parallel block size is 64,000 bytes by default; but is configurable.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>Salsa20 <a href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</a>.</description>
                    </item>
                    <item>
                        <description>Salsa20 <a href="http://cr.yp.to/snuffle/design.pdf">Design</a>.</description>
                    </item>
                    <item>
                        <description>Salsa20 <a href="http://cr.yp.to/snuffle/security.pdf">Security</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt/Decrypt an array of bytes with offset and length parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
            <param name="Length">Length of data to process</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt/Decrypt an array of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt/Decrypt an array of bytes
</summary>
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Initialize(CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher
</summary>
            <param name="KeyParam">Cipher key container. The LegalKeySizes property contains valid sizes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.VectorSize">
            <summary>
Get: Initialization vector size
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Rounds">
            <summary>
Get: Number of rounds
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.ParallelMinimumSize" />.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.LegalRounds">
            <summary>
Get: Available diffusion round assignments
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.LegalKeySizes">
            <summary>
Get: Unit block size of internal cipher in bytes.
<para>Block size must be 16 or 32 bytes wide. 
Value set in class constructor.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.IsParallel">
            <summary>
Get/Set: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Enumeral">
            <summary>
Get: The stream ciphers type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.BlockSize">
            <summary>
Get: Unit block size of internal cipher in bytes.
<para>Block size must be 16 or 32 bytes wide. 
Value set in class constructor.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Stream.IStreamCipher.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Stream.IStreamCipher">
            <summary>
Stream Cipher Interface
</summary>
        </member>
        <member name="T:CEX.Enumeration.StreamCiphers">
            <summary>
Stream Ciphers
</summary>
        </member>
        <member name="F:Salsa">
            <summary>
A Salsa20 Stream Cipher
</summary>
            <summary>
A Salsa20 Stream Cipher
</summary>
        </member>
        <member name="F:ChaCha">
            <summary>
An implementation of the ChaCha Stream Cipher
</summary>
            <summary>
An implementation of the ChaCha Stream Cipher
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.InverseTransform(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <remarks>
Apply the inverse of the linear transformation to the register set
</remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.LinearTransform(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <remarks>
Apply the linear transformation to the register set
</remarks>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.Update(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Update the Salt material
</summary>
            <param name="Salt">Salt value; size must be at least cipher key size + cipher block size</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt is too small</exception>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value; size must be at least cipher key size + cipher block size</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt is too small</exception>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Generate pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            <returns>Number of bytes generated</returns>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Generate a block of pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.#ctor(CEX.Cipher.Symmetric.Block.IBlockCipher*,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Creates a HKDF Bytes Generator using the given HMAC function
</summary>
            <param name="Cipher">The Block Cipher instance</param>
            <param name="KeySize">The internal ciphers key size; calculated automatically if this value is zero</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if a null cipher is used</exception>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Generator.CTRDrbg.ParallelMinimumSize" />.
</summary>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.KeySize">
            <summary>
                <para>Minimum initialization key size in bytes; 
combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.IV">
            <summary>
Get: The current state of the initialization Vector
</summary>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.IsParallel">
            <summary>
Get/Set: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.IsInitialized">
            <summary>
Get: Generator is ready to produce data
</summary>
        </member>
        <member name="M:CEX.Generator.CTRDrbg.Enumeral">
            <summary>
Get: The generators type name
</summary>
        </member>
        <member name="T:CEX.Generator.CTRDrbg">
            <summary>
CTRDrbg: An implementation of a Encryption Counter based Deterministic Random Byte Generator
</summary>
            <example>
                <description>Generate an array of pseudo random bytes:</description>
                <code>
CTRDrbg rnd(new RDX());
// initialize
rnd.Initialize(Salt, [Ikm], [Nonce]);
// generate bytes
rnd.Generate(Output, [Offset], [Size]);
</code>
            </example>
            <seealso cref="N:CEX.Cipher.Symmetric.Block" />
            <seealso cref="T:CEX.Enumeration.BlockCiphers" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Can be initialized with any block cipher.</description>
                    </item>
                    <item>
                        <description>Parallelized by default on a multi processer system when an input byte array of <see cref="M:CEX.Generator.CTRDrbg.ParallelMinimumSize" /> bytes or larger is used.</description>
                    </item>
                    <item>
                        <description>Parallelization can be disabled using the <see cref="M:CEX.Generator.CTRDrbg.IsParallel" /> property.</description>
                    </item>
                    <item>
                        <description>Combination of [Salt, Ikm, Nonce] must be: cipher key size +  cipher block size in length.</description>
                    </item>
                    <item>
                        <description>Nonce and Ikm are optional, (but recommended).</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>: Recommendation for the Entropy Sources Used for Random Bit Generation.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Fips 140-2</a>: Security Requirments For Cryptographic Modules.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">SP800-22 1a</a>: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://eprint.iacr.org/2006/379.pdf">Security Bounds</a> for the Codebook-based: Deterministic Random Bit Generator.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Mac.VMAC.InitKey(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <remarks>
Section 3.2, table 2 <a href="http://vmpcfunction.com/vmpc_mac.pdf">VMPC-MAC: 
A Stream Cipher Based Authenticated Encryption Scheme</a></remarks>
        </member>
        <member name="M:CEX.Mac.VMAC.Update(System.Byte)">
            <summary>
Update the digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Mac.VMAC.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Mac.VMAC.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the VMPC MAC.
<para>Uses the Key and IV fields of the KeyParams class.</para></summary>
            <param name="MacKey">A byte array containing the Key</param>
            <param name="IV">A byte array containing the Initialization Vector</param>
            <exception cref="T:CEX.Exception.CryptoMacException">Thrown if a null or invalid Key, or IV is used</exception>
        </member>
        <member name="M:CEX.Mac.VMAC.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Process the last block of data
</summary>
            <param name="Output">The hash value return</param>
            <param name="OutOffset">The offset in the data</param>
            <returns>The number of bytes processed</returns>
            <exception cref="T:CEX.Exception.CryptoMacException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:CEX.Mac.VMAC.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Mac.VMAC.ComputeMac(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Mac hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The output message code</param>
        </member>
        <member name="M:CEX.Mac.VMAC.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:CEX.Mac.VMAC.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Mac.VMAC.#ctor">
            <summary>
Initialize the VMAC class
</summary>
        </member>
        <member name="M:CEX.Mac.VMAC.Name">
            <summary>
Get: Algorithm name
</summary>
        </member>
        <member name="M:CEX.Mac.VMAC.IsInitialized">
            <summary>
Get: Mac is ready to digest data
</summary>
        </member>
        <member name="M:CEX.Mac.VMAC.MacSize">
            <summary>
Get: Size of returned mac in bytes
</summary>
        </member>
        <member name="M:CEX.Mac.VMAC.Enumeral">
            <summary>
Get: The macs type name
</summary>
        </member>
        <member name="M:CEX.Mac.VMAC.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Mac.VMAC">
            <summary>
An implementation of a Variably Modified Permutation Composition based Message Authentication Code
</summary>
            <example>
                <description>Example generating a MAC code from an Input array</description>
                <code>
CEX::Mac::VMAC mac;
// initialize
mac.Initialize(Key, Iv);
// get mac code
mac.ComputeMac(Input, Output);
</code>
            </example>
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>No fixed block size is used.</description>
                    </item>
                    <item>
                        <description>MAC return size is 20 bytes.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>VMPC <a href="http://www.vmpcfunction.com/vmpc_mac.pdf">MAC Specification</a>:  VMPC-MAC: A Stream Cipher Based Authenticated Encryption Scheme.</description>
                    </item>
                    <item>
                        <description>VMPC <a href="http://www.vmpcfunction.com/vmpcmac.htm">VMPC-MAC</a> Authenticated Encryption Scheme.</description>
                    </item>
                    <item>
                        <description>IETF <a href="http://www.okna.wroc.pl/vmpc.pdf">VMPC One-Way Function</a> and Stream Cipher.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:Threefish512.SetTweak(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the tweak
</summary>
            <param name="Tweak">The cipher tweak</param>
        </member>
        <member name="M:Threefish512.SetKey(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the key
</summary>
            <param name="Key">The cipher key</param>
        </member>
        <member name="M:Threefish512.Encrypt(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt a block
</summary>
            <param name="Input">Input array</param>
            <param name="Output">Processed bytes</param>
        </member>
        <member name="M:Threefish512.Clear">
            <summary>
Reset the state
</summary>
        </member>
        <member name="M:Threefish512.#ctor">
            <summary>
Threefish with a 512 bit block
</summary>
        </member>
        <member name="T:Threefish512">
            <summary>
Part of Skein512: the Threefish cipher using a 512bit key size.
</summary>
        </member>
        <member name="M:CEX.Seed.XSPRsg.Split(System.UInt64)">
            <summary>
Implementation of java's Splittable function
</summary>
            <param name="X">Input integer</param>
            <returns>A processed long integer</returns>
        </member>
        <member name="M:CEX.Seed.XSPRsg.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Seed.XSPRsg.Next">
            <summary>
Returns the next pseudo random 32bit integer
</summary>
            <returns>A pseudo random 32bit integer</returns>
        </member>
        <member name="M:CEX.Seed.XSPRsg.Jump">
            <summary>
Increment the state by 64 blocks; used with the 128 and 1024 implementations
</summary>
        </member>
        <member name="M:CEX.Seed.XSPRsg.GetBytes(System.Int32)">
            <summary>
Get a pseudo random seed byte array
</summary>
            <param name="Size">The size of the expected seed returned</param>
            <returns>A pseudo random seed</returns>
        </member>
        <member name="M:CEX.Seed.XSPRsg.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill the buffer with random bytes
</summary>
            <param name="Output">The array to fill</param>
        </member>
        <member name="M:CEX.Seed.XSPRsg.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Seed.XSPRsg.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Seed.XSPRsg.#ctor(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize this class with a random seed array.
<para>Initializing with 2 ulongs invokes the 128 bit function, initializing with 16 ulongs
invokes the 1024 bit function.</para></summary>
            <param name="Seed">The initial state values; can be either 2, or 16, 64bit values</param>
            <exception cref="T:CEX.Exception.CryptoRandomException">Thrown if an invalid seed size is used</exception>
        </member>
        <member name="M:CEX.Seed.XSPRsg.#ctor">
            <summary>
Initialize this class using the default random provider to generate 16 ulongs and invoke the 1024 bit function
</summary>
        </member>
        <member name="M:CEX.Seed.XSPRsg.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Seed.XSPRsg.Enumeral">
            <summary>
Get: The seed generators type name
</summary>
        </member>
        <member name="T:CEX.Seed.XSPRsg">
            <summary>
XSPRsg: Generates seed material using an XorShift+ generator.
<para>This generator is not generally considered a cryptographic quality generator. 
This generator is suitable as a quality high-speed number generator, but not to be used directly for tasks that require secrecy, ex. key generation.</para></summary>
            <example>
                <description>Example of getting a seed value:</description>
                <code>
XSPRsg gen(Seed);
gen.GetSeed(Output);
</code>
            </example>
            <remarks>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>Further scramblings of Marsaglia’s <a href="http://vigna.di.unimi.it/ftp/papers/xorshiftplus.pdf">Xorshift Generators</a>.</description>
                    </item>
                    <item>
                        <description>
                            <a href="http://xorshift.di.unimi.it/">Xorshift+ generators</a> and the PRNG shootout.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.X923.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.X923.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.X923.AddPadding(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Add padding to input array
</summary>
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
            <exception cref="T:CEX.Exception.CryptoPaddingException">Thrown if the padding offset value is longer than the array length</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.X923.Name">
            <summary>
Get: Padding name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.X923.Enumeral">
            <summary>
Get: The padding modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.X923.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.X923.#ctor">
            <summary>
Initialize this class
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Padding.X923">
            <summary>
The X.923 Padding Scheme
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.PKCS7.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.PKCS7.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.PKCS7.AddPadding(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Add padding to input array
</summary>
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
            <exception cref="T:CEX.Exception.CryptoPaddingException">Thrown if the padding offset value is longer than the array length</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.PKCS7.Name">
            <summary>
Get: Padding name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.PKCS7.Enumeral">
            <summary>
Get: The padding modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.PKCS7.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.PKCS7.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Padding.PKCS7">
            <summary>
The PKCS7 Padding Scheme
</summary>
            <remarks>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>RFC <a href="http://tools.ietf.org/html/rfc5652">5652</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Helper.PaddingFromName.GetInstance(&lt;unknown type&gt;)">
            <summary>
Get a Padding Mode by name
</summary>
            <param name="PaddingType">The padding enumeration name</param>
            <returns>An initialized padding mode</returns>
            <exception cref="T:CEX.Exception.CryptoException">Thrown if the enumeration name is not supported</exception>
        </member>
        <member name="T:CEX.Helper.PaddingFromName">
            <summary>
PaddingFromName: Get a Cipher Padding Mode instance from it's enumeration name.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.TBC.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.TBC.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.TBC.AddPadding(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Add padding to input array
</summary>
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
            <exception cref="T:CEX.Exception.CryptoPaddingException">Thrown if the padding offset value is longer than the array length</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.TBC.Name">
            <summary>
Get: Padding name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.TBC.Enumeral">
            <summary>
Get: The padding modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.TBC.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.TBC.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Padding.TBC">
            <summary>
The Trailing Bit Compliment Padding Scheme.
</summary>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.Update(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Update the Salt material
</summary>
            <param name="Seed">Pseudo random seed material</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt value is too small</exception>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value; salt must be at least 1* block size + counter size of 8 bytes</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt is too small</exception>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Generate pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            <returns>Number of bytes generated</returns>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Generate a block of pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.#ctor(CEX.Digest.IDigest*)">
            <summary>
Initialize the class
</summary>
            <param name="Digest">Hash function</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if a null digest is used</exception>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.KeySize">
            <summary>
                <para>Minimum initialization key size in bytes; 
combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.IsInitialized">
            <summary>
Get: Generator is ready to produce data
</summary>
        </member>
        <member name="M:CEX.Generator.DGCDrbg.Enumeral">
            <summary>
Get: The generators type name
</summary>
        </member>
        <member name="T:CEX.Generator.DGCDrbg">
            <summary>
DGTDRBG: An implementation of a Digest Counter based Deterministic Random Byte Generator
</summary>
            <example>
                <description>Generate an array of pseudo random bytes:</description>
                <code>
DGTDRBG rnd(new SHA512());
// initialize
rnd.Initialize(Salt, [Ikm], [Nonce]);
// generate bytes
rnd.Generate(Output, [Offset], [Size]);
</code>
            </example>
            <seealso cref="N:CEX.Digest" />
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Can be initialized with any digest.</description>
                    </item>
                    <item>
                        <description>Combination of [Salt, Ikm, Nonce] must be at least: digest block size + counter (8 bytes) size in length.</description>
                    </item>
                    <item>
                        <description>Nonce and Ikm are optional, (but recommended).</description>
                    </item>
                    <item>
                        <description>Output buffer is 4 * the digest return size.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf">SP800-90A R1</a>: Appendix E1.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf">SP800-90A</a>: Appendix E1.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>: Recommendation for the Entropy Sources Used for Random Bit Generation.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Fips 140-2</a>: Security Requirments For Cryptographic Modules.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">SP800-22 1a</a>: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://eprint.iacr.org/2006/379.pdf">Security Bounds</a> for the Codebook-based: Deterministic Random Bit Generator.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:Threefish1024.SetTweak(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the tweak
</summary>
            <param name="Tweak">The cipher tweak</param>
        </member>
        <member name="M:Threefish1024.SetKey(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the key
</summary>
            <param name="Key">The cipher key</param>
        </member>
        <member name="M:Threefish1024.Encrypt(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt a block
</summary>
            <param name="Input">Input array</param>
            <param name="Output">Processed bytes</param>
        </member>
        <member name="M:Threefish1024.Clear">
            <summary>
Reset the state
</summary>
        </member>
        <member name="M:Threefish1024.#ctor">
            <summary>
Threefish with a 1024 bit block
</summary>
        </member>
        <member name="T:Threefish1024">
            <summary>
Part of Skein1024: the Threefish cipher using a 1024bit key size.
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.Update(System.Byte)">
            <summary>
Update the message digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Digest.Skein256.SetVersion(System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the version string. Version must be between 0 and 3, inclusive.
</summary>
            <param name="Version">Version string</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if an invalid version is used</exception>
        </member>
        <member name="M:CEX.Digest.Skein256.SetTreeLeafSize(System.Byte!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the tree leaf size
</summary>
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:CEX.Digest.Skein256.SetTreeFanOutSize(System.Byte!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the tree fan out size
</summary>
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:CEX.Digest.Skein256.SetSchema(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the Schema. Schema must be 4 bytes.
</summary>
            <param name="Schema">Schema Configuration string</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if an invalid schema is used</exception>
        </member>
        <member name="M:CEX.Digest.Skein256.SetMaxTreeHeight(System.Byte!System.Runtime.CompilerServices.IsConst)">
            <summary>
Set the tree height. Tree height must be zero or greater than 1.
</summary>
            <param name="Height">Tree height</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if an invalid tree height is used</exception>
        </member>
        <member name="M:CEX.Digest.Skein256.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.Initialize(&lt;unknown type&gt;)">
            <summary>
Used to re-initialize the digest state.
<para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
This does not start a new UBI block type, and must be done manually.</para></summary>
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:CEX.Digest.Skein256.GenerateConfiguration(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;)">
            <summary>
Generate a configuration using a state key
</summary>
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:CEX.Digest.Skein256.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Do final processing and get the hash value
</summary>
            <param name="Output">The Hash output value array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <returns>Size of Hash value</returns>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the output buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Skein256.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The hash output value array</param>
        </member>
        <member name="M:CEX.Digest.Skein256.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the input buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Skein256.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.#ctor(&lt;unknown type&gt;)">
            <summary>
Initialize the digest
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.GetUbiParameters">
            <summary>
Ubi Tweak parameters
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.GetStateSize">
            <summary>
Get the state size in bits
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.GetInitializationType">
            <summary>
Get the initialization type
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.GetConfigValue">
            <summary>
Get the post-chain configuration value
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.GetConfigString">
            <summary>
Get the pre-chain configuration string
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.Enumeral">
            <summary>
Get: The digests type enumeration member
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.DigestSize">
            <summary>
Get: Size of returned digest in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.Skein256.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Digest.Skein256">
            <summary>
Skein256: An implementation of the Skein digest with a 256 bit digest return size
</summary>
            <example>
                <description>Example using the ComputeHash method:</description>
                <code>
Skein256 digest;
std:vector&lt;byte&gt; hash(digest.DigestSize(), 0);
// compute a hash
digest.ComputeHash(Input, hash);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Block size is 32 bytes, (256 bits).</description>
                    </item>
                    <item>
                        <description>Digest size is 32 bytes, (256 bits).</description>
                    </item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Skein256.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> method wraps the <see cref="M:CEX.Digest.Skein256.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)" /> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Skein256.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)" /> method does NOT reset the internal state; call <see cref="M:CEX.Digest.Skein256.Reset" /> to reinitialize.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>Skein <a href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">The Skein digest</a>.</description>
                    </item>
                    <item>
                        <description>The Skein Hash Function Family <a href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</a>.</description>
                    </item>
                    <item>
                        <description>Skein <a href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</a> Support for the Skein Hash Family.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">SHA3 Third-Round Report</a> of the SHA-3 Cryptographic Hash Algorithm Competition&gt;.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:UbiTweak.StartNewBlockType(&lt;unknown type&gt;!System.Runtime.CompilerServices.IsConst)">
            <summary>
Starts a new UBI block type by setting BitsProcessed to zero, setting the first flag, and setting the block type
</summary>
            <param name="Value">The UBI block type of the new block</param>
        </member>
        <member name="M:UbiTweak.SetTweak(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst)">
            <summary>
Sets the tweak value array
</summary>
        </member>
        <member name="M:UbiTweak.SetTreeLevel(System.Byte!System.Runtime.CompilerServices.IsConst)">
            <summary>
Sets the current tree level
</summary>
        </member>
        <member name="M:UbiTweak.SetIsFinalBlock(System.UInt64!System.Runtime.CompilerServices.IsConst)">
            <summary>
Sets the final block flag
</summary>
        </member>
        <member name="M:UbiTweak.SetIsFirstBlock(System.Boolean!System.Runtime.CompilerServices.IsConst)">
            <summary>
Sets the first block flag
</summary>
        </member>
        <member name="M:UbiTweak.SetBlockType(&lt;unknown type&gt;!System.Runtime.CompilerServices.IsConst)">
            <summary>
Sets the current UBI block type
</summary>
        </member>
        <member name="M:UbiTweak.SetBitsProcessed(System.UInt64!System.Runtime.CompilerServices.IsConst)">
            <summary>
Sets the number of bits processed so far, inclusive
</summary>
        </member>
        <member name="M:UbiTweak.GetTweak">
            <summary>
Gets the tweak value array
</summary>
        </member>
        <member name="M:UbiTweak.GetTreeLevel">
            <summary>
Gets the current tree level
</summary>
        </member>
        <member name="M:UbiTweak.GetIsFirstBlock">
            <summary>
Gets the first block flag
</summary>
        </member>
        <member name="M:UbiTweak.GetIsFinalBlock">
            <summary>
Gets the final block flag
</summary>
        </member>
        <member name="M:UbiTweak.GetBlockType">
            <summary>
Gets the current UBI block type.
</summary>
        </member>
        <member name="M:UbiTweak.GetBitsProcessed">
            <summary>
Gets the number of bits processed so far, inclusive.
</summary>
        </member>
        <member name="M:UbiTweak.Clear">
            <summary>
Clear the teak value
</summary>
        </member>
        <member name="M:UbiTweak.#ctor">
            <summary>
Initialize this class
</summary>
        </member>
        <member name="T:UbiTweak">
            <summary>
Part of Skein: the UBI Tweak structure.
</summary>
        </member>
        <member name="T:SkeinInitializationType">
            <summary>
Specifies the Skein initialization type
</summary>
        </member>
        <member name="F:ChainedConfig">
            <summary>
Creates the initial state by chaining the previous state value with the config block, then initializes the hash.
This starts a new UBI block type with the standard Payload type.
</summary>
        </member>
        <member name="F:ChainedState">
            <summary>
Leaves the initial state set to its previous value, which is then chained with subsequent block transforms.
This does not start a new UBI block type, and must be done manually.
</summary>
        </member>
        <member name="F:ZeroedState">
            <summary>
Creates the initial state with zeros instead of the configuration block, then initializes the hash.
This does not start a new UBI block type, and must be done manually.
</summary>
        </member>
        <member name="F:Normal">
            <summary>
Identical to the standard Skein initialization.
</summary>
        </member>
        <member name="T:UbiType">
            <summary>
Specifies the Skein Ubi type
</summary>
        </member>
        <member name="F:Out">
            <summary>
The output transform.
</summary>
        </member>
        <member name="F:Message">
            <summary>
The normal message input of the hash function.
</summary>
        </member>
        <member name="F:Nonce">
            <summary>
Nonce value for use in stream cipher mode and randomized hashing.
</summary>
        </member>
        <member name="F:KeyIdentifier">
            <summary>
Used for key derivation.
</summary>
        </member>
        <member name="F:PublicKey">
            <summary>
Used to hash the public key when hashing a message for signing.
</summary>
        </member>
        <member name="F:Personalization">
            <summary>
A string that applications can use to create different functions for different uses.
</summary>
        </member>
        <member name="F:Config">
            <summary>
The configuration block.
</summary>
        </member>
        <member name="F:Key">
            <summary>
A key that turns Skein into a MAC or KDF function.
</summary>
        </member>
        <member name="M:Threefish256.SetTweak(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the tweak
</summary>
            <param name="Tweak">The cipher tweak</param>
        </member>
        <member name="M:Threefish256.SetKey(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the key
</summary>
            <param name="Key">The cipher key</param>
        </member>
        <member name="M:Threefish256.Encrypt(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt a block
</summary>
            <param name="Input">Input array</param>
            <param name="Output">Processed bytes</param>
        </member>
        <member name="M:Threefish256.Clear">
            <summary>
Reset the state
</summary>
        </member>
        <member name="M:Threefish256.#ctor">
            <summary>
Threefish with a 256 bit block
</summary>
        </member>
        <member name="T:Threefish256">
            <summary>
Part of Skein256: the Threefish cipher using a 256bit key size.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Transform a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.SHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Transform a block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.
Input and Output array lengths must be at least <see cref="M:CEX.Cipher.Symmetric.Block.SHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform or Decrypt</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher.
</summary>
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container.<para>The <see cref="M:CEX.Cipher.Symmetric.Block.SHX.LegalKeySizes" /> property contains valid sizes.</para></param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>true</c> before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.SHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt a block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>true</c> before this method can be used.
Input and Output array lengths must be at least <see cref="M:CEX.Cipher.Symmetric.Block.SHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.Destroy">
            <summary>
Clear the buffers and reset
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Decrypt a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>false</c> before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.SHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Decrypt a single block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>false</c> before this method can be used.
Input and Output arrays must be at least <see cref="M:CEX.Cipher.Symmetric.Block.SHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.#ctor(System.UInt32,&lt;unknown type&gt;)">
            <summary>
Initialize the class
</summary>
            <param name="Rounds">Number of diffusion rounds. The <see cref="M:CEX.Cipher.Symmetric.Block.SHX.LegalRounds" /> property contains available sizes. Default is 32 rounds.</param>
            <param name="KdfEngineType">The Key Schedule KDF digest engine; can be any one of the Digest implementations. The default engine is SHA512.</param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.#ctor(CEX.Digest.IDigest*,System.UInt32)">
            <summary>
Initialize the class with a Digest instance
</summary>
            <param name="KdfEngine">The Key Schedule KDF digest engine; can be any one of the message Digest implementations..</param>
            <param name="Rounds">Number of diffusion rounds. The <see cref="M:CEX.Cipher.Symmetric.Block.SHX.LegalRounds" /> property contains available sizes. Default is 32 rounds.</param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.Rounds">
            <summary>
Get: The number of diffusion rounds processed by the transform
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.LegalRounds">
            <summary>
Get: Available diffusion round assignments
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.IsEncryption">
            <summary>
Get: Initialized for encryption, false for decryption.
<para>Value set in <see cref="M:CEX.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" />.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.IkmSize">
            <summary>
Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
<para>This property can only be changed before the Initialize function is called.</para><para>Default is the digest return size; can only be a multiple of that length.
Maximum size is the digests underlying block size; if the key
is longer than this, the size will default to the block size.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.Enumeral">
            <summary>
Get: The block ciphers type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.DistributionCode">
            <summary>
Get/Set: Sets the Info value in the HKDF initialization parameters.
<para>Must be set before <see cref="M:CEX.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> is called.
Changing this code will create a unique distribution of the cipher.
Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para></summary>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.SHX.BlockSize">
            <summary>
Get: Unit block size of internal cipher in bytes.
<para>Block size must be 16 or 32 bytes wide.
Value set in class constructor.</para></summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.SHX">
            <summary>
SHX: A Serpent cipher extended with an HKDF powered Key Schedule.
<para>SHX is a Serpent implementation that uses an HKDF generator to expand the user supplied key into a working key integer array.</para></summary>
            <example>
                <description>Example using an <c>ICipherMode</c> interface:</description>
                <code>
CTR cipher(new SHX());
// initialize for encryption
cipher.Initialize(true, KeyParams(Key, IV));
// encrypt a block
cipher.Transform(Input, Output);
</code>
            </example>
            <seealso cref="T:CEX.Enumeration.BlockCiphers" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <seealso cref="T:CEX.Digest.IDigest" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>HKDF Digest engine is definable through the SHX(uint, Digests) Constructor parameter: KeyEngine.</description>
                    </item>
                    <item>
                        <description>Key Schedule is powered by a Hash based Key Derivation Function using a definable Digest.</description>
                    </item>
                    <item>
                        <description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description>
                    </item>
                    <item>
                        <description>Valid block size is 16 bytes wide.</description>
                    </item>
                    <item>
                        <description>Valid Rounds assignments are 32, 40, 48, 56, 64, 80, 96 and 128, default is 64.</description>
                    </item>
                </list>
                <para>It also takes a user defined number of rounds between 32 (the standard number of rounds), all the way up to 128 rounds in 8 round sets. 
A round count of 40 or 48 is more than sufficient, as theoretical attacks to date are only able to break up to 12 rounds; and would require an enormous amount of memory and processing power.
The transform in SHX is identical to the Serpent implementation SPX, it process rounds by first moving the byte input array into 4 integers, then processing the rounds in a while loop. 
Each round consists of an XOR of each state word (<c>Rn</c>) with a key, an S-Box transformation of those words, and then a linear transformation. 
Each of the 8 S-Boxes are used in succession within a loop cycle. The final round XORs the last 4 keys with the state and shifts them back into the output byte array.</para>
                <para>The key schedule in SHX powered by an HKDF bytes generator, using a Digest HMAC (Hash based Message Authentication Code) as its random engine. 
This is one of the strongest: methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
                <para>When using SHA-2 512, a minimum key size for SHX is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para>
                <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake, Keccak, SHA-2, or Skein.
The default Digest Engine is SHA-2 512.</para>
                <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <c>klen = h + (n * s)</c>, this will vary between Digest implementations. 
Correct key sizes can be determined at runtime using the <see cref="M:CEX.Cipher.Symmetric.Block.SHX.LegalKeySizes" /> property.</para>
                <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
SHX is capable of processing up to 128 rounds, that is four times the number of rounds used in a standard implementation of Serpent. 
Valid rounds assignments can be found in the <see cref="M:CEX.Cipher.Symmetric.Block.SHX.LegalRounds" /> static property.</para>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>Serpent: <a href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</a>.</description>
                    </item>
                    <item>
                        <description>HMAC <a href="http://tools.ietf.org/html/rfc2104">RFC 2104</a>.</description>
                    </item>
                    <item>
                        <description>Fips <a href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</a>.</description>
                    </item>
                    <item>
                        <description>HKDF <a href="http://tools.ietf.org/html/rfc5869">RFC 5869</a>.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="https://131002.net/blake/blake.pdf">The Blake digest</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="http://keccak.noekeon.org/Keccak-submission-3.pdf">The Keccak digest</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">The Skein digest</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Transform a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.RHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Transform a block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.
Input and Output array lengths must be at least <see cref="M:CEX.Cipher.Symmetric.Block.RHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform or Decrypt</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher.
</summary>
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="M:CEX.Cipher.Symmetric.Block.RHX.LegalKeySizes" /> property contains valid sizes.</para></param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>true</c> before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.RHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt a block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>true</c> before this method can be used.
Input and Output array lengths must be at least <see cref="M:CEX.Cipher.Symmetric.Block.RHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.Destroy">
            <summary>
Clear the buffers and reset
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Decrypt a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>false</c> before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.RHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Decrypt a single block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>false</c> before this method can be used.
Input and Output arrays must be at least <see cref="M:CEX.Cipher.Symmetric.Block.RHX.BlockSize" /> in length.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.#ctor(System.UInt32,System.UInt32,&lt;unknown type&gt;)">
            <summary>
Initialize the class
</summary>
            <param name="Rounds">Number of diffusion rounds. The <see cref="M:CEX.Cipher.Symmetric.Block.RHX.LegalRounds" /> property contains available sizes.  Default is 22 rounds.</param>
            <param name="BlockSize">Cipher input Block Size. Default is 16 bytes.</param>
            <param name="KdfEngineType">
                <para>The Key Schedule KDF digest engine; can be any one of the Digest implementations. The default engine is SHA512</para>.</param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid block size or invalid rounds count are used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.#ctor(CEX.Digest.IDigest*,System.UInt32,System.UInt32)">
            <summary>
Initialize the class with a Digest instance
</summary>
            <param name="KdfEngine">The Key Schedule KDF digest engine; can be any one of the Digest implementations.</param>
            <param name="Rounds">Number of diffusion rounds. The <see cref="M:CEX.Cipher.Symmetric.Block.RHX.LegalRounds" /> property contains available sizes.  Default is 22 rounds.</param>
            <param name="BlockSize">Cipher input Block Size. Default is 16 bytes.</param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid block size or invalid rounds count are used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.Rounds">
            <summary>
Get: The number of diffusion rounds processed by the transform
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.LegalRounds">
            <summary>
Get: Available diffusion round assignments
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.IsEncryption">
            <summary>
Get: Initialized for encryption, false for decryption.
<para>Value set in <see cref="M:CEX.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" />.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.IkmSize">
            <summary>
Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
<para>This property can only be changed before the Initialize function is called.</para><para>Default is the digest return size; can only be a multiple of that length.
Maximum size is the digests underlying block size; if the key
is longer than this, the size will default to the block size.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.Enumeral">
            <summary>
Get: The block ciphers type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.DistributionCode">
            <summary>
Get/Set: Sets the Info value in the HKDF initialization parameters.
<para>Must be set before <see cref="M:CEX.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> is called.
Changing this code will create a unique distribution of the cipher.
Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para></summary>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.RHX.BlockSize">
            <summary>
Get: Unit block size of internal cipher in bytes.
<para>Block size must be 16 or 32 bytes wide.
Value set in class constructor.</para></summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.RHX">
            <summary>
RHX: A Rijndael Cipher extended with an (optional) HKDF powered Key Schedule.
<para>RHX is a Rijndael implementation that uses a standard configuration on key sizes up to 64 bytes (512 bits). 
On keys larger than 64 bytes, an HKDF bytes generator is used to expand the user supplied key into a working key integer array.</para></summary>
            <example>
                <description>Example using an <c>ICipherMode</c> interface:</description>
                <code>
CTR cipher(new RHX());
// initialize for encryption
cipher.Initialize(true, KeyParams(Key, IV));
// encrypt a block
cipher.Transform(Input, Output);
</code>
            </example>
            <seealso cref="T:CEX.Enumeration.BlockCiphers" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <seealso cref="T:CEX.Digest.IDigest" />
            <remarks>
                <description>Implementation Notes:</description>
                <para>The key schedule in RHX is the defining difference between this and a standard version of Rijndael.
if the cipher key input is beyond the standard lengths used in Rijndael (128-512 bits), instead of using an inline function to expand the user supplied key into a larger working array, 
RHX uses a hash based pseudo-random generator to create the internal working key array.
When using a non-standard key size, the number of diffusion rounds can be set by the user (through the class constructor). RHX can run between 10 and 38 rounds.
</para>
                <list type="bullet">
                    <item>
                        <description>When using a standard cipher key length the rounds calculation is done automatically: 10, 12, 14, and 22, for key sizes 126, 192, 256, and 512 bits.</description>
                    </item>
                    <item>
                        <description>HKDF Digest engine is definable through the RHX(uint, uint, Digests) Constructor parameter: KeyEngine.</description>
                    </item>
                    <item>
                        <description>Key Schedule is powered by a Hash based Key Derivation Function using a user definable Digest.</description>
                    </item>
                    <item>
                        <description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description>
                    </item>
                    <item>
                        <description>Valid block sizes are 16 and 32 byte wide.</description>
                    </item>
                    <item>
                        <description>Valid Rounds are 10 to 38, default is 22.</description>
                    </item>
                </list>
                <description>HKDF Bytes Generator:</description>
                <para>HKDF: is a key derivation function that uses a Digest HMAC (Hash based Message Authentication Code) as its random engine. 
This is one of the strongest methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
                <para>When using SHA-2 512, a minimum key size for RHX is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in post-quantum terms.</para>
                <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake, Keccak, SHA-2 or Skein.
The default Digest Engine is SHA-2 512.</para>
                <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <c>klen = h + (n * s)</c>, this will vary between Digest implementations. 
Correct key sizes can be determined at runtime using the <see cref="M:CEX.Cipher.Symmetric.Block.RHX.LegalKeySizes" /> property.</para>
                <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
RHX is capable of processing up to 38 rounds, that is twenty-four rounds more than the fourteen rounds used in an implementation of AES-256. 
Valid rounds assignments can be found in the <see cref="M:CEX.Cipher.Symmetric.Block.RHX.LegalRounds" /> static property.</para>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</a>.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">Rijndael ammended</a>.</description>
                    </item>
                    <item>
                        <description>HMAC <a href="http://tools.ietf.org/html/rfc2104">RFC 2104</a>.</description>
                    </item>
                    <item>
                        <description>Fips <a href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</a>.</description>
                    </item>
                    <item>
                        <description>HKDF <a href="http://tools.ietf.org/html/rfc5869">RFC 5869</a>.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="https://131002.net/blake/blake.pdf">The Blake digest</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="http://keccak.noekeon.org/Keccak-submission-3.pdf">The Keccak digest</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">The Skein digest</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Helper.BlockCipherFromName.GetInstance(&lt;unknown type&gt;,System.Int32,System.Int32,&lt;unknown type&gt;)">
            <summary>
Get a block cipher instance with specified initialization parameters
</summary>
            <param name="EngineType">The block cipher enumeration name</param>
            <param name="BlockSize">The cipher block size</param>
            <param name="RoundCount">The number of cipher rounds</param>
            <param name="KdfEngine">The ciphers key expansion engine (HX ciphers)</param>
            <returns>An initialized block cipher</returns>
            <exception cref="T:CEX.Exception.CryptoException">Thrown if the enumeration name is not supported</exception>
        </member>
        <member name="M:CEX.Helper.BlockCipherFromName.GetInstance(&lt;unknown type&gt;)">
            <summary>
Get a block cipher instance with default initialization parameters
</summary>
            <param name="EngineType">The block cipher enumeration name</param>
            <returns>An initialized block cipher</returns>
            <exception cref="T:CEX.Exception.CryptoException">Thrown if the enumeration name is not supported</exception>
        </member>
        <member name="T:CEX.Helper.BlockCipherFromName">
            <summary>
BlockCipherFromName: Get a Block Cipher instance from it's enumeration name.
</summary>
        </member>
        <member name="M:CEX.Prng.CSPPrng.Reset">
            <summary>
Reset the generator instance
</summary>
        </member>
        <member name="M:CEX.Prng.CSPPrng.NextLong(System.UInt64,System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random 64bit integer</returns>
        </member>
        <member name="M:CEX.Prng.CSPPrng.NextLong(System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random 64bit integer</returns>
        </member>
        <member name="M:CEX.Prng.CSPPrng.NextLong">
            <summary>
Get a pseudo random unsigned 64bit integer
</summary>
            <returns>Random 64bit integer</returns>
        </member>
        <member name="M:CEX.Prng.CSPPrng.Next(System.UInt32,System.UInt32)">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random 32bit integer</returns>
        </member>
        <member name="M:CEX.Prng.CSPPrng.Next(System.UInt32)">
            <summary>
Get an pseudo random unsigned 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random 32bit integer</returns>
        </member>
        <member name="M:CEX.Prng.CSPPrng.Next">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <returns>Random 32bit integer</returns>
        </member>
        <member name="M:CEX.Prng.CSPPrng.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
        </member>
        <member name="M:CEX.Prng.CSPPrng.GetBytes(System.UInt32)">
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
        </member>
        <member name="M:CEX.Prng.CSPPrng.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Prng.CSPPrng.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Prng.CSPPrng.#ctor">
            <summary>
Initialize this class
</summary>
        </member>
        <member name="M:CEX.Prng.CSPPrng.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Prng.CSPPrng.Enumeral">
            <summary>
Get: The prngs type name
</summary>
        </member>
        <member name="T:CEX.Prng.CSPPrng">
            <summary>
An implementation of a Cryptographically Secure PRNG using the the operating system random provider
</summary>
            <example>
                <description>Example of generating a pseudo random integer:</description>
                <code>
CSPPrng rnd();
int x = rnd.Next();
</code>
            </example>
            <remarks>
                <description>Guiding Publications::</description>
                <list type="number">
                    <item>
                        <description>Microsoft <a href="http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider.aspx">RNGCryptoServiceProvider</a>: class documentation.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>: Recommendation for the Entropy Sources Used for Random Bit Generation.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Fips 140-2</a>: Security Requirments For Cryptographic Modules.</description>
                    </item>
                    <item>
                        <description>RFC <a href="http://www.ietf.org/rfc/rfc4086.txt">4086</a>: Randomness Requirements for Security.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Seed.CSPRsg.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Seed.CSPRsg.Next">
            <summary>
Returns the next pseudo random 32bit integer
</summary>
        </member>
        <member name="M:CEX.Seed.CSPRsg.GetBytes(System.Int32)">
            <summary>
Get a pseudo random seed byte array
</summary>
            <param name="Size">The size of the expected seed returned</param>
            <returns>A pseudo random seed</returns>
        </member>
        <member name="M:CEX.Seed.CSPRsg.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill the buffer with random bytes
</summary>
            <param name="Output">The array to fill</param>
        </member>
        <member name="M:CEX.Seed.CSPRsg.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Seed.CSPRsg.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Seed.CSPRsg.#ctor">
            <summary>
Initialize this class
</summary>
        </member>
        <member name="M:CEX.Seed.CSPRsg.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Seed.CSPRsg.Enumeral">
            <summary>
Get: The seed generators type name
</summary>
        </member>
        <member name="T:CEX.Seed.CSPRsg">
            <summary>
CSPRsg: An implementation of a Cryptographically Secure seed generator using the RNGCryptoServiceProvider class
</summary>
            <example>
                <description>Example of getting a seed value:</description>
                <code>
CSPRsg gen;
gen.GetSeed(Output);
</code>
            </example>
            <remarks>
                <description>Guiding Publications::</description>
                <list type="number">
                    <item>
                        <description>Microsoft <a href="http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider.aspx">RNGCryptoServiceProvider</a>: class documentation.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>: Recommendation for the Entropy Sources Used for Random Bit Generation.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Fips 140-2</a>: Security Requirments For Cryptographic Modules.</description>
                    </item>
                    <item>
                        <description>RFC <a href="http://www.ietf.org/rfc/rfc4086.txt">4086</a>: Randomness Requirements for Security.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Seed.ISeed.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Seed.ISeed.Next">
            <summary>
Returns the next pseudo random 32bit integer
</summary>
        </member>
        <member name="M:CEX.Seed.ISeed.GetBytes(System.Int32)">
            <summary>
Get a pseudo random seed byte array
</summary>
            <param name="Size">The size of the expected seed returned</param>
            <returns>A pseudo random seed</returns>
        </member>
        <member name="M:CEX.Seed.ISeed.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the pseudo random bytes
</summary>
            <param name="Output">Output array</param>
        </member>
        <member name="M:CEX.Seed.ISeed.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Seed.ISeed.Name">
            <summary>
Get: Algorithm name
</summary>
        </member>
        <member name="M:CEX.Seed.ISeed.Enumeral">
            <summary>
Get: The seed generators type name
</summary>
        </member>
        <member name="M:CEX.Seed.ISeed.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Seed.ISeed.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Seed.ISeed">
            <summary>
ISeed: Pseudo random seed generator interface
</summary>
        </member>
        <member name="T:CEX.Enumeration.SeedGenerators">
            <summary>
Seed Generators
</summary>
        </member>
        <member name="F:XSPRsg">
            <summary>
A (fast but less secure) Seed Generator using the entropy pool and an XorShift+ generator
</summary>
        </member>
        <member name="F:ISCRsg">
            <summary>
A Secure Seed Generator using the entropy pool and an ISAAC generator
</summary>
        </member>
        <member name="F:CSPRsg">
            <summary>
A Secure Seed Generator using RNGCryptoServiceProvider
</summary>
        </member>
        <member name="M:CEX.Prng.IRandom.Reset">
            <summary>
Reset the generator instance
</summary>
        </member>
        <member name="M:CEX.Prng.IRandom.NextLong(System.UInt64,System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.IRandom.NextLong(System.UInt64)">
            <summary>
Get a ranged pseudo random unsigned 64bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.IRandom.NextLong">
            <summary>
Get a pseudo random unsigned 64bit integer
</summary>
            <returns>Random UInt64</returns>
        </member>
        <member name="M:CEX.Prng.IRandom.Next(System.UInt32,System.UInt32)">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.IRandom.Next(System.UInt32)">
            <summary>
Get an pseudo random unsigned 32bit integer
</summary>
            <param name="Maximum">Maximum value</param>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.IRandom.Next">
            <summary>
Get a pseudo random unsigned 32bit integer
</summary>
            <returns>Random UInt32</returns>
        </member>
        <member name="M:CEX.Prng.IRandom.GetBytes(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fill an array with pseudo random bytes
</summary>
            <param name="Output">Output array</param>
        </member>
        <member name="M:CEX.Prng.IRandom.GetBytes(System.UInt32)">
            <summary>
Return an array filled with pseudo random bytes
</summary>
            <param name="Size">Size of requested byte array</param>
            <returns>Random byte array</returns>
        </member>
        <member name="M:CEX.Prng.IRandom.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Prng.IRandom.Name">
            <summary>
Get: Algorithm name
</summary>
        </member>
        <member name="M:CEX.Prng.IRandom.Enumeral">
            <summary>
Get: The prngs type name
</summary>
        </member>
        <member name="M:CEX.Prng.IRandom.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Prng.IRandom.#ctor">
            <summary>
Initialize this class
</summary>
        </member>
        <member name="T:CEX.Prng.IRandom">
            <summary>
Psuedo Random Number Generator interface
</summary>
        </member>
        <member name="T:CEX.Enumeration.Prngs">
            <summary>
Pseudo Random Generators
</summary>
        </member>
        <member name="F:SP20Prng">
            <summary>
An implementation of a Salsa20 Counter based Prng
</summary>
        </member>
        <member name="F:PPBPrng">
            <summary>
An implementation of a passphrase based PKCS#5 random number generator
</summary>
        </member>
        <member name="F:DGCPrng">
            <summary>
A Digest Counter mode random number generator
</summary>
        </member>
        <member name="F:CTRPrng">
            <summary>
A Symmetric Cipher Counter mode random number generator
</summary>
        </member>
        <member name="F:CSPPrng">
            <summary>
 A Secure PRNG using RNGCryptoServiceProvider
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoRandomException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoRandomException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoRandomException.Origin">
            <summary>
Get/Set: The origin of the exception in the format Class
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoRandomException.Message">
            <summary>
Get/Set: The message associated with the error
</summary>
        </member>
        <member name="T:CEX.Exception.CryptoRandomException">
            <summary>
Wraps exceptions thrown within Pseudo Random Number Generator operations
</summary>
        </member>
        <member name="M:CEX.Digest.Blake512.Update(System.Byte)">
            <summary>
Update the message digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Digest.Blake512.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Digest.Blake512.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Do final processing and get the hash value
</summary>
            <param name="Output">The Hash output value array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <returns>Size of Hash value</returns>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the output buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Blake512.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Digest.Blake512.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The hash output value array</param>
        </member>
        <member name="M:CEX.Digest.Blake512.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the input buffer is too short</exception>
        </member>
        <member name="M:CEX.Digest.Blake512.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Digest.Blake512.#ctor(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;)">
            <summary>
Initialize the class with a salt value
</summary>
            <param name="Salt">The optional salt value; must be 4 unsigned longs in length</param>
            <exception cref="T:CEX.Exception.CryptoDigestException">Thrown if the salt length is invalid</exception>
        </member>
        <member name="M:CEX.Digest.Blake512.#ctor">
            <summary>
Initialize the digest
</summary>
        </member>
        <member name="M:CEX.Digest.Blake512.Name">
            <summary>
Get: Digest name
</summary>
        </member>
        <member name="M:CEX.Digest.Blake512.Enumeral">
            <summary>
Get: The digests type enumeration member
</summary>
        </member>
        <member name="M:CEX.Digest.Blake512.DigestSize">
            <summary>
Get: Size of returned digest in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.Blake512.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Digest.Blake512">
            <summary>
Blake512: An implementation of the Blake digest with a 512 bit return size
</summary>
            <example>
                <description>Example using the ComputeHash method:</description>
                <code>
Blake512 digest;
std:vector&lt;byte&gt; hash(digest.DigestSize(), 0);
// compute a hash
digest.ComputeHash(Input, hash);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Block size is 64 bytes, (512 bits).</description>
                    </item>
                    <item>
                        <description>Digest size is 64 bytes, (512 bits).</description>
                    </item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Blake512.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> method wraps the <see cref="M:CEX.Digest.Blake512.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)" /> and DoFinal methods</description>/&gt;</item>
                    <item>
                        <description>The <see cref="M:CEX.Digest.Blake512.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)" /> method resets the internal state.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="https://131002.net/blake">SHA3 Proposal Blake</a>.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">SHA3: Third-Round Report</a> of the SHA-3 Cryptographic Hash Algorithm Competition.</description>
                    </item>
                    <item>
                        <description>SHA3 Submission in C: <a href="https://131002.net/blake/blake_ref.c">blake_ref.c</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Helper.DigestFromName.GetInstance(&lt;unknown type&gt;)">
            <summary>
Get a Digest instance by name
</summary>
            <param name="DigestType">The message digest enumeration name</param>
            <returns>An initialized digest</returns>
            <exception cref="T:CEX.Exception.CryptoException">Thrown if the enumeration name is not supported</exception>
        </member>
        <member name="T:CEX.Helper.DigestFromName">
            <summary>
DigestFromName: Get a Message Digest instance from it's enumeration name.
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoException.Origin">
            <summary>
Get/Set: The origin of the exception in the format Class
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoException.Message">
            <summary>
Get/Set: The message associated with the error
</summary>
        </member>
        <member name="T:CEX.Exception.CryptoException">
            <summary>
Generalized cryptographic error container
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Transform a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.THX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Transform a block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.
Input and Output array lengths must be at least <see cref="M:CEX.Cipher.Symmetric.Block.THX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform or Decrypt</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher.
</summary>
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="M:CEX.Cipher.Symmetric.Block.THX.LegalKeySizes" /> property contains valid sizes.</para></param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>true</c> before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.THX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt a block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>true</c> before this method can be used.
Input and Output array lengths must be at least <see cref="M:CEX.Cipher.Symmetric.Block.THX.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.Destroy">
            <summary>
Clear the buffers and reset
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Decrypt a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>false</c> before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.THX.BlockSize" /> in length.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Decrypt a single block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>false</c> before this method can be used.
Input and Output arrays must be at least <see cref="M:CEX.Cipher.Symmetric.Block.THX.BlockSize" /> in length.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.#ctor(System.UInt32,&lt;unknown type&gt;)">
            <summary>
Initialize the class
</summary>
            <param name="Rounds">Number of diffusion rounds. The <see cref="M:CEX.Cipher.Symmetric.Block.THX.LegalRounds" /> property contains available sizes. Default is 16 rounds.</param>
            <param name="KdfEngineType">The Key Schedule KDF digest engine; can be any one of the Digest implementations. The default engine is SHA512.</param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.#ctor(CEX.Digest.IDigest*,System.UInt32)">
            <summary>
Initialize the class with a Digest instance
</summary>
            <param name="KdfEngine">The Key Schedule KDF digest engine; can be any one of the Digest implementations.</param>
            <param name="Rounds">Number of diffusion rounds. The <see cref="M:CEX.Cipher.Symmetric.Block.THX.LegalRounds" /> property contains available sizes. Default is 16 rounds.</param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.Rounds">
            <summary>
Get: The number of diffusion rounds processed by the transform
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.LegalRounds">
            <summary>
Get: Available diffusion round assignments
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.IsEncryption">
            <summary>
Get: Initialized for encryption, false for decryption.
<para>Value set in <see cref="M:CEX.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" />.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.IkmSize">
            <summary>
Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
<para>This property can only be changed before the Initialize function is called.</para><para>Default is the digest return size; can only be a multiple of that length.
Maximum size is the digests underlying block size; if the key
is longer than this, the size will default to the block size.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.Enumeral">
            <summary>
Get: The block ciphers type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.DistributionCode">
            <summary>
Get/Set: Sets the Info value in the HKDF initialization parameters.
<para>Must be set before <see cref="M:CEX.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> is called.
Changing this code will create a unique distribution of the cipher.
Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para></summary>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.THX.BlockSize">
            <summary>
Get: Unit block size of internal cipher in bytes.
<para>Block size must be 16 or 32 bytes wide.
Value set in class constructor.</para></summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.THX">
            <summary>
THX: A Twofish Cipher extended with an (optional) HKDF powered Key Schedule.
<para>THX is a Twofish implementation that can use a standard configuration on key sizes up to 256 bits, 
an extended key size of 512 bits, or unlimited key sizes greater than 64 bytes. 
On <see cref="M:CEX.Cipher.Symmetric.Block.THX.LegalKeySizes" /> larger than 64 bytes, an HKDF bytes generator is used to expand the <c>working key</c> integer array.
In extended mode, the number of <c>transformation rounds</c> can be user assigned (through the constructor) to between 16 and 32 rounds.</para></summary>
            <example>
                <description>Example using an <c>ICipherMode</c> interface:</description>
                <code>
CTR cipher(new THX());
// initialize for encryption
cipher.Initialize(true, KeyParams(Key, IV));
// encrypt a block
cipher.Transform(Input, Output);
</code>
            </example>
            <seealso cref="T:CEX.Enumeration.BlockCiphers" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <seealso cref="T:CEX.Digest.IDigest" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>HKDF Digest engine is definable through the <see cref="M:CEX.Cipher.Symmetric.Block.THX.#ctor(System.UInt32,&lt;unknown type&gt;)">Constructor</see> parameter: KeyEngine.</description>
                    </item>
                    <item>
                        <description>Key Schedule is (optionally) powered by a Hash based Key Derivation Function using a definable Digest.</description>
                    </item>
                    <item>
                        <description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description>
                    </item>
                    <item>
                        <description>Valid block size is 16 bytes wide.</description>
                    </item>
                    <item>
                        <description>Valid Rounds assignments are set at 16 in standard mode, and 32, 40, 48, 56, and 64 in extended mode.</description>
                    </item>
                    <item>
                        <description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description>
                    </item>
                </list>
                <description>HKDF Bytes Generator:</description>
                <para>HKDF: is a key derivation function that uses a Digest HMAC (Hash based Message Authentication Code) as its random engine. 
This is one of the strongest methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
                <para>When using SHA-2 512, a minimum key size for RHX is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in post-quantum terms.</para>
                <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake, Keccak, SHA-2 or Skein.
The default Digest Engine is SHA-2 512.</para>
                <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <c>klen = h + (n * s)</c>, this will vary between Digest implementations. 
Correct key sizes can be determined at runtime using the <see cref="M:CEX.Cipher.Symmetric.Block.THX.LegalKeySizes" /> property.</para>
                <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
RHX is capable of processing up to 38 rounds, that is twenty-four rounds more than the fourteen rounds used in an implementation of AES-256. 
Valid rounds assignments can be found in the <see cref="M:CEX.Cipher.Symmetric.Block.THX.LegalRounds" /> static property.</para>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</a>.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">Rijndael ammended</a>.</description>
                    </item>
                    <item>
                        <description>HMAC <a href="http://tools.ietf.org/html/rfc2104">RFC 2104</a>.</description>
                    </item>
                    <item>
                        <description>Fips <a href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</a>.</description>
                    </item>
                    <item>
                        <description>HKDF <a href="http://tools.ietf.org/html/rfc5869">RFC 5869</a>.</description>
                    </item>
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="https://131002.net/blake/blake.pdf">The Blake digest</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="http://keccak.noekeon.org/Keccak-submission-3.pdf">The Keccak digest</a>.</description>
                    </item>
                    <item>
                        <description>SHA3 <a href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">The Skein digest</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Utility.ParallelUtils.ParallelFor(System.Int32,System.Int32,std.function&lt;(System.Int32)(System.Int32)&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
A multi platform Parallel For loop
</summary>
            <param name="From">The starting position</param>
            <param name="To">The ending position</param>
            <param name="F">The function delegate</param>
        </member>
        <member name="M:CEX.Utility.ParallelUtils.ProcessorCount">
            <summary>
Get The number of processors available on the system
</summary>
        </member>
        <member name="T:CEX.Utility.ParallelUtils">
            <summary>
Parallel functions class
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Transform a block of bytes with offset parameters. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Transform a block of bytes. 
<para>Initialize(bool, KeyParams) must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Encryption">True if cipher is used for encryption, false to decrypt</param>
            <param name="KeyParam">KeyParams containing key and vector</param>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.#ctor(CEX.Cipher.Symmetric.Block.IBlockCipher*,System.UInt32)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="BlockSizeBits">Block size in bits; minimum is 8, or 1 byte. Maximum is Cipher block size in bits</param>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a null Cipher or valid block size is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.ParallelBlockSize">
            <summary>
Get/Set: Parallel block size. Must be a multiple of <see cref="M:CEX.Cipher.Symmetric.Block.Mode.OFB.ParallelMinimumSize" />.
<para>The parallel block size is calculated automatically based on the number of available processors on the system (n * 64kb).</para></summary>
            <exception cref="T:CEX.Exception.CryptoCipherModeException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, 
or block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.LegalKeySizes">
            <summary>
Get: Available Encryption Key Sizes in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.IV">
            <summary>
Get: The current state of the initialization Vector
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.IsParallel">
            <summary>
Get/Set: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.IsEncryption">
            <summary>
Get: Initialized for encryption, false for decryption
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.Enumeral">
            <summary>
Get: The cipher modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.Engine">
            <summary>
Get: Underlying Cipher
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.OFB.BlockSize">
            <summary>
Get: Unit block size of internal cipher
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Mode.OFB">
            <summary>
Implements a Cipher FeedBack Mode: OFB
</summary>
            <example>
                <description>Example using an <c>ICipherMode</c> interface:</description>
                <code>
OFB cipher(new RDX());
// initialize for encryption
cipher.Initialize(true, KeyParams(Key, IV));
// encrypt a block
cipher.Transform(Input, Output);
</code>
            </example>
            <seealso cref="N:CEX.Cipher.Symmetric.Block" />
            <seealso cref="T:CEX.Enumeration.BlockCiphers" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>OFB is not a parallel capable cipher mode.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>NIST <a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Transform a block of bytes with offset parameters.  
<para>Parallel capable function if Output array length is at least equal to <see cref="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.ParallelMinimumSize" />.
Initialize() must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Transform a block of bytes. 
<para>Parallel capable function if Output array length is at least equal to <see cref="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.ParallelMinimumSize" />.
Initialize() must be called before this method can be used.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Encryption">True if cipher is used for encryption, false to decrypt</param>
            <param name="KeyParam">The KeyParams containing key and vector</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.ProcessorCount">
            <remarks>
Get: Processor count
</remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.ParallelMinimumSize">
            <summary>
Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.ParallelMaximumSize">
            <summary>
Get: Maximum input size with parallel processing
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.ParallelBlockSize">
            <summary>
Get: Parallel block size. Must be a multiple of <see cref="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.ParallelMinimumSize" />.
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.LegalKeySizes">
            <summary>
Get: List of available legal key sizes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.IV">
            <summary>
Get: The current state of the initialization Vector
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.IsParallel">
            <summary>
Get: Automatic processor parallelization
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.IsEncryption">
            <summary>
Get: Initialized for encryption, false for decryption
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.Enumeral">
            <summary>
Get: The cipher modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.Engine">
            <summary>
Get: Underlying Cipher
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.BlockSize">
            <summary>
Get: Unit block size of internal cipher
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Mode.ICipherMode.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Mode.ICipherMode">
            <summary>
Cipher Mode Interface
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Transform a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Transform(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Transform a block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called before this method can be used.
Input and Output array lengths must be at least <see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform or Decrypt</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the Cipher
</summary>
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.LegalKeySizes" /> property contains valid sizes.</para></param>
            <exception cref="T:CEX.Exception.CryptoSymmetricCipherException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Encrypt a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>true</c> before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Output product of Transform</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.EncryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Encrypt a block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>true</c> before this method can be used.
Input and Output array lengths must be at least <see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.BlockSize" /> in length.</para></summary>
            <param name="Input">Input bytes to Transform</param>
            <param name="Output">Output product of Transform</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Decrypt a block of bytes with offset parameters.
<para><see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>false</c> before this method can be used.
Input and Output arrays with Offsets must be at least <see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.BlockSize" /> in length.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.DecryptBlock(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Decrypt a single block of bytes.
<para><see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> must be called with the Encryption flag set to <c>false</c> before this method can be used.
Input and Output arrays must be at least <see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.BlockSize" /> in length.</para></summary>
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Rounds">
            <summary>
Get: The number of diffusion rounds processed by the transform
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.LegalRounds">
            <summary>
Get: Available diffusion round assignments
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.LegalKeySizes">
            <summary>
Get: List of available legal key sizes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.IsInitialized">
            <summary>
Get: Cipher is ready to transform data
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.IsEncryption">
            <summary>
Get: True is initialized for encryption, false for decryption.
<para>Value set in <see cref="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,CEX.Common.KeyParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" />.</para></summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Enumeral">
            <summary>
Get: The block ciphers type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.BlockSize">
            <summary>
Get: Unit block size of internal cipher in bytes
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.IBlockCipher.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.IBlockCipher">
            <summary>
Block Cipher Interface
</summary>
        </member>
        <member name="M:CEX.Common.KeyParams.Serialize(CEX.Common.KeyParams*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Serialize a KeyParams class
</summary>
            <param name="KeyObj">A KeyParams class</param>
            <returns>A stream containing the KeyParams data</returns>
        </member>
        <member name="M:CEX.Common.KeyParams.DeSerialize(CEX.IO.MemoryStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Deserialize a KeyParams class
</summary>
            <param name="KeyStream">Stream containing the KeyParams data</param>
            <returns>A populated KeyParams class</returns>
        </member>
        <member name="M:CEX.Common.KeyParams.Equals(CEX.Common.KeyParams*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Compare this KeyParams instance with another
</summary>
            <param name="Obj">KeyParams to compare</param>
            <returns>Returns true if equal</returns>
        </member>
        <member name="M:CEX.Common.KeyParams.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Common.KeyParams.DeepCopy">
            <summary>
Create a deep copy of this KeyParams class
</summary>
        </member>
        <member name="M:CEX.Common.KeyParams.Clone">
            <summary>
Create a shallow copy of this KeyParams class
</summary>
        </member>
        <member name="M:CEX.Common.KeyParams.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Common.KeyParams.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize this class with a Cipher Key, IV, and IKM
</summary>
            <param name="Key">Cipher Key</param>
            <param name="IV">Cipher IV</param>
            <param name="Ikm">Input Key Material</param>
        </member>
        <member name="M:CEX.Common.KeyParams.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize this class with a Cipher Key, and IV
</summary>
            <param name="Key">Cipher Key</param>
            <param name="IV">Cipher IV</param>
        </member>
        <member name="M:CEX.Common.KeyParams.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize this class with a Cipher Key
</summary>
            <param name="Key">Cipher Key</param>
        </member>
        <member name="M:CEX.Common.KeyParams.#ctor">
            <summary>
Initialize this class
</summary>
        </member>
        <member name="M:CEX.Common.KeyParams.Ikm">
            <summary>
Get: Input Keying Material
</summary>
            <summary>
Set: Input Keying Material
</summary>
        </member>
        <member name="M:CEX.Common.KeyParams.IV">
            <summary>
Get: Cipher Initialization Vector
</summary>
            <summary>
Set: Cipher Initialization Vector
</summary>
        </member>
        <member name="M:CEX.Common.KeyParams.Key">
            <summary>
Get: The cipher Key
</summary>
            <summary>
Set: The cipher Key
</summary>
        </member>
        <member name="T:CEX.Common.KeyParams">
            <summary>
KeyParams: A Symmetric Cipher Key and Vector Container class.
</summary>
        </member>
        <member name="M:CEX.IO.StreamReader.ReadWord64">
            <summary>
Reads an unsigned 64 bit integer from the stream
</summary>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if source array is too small</exception>
        </member>
        <member name="M:CEX.IO.StreamReader.ReadWord32">
            <summary>
Reads an unsigned 32 bit integer from the stream
</summary>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if source array is too small</exception>
        </member>
        <member name="M:CEX.IO.StreamReader.ReadUInt64">
            <summary>
Reads an unsigned 64 bit integer from the stream
</summary>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if source array is too small</exception>
        </member>
        <member name="M:CEX.IO.StreamReader.ReadInt64">
            <summary>
Reads a 64 bit integer from the stream
</summary>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if source array is too small</exception>
        </member>
        <member name="M:CEX.IO.StreamReader.ReadUInt32">
            <summary>
Reads an unsigned 32 bit integer from the stream
</summary>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if source array is too small</exception>
        </member>
        <member name="M:CEX.IO.StreamReader.ReadInt32">
            <summary>
Reads a 32 bit integer from the stream
</summary>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if source array is too small</exception>
        </member>
        <member name="M:CEX.IO.StreamReader.ReadUInt16">
            <summary>
Reads an unsigned 16 bit integer from the stream
</summary>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if source array is too small</exception>
        </member>
        <member name="M:CEX.IO.StreamReader.ReadInt16">
            <summary>
Reads a 16 bit integer from the stream
</summary>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if source array is too small</exception>
        </member>
        <member name="M:CEX.IO.StreamReader.ReadBytes(System.UInt32)">
            <summary>
Reads a portion of the stream into the buffer
</summary>
            <param name="Length">The number of bytes to read</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if source array is too small</exception>
        </member>
        <member name="M:CEX.IO.StreamReader.ReadByte">
            <summary>
Read a single byte from the stream
</summary>
            <returns>The byte value</returns>
        </member>
        <member name="M:CEX.IO.StreamReader.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.IO.StreamReader.#ctor(CEX.IO.MemoryStream!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize this class with a byte array
</summary>
            <param name="DataStream">MemoryStream to read</param>
        </member>
        <member name="M:CEX.IO.StreamReader.Position">
            <summary>
The current position within the data
</summary>
        </member>
        <member name="M:CEX.IO.StreamReader.Length">
            <summary>
The length of the data
</summary>
        </member>
        <member name="T:CEX.IO.StreamReader">
            <summary>
Methods for reading integer types from a binary stream
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.Write(System.UInt64)">
            <summary>
Write a 64bit unsigned integer to the base stream
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.Write(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Write a 64bit integer to the base stream
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.Write(System.UInt32)">
            <summary>
Write a 32bit unsigned integer to the base stream
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.Write(System.Int32)">
            <summary>
Write a 32bit integer to the base stream
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.Write(System.UInt16)">
            <summary>
Write a 16bit unsigned integer to the base stream
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.Write(System.Int16)">
            <summary>
Write a 16bit integer to the base stream
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.Write(System.Byte)">
            <summary>
Write an 8bit integer to the base stream
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.GetStream">
            <summary>
Returns the base MemoryStream object
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.GetBytes">
            <summary>
Returns the entire array of raw bytes from the stream
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.#ctor(CEX.IO.MemoryStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize this class with a MemoryStream
</summary>
            <param name="DataStream">The MemoryStream to write data to</param>
        </member>
        <member name="M:CEX.IO.StreamWriter.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize this class with a byte array
</summary>
            <param name="DataArray">The byte array to write data to</param>
        </member>
        <member name="M:CEX.IO.StreamWriter.#ctor(System.UInt32)">
            <summary>
Initialize this class
</summary>
            <param name="Length">The length of the underlying stream</param>
        </member>
        <member name="M:CEX.IO.StreamWriter.Position">
            <summary>
The current position within the data
</summary>
        </member>
        <member name="M:CEX.IO.StreamWriter.Length">
            <summary>
The length of the data
</summary>
        </member>
        <member name="T:CEX.IO.StreamWriter">
            <summary>
Write integer values to a byte array
</summary>
        </member>
        <member name="M:CEX.IO.MemoryStream.WriteByte(System.Byte)">
            <summary>
Write a single byte from the stream
</summary>
            <returns>The byte value</returns>
        </member>
        <member name="M:CEX.IO.MemoryStream.Write(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Writes a buffer into the stream
</summary>
            <param name="Buffer">The output buffer to write to the stream</param>
            <param name="Offset">Offset within the output buffer at which to begin</param>
            <param name="Count">The number of bytes to write</param>
            <returns>The number of bytes processed</returns>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:CEX.IO.MemoryStream.SetLength(System.UInt32)">
            <summary>
Set the length of the stream
</summary>
            <param name="Length">The desired length</param>
        </member>
        <member name="M:CEX.IO.MemoryStream.Seek(System.UInt32,&lt;unknown type&gt;)">
            <summary>
Seek to a position within the stream
</summary>
            <param name="Offset">The offset position</param>
            <param name="Origin">The starting point</param>
        </member>
        <member name="M:CEX.IO.MemoryStream.Reset">
            <summary>
Reset and initialize the underlying stream to zero
</summary>
        </member>
        <member name="M:CEX.IO.MemoryStream.ReadByte">
            <summary>
Read a single byte from the stream
</summary>
            <returns>The byte value</returns>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if the output array is too short</exception>
        </member>
        <member name="M:CEX.IO.MemoryStream.Read(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Reads a portion of the stream into the buffer
</summary>
            <param name="Buffer">The output buffer receiving the bytes</param>
            <param name="Offset">Offset within the output buffer at which to begin</param>
            <param name="Count">The number of bytes to read</param>
            <returns>The number of bytes processed</returns>
        </member>
        <member name="M:CEX.IO.MemoryStream.Flush">
            <summary>
Write the stream to disk
</summary>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Not implemented exception</exception>
        </member>
        <member name="M:CEX.IO.MemoryStream.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.IO.MemoryStream.CopyTo(CEX.IO.IByteStream*)">
            <summary>
Copy this stream to another stream
</summary>
            <param name="Destination">The destination stream</param>
        </member>
        <member name="M:CEX.IO.MemoryStream.Close">
            <summary>
Close and flush the stream
</summary>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Not implemented exception</exception>
        </member>
        <member name="M:CEX.IO.MemoryStream.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.IO.MemoryStream.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Initialize this class (Copy constructor); copy a portion of a byte array to the streams content
</summary>
            <param name="DataArray">The array used to initialize the stream</param>
            <param name="Offset">The offset in the Data array at which to begin copying</param>
            <param name="Length">The number of bytes to copy</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if the offset or length values are invalid</exception>
        </member>
        <member name="M:CEX.IO.MemoryStream.#ctor(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize this class; setting a byte array as the streams content
</summary>
            <param name="DataArray">The array used to initialize the stream</param>
        </member>
        <member name="M:CEX.IO.MemoryStream.#ctor(System.UInt32)">
            <summary>
Initialize this class; setting the streams length
</summary>
            <param name="Length">The reserved length of the stream</param>
        </member>
        <member name="M:CEX.IO.MemoryStream.#ctor">
            <summary>
Initialize this class
</summary>
        </member>
        <member name="M:CEX.IO.MemoryStream.ToArray">
            <summary>
Get: The underlying stream
</summary>
        </member>
        <member name="M:CEX.IO.MemoryStream.Position">
            <summary>
Get: The streams current position
</summary>
        </member>
        <member name="M:CEX.IO.MemoryStream.Length">
            <summary>
Get: The stream length
</summary>
        </member>
        <member name="M:CEX.IO.MemoryStream.CanWrite">
            <summary>
Get: The stream can be written to
</summary>
        </member>
        <member name="M:CEX.IO.MemoryStream.CanSeek">
            <summary>
Get: The stream is seekable
</summary>
        </member>
        <member name="M:CEX.IO.MemoryStream.CanRead">
            <summary>
Get: The stream can be read
</summary>
        </member>
        <member name="T:CEX.IO.MemoryStream">
            <summary>
Write data to a byte array
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoSymmetricCipherException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoSymmetricCipherException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoSymmetricCipherException.Origin">
            <summary>
Get/Set: The origin of the exception in the format Class
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoSymmetricCipherException.Message">
            <summary>
Get/Set: The message associated with the error
</summary>
        </member>
        <member name="T:CEX.Exception.CryptoSymmetricCipherException">
            <summary>
Wraps exceptions thrown within a Symmetric cipher operational context
</summary>
        </member>
        <member name="T:CEX.Enumeration.BlockCiphers">
            <summary>
Block Ciphers
</summary>
        </member>
        <member name="F:THX">
            <summary>
A Twofish Block Cipher Extended with an HKDF Key Schedule
</summary>
            <summary>
A Twofish Block Cipher Extended with an HKDF Key Schedule
</summary>
        </member>
        <member name="F:SHX">
            <summary>
The Serpent Block Cipher Extended with an HKDF Key Schedule
</summary>
            <summary>
The Serpent Block Cipher Extended with an HKDF Key Schedule
</summary>
        </member>
        <member name="F:RHX">
            <summary>
An implementation based on the Rijndael Block Cipher, using HKDF with a SHA512 HMAC for expanded key generation
</summary>
            <summary>
An implementation based on the Rijndael Block Cipher, using HKDF with a SHA512 HMAC for expanded key generation
</summary>
        </member>
        <member name="T:CEX.Enumeration.CipherModes">
            <summary>
Cipher Modes
</summary>
        </member>
        <member name="F:OFB">
            <summary>
Output FeedBack Mode
</summary>
        </member>
        <member name="F:CTR">
            <summary>
SIC Counter Mode
</summary>
        </member>
        <member name="F:CFB">
            <summary>
Cipher FeedBack Mode
</summary>
        </member>
        <member name="F:CBC">
            <summary>
Cipher Block Chaining Mode
</summary>
        </member>
        <member name="F:ECB">
            <summary>
Electronic CodeBook Mode (not secure, testing only)
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoCipherModeException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoCipherModeException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoCipherModeException.Origin">
            <summary>
Get/Set: The origin of the exception in the format Class
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoCipherModeException.Message">
            <summary>
Get/Set: The message associated with the error
</summary>
        </member>
        <member name="T:CEX.Exception.CryptoCipherModeException">
            <summary>
Wraps exceptions thrown within Symmetric cipher mode operations
</summary>
        </member>
        <member name="M:CEX.Generator.HKDF.Update(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Update the Salt material
</summary>
            <param name="Salt">Pseudo random seed material</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt value is too small</exception>
        </member>
        <member name="M:CEX.Generator.HKDF.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
        </member>
        <member name="M:CEX.Generator.HKDF.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
        </member>
        <member name="M:CEX.Generator.HKDF.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value; must be at least 1* digest block size</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt is too small</exception>
        </member>
        <member name="M:CEX.Generator.HKDF.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Generate pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">The starting position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            <returns>Number of bytes generated</returns>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the output buffer is too small, or the size requested exceeds maximum: 255 * HashLen bytes</exception>
        </member>
        <member name="M:CEX.Generator.HKDF.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Generate a block of pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:CEX.Generator.HKDF.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Generator.HKDF.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Generator.HKDF.#ctor(CEX.Mac.HMAC*)">
            <summary>
Initialize an HKDF Bytes Generator with an HMAC
</summary>
            <param name="Hmac">The initialized HMAC to be used</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if a null HMAC is used</exception>
        </member>
        <member name="M:CEX.Generator.HKDF.#ctor(CEX.Digest.IDigest*)">
            <summary>
Initialize an HKDF Bytes Generator with a message digest
</summary>
            <param name="Digest">The initialized message digest to be used</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if a null digest is used</exception>
        </member>
        <member name="M:CEX.Generator.HKDF.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Generator.HKDF.KeySize">
            <summary>
                <para>Minimum initialization key size in bytes; 
combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="M:CEX.Generator.HKDF.IsInitialized">
            <summary>
Get: Generator is ready to produce data
</summary>
        </member>
        <member name="M:CEX.Generator.HKDF.Enumeral">
            <summary>
Get: The generators type name
</summary>
        </member>
        <member name="T:CEX.Generator.HKDF">
            <summary>
HKDF: An implementation of an Hash based Key Derivation Function
</summary>
            <seealso cref="T:CEX.Mac.HMAC" />
            <seealso cref="N:CEX.Digest" />
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Can be initialized with a Digest or a Mac.</description>
                    </item>
                    <item>
                        <description>Salt size should be multiple of Digest block size.</description>
                    </item>
                    <item>
                        <description>Ikm size should be Digest hash return size.</description>
                    </item>
                    <item>
                        <description>Nonce and Ikm are optional, (but recommended).</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>RFC <a href="http://tools.ietf.org/html/rfc2104">2104</a>: HMAC: Keyed-Hashing for Message Authentication.</description>
                    </item>
                    <item>
                        <description>RFC <a href="http://tools.ietf.org/html/rfc5869">5869</a>: HMAC-based Extract-and-Expand Key Derivation Function.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Mac.HMAC.Update(System.Byte)">
            <summary>
Update the digest with 1 byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Mac.HMAC.Reset">
            <summary>
Reset and initialize the underlying digest
</summary>
        </member>
        <member name="M:CEX.Mac.HMAC.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the HMAC generator
<para>Uses a Key and optional IV field to initialize the cipher.</para></summary>
            <param name="MacKey">A byte array containing the primary Key</param>
            <param name="IV">A byte array containing a secondary Initialization Vector</param>
        </member>
        <member name="M:CEX.Mac.HMAC.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Completes processing and returns the HMAC code
</summary>
            <param name="Output">Output array that receives the hash code</param>
            <param name="OutOffset">Offset within Output array</param>
            <returns>The number of bytes processed</returns>
        </member>
        <member name="M:CEX.Mac.HMAC.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Mac.HMAC.ComputeMac(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The output message code</param>
        </member>
        <member name="M:CEX.Mac.HMAC.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the digest
</summary>
            <param name="Input">Hash input data</param>
            <param name="InOffset">Starting position with the Input array</param>
            <param name="Length">Length of data to process</param>
        </member>
        <member name="M:CEX.Mac.HMAC.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Mac.HMAC.#ctor(CEX.Digest.IDigest*)">
            <summary>
Initialize the class
</summary>
            <param name="Digest">Message Digest instance</param>
            <exception cref="T:CEX.Exception.CryptoMacException">Thrown if a null digest is used</exception>
        </member>
        <member name="M:CEX.Mac.HMAC.Name">
            <summary>
Get: Algorithm name
</summary>
        </member>
        <member name="M:CEX.Mac.HMAC.IsInitialized">
            <summary>
Get: Mac is ready to digest data
</summary>
        </member>
        <member name="M:CEX.Mac.HMAC.MacSize">
            <summary>
Get: Size of returned mac in bytes
</summary>
        </member>
        <member name="M:CEX.Mac.HMAC.Enumeral">
            <summary>
Get: The macs type name
</summary>
        </member>
        <member name="M:CEX.Mac.HMAC.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="T:CEX.Mac.HMAC">
            <summary>
An implementation of a Hash based Message Authentication Code
</summary>
            <example>
                <description>Example generating a MAC code from an Input array</description>
                <code>
CEX::Digest::SHA256* eng;
CEX::Mac::HMAC hmac1(eng);
hmac1.Initialize(key, [IV]);
hmac1.ComputeMac(Input, Output);
delete eng;
</code>
            </example>
            <seealso cref="N:CEX.Digest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Key size should be equal to digest output size.</description>
                    </item>
                    <item>
                        <description>Block size is the Digests engines block size.</description>
                    </item>
                    <item>
                        <description>Digest size is the Digest engines digest return size.</description>
                    </item>
                    <item>
                        <description>The <see cref="M:CEX.Mac.HMAC.ComputeMac(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)" /> method wraps the <see cref="M:CEX.Mac.HMAC.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)" /> and DoFinal methods.</description>/&gt;</item>
                    <item>
                        <description>The <see cref="M:CEX.Mac.HMAC.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)" /> method resets the internal state.</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>RFC <a href="http://tools.ietf.org/html/rfc2104">2104</a>: HMAC: Keyed-Hashing for Message Authentication.</description>
                    </item>
                    <item>
                        <description>Fips <a href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198-1</a>: The Keyed-Hash Message Authentication Code (HMAC).</description>
                    </item>
                    <item>
                        <description>Fips <a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">180-4</a>: Secure Hash Standard (SHS).</description>
                    </item>
                    <item>
                        <description>CRYPTO '06, Lecture <a href="http://cseweb.ucsd.edu/~mihir/papers/hmac-new.pdf">NMAC and HMAC Security</a>: NMAC and HMAC Security Proofs.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Mac.IMac.Update(System.Byte)">
            <summary>
Update the digest with 1 byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Mac.IMac.Reset">
            <summary>
Reset and initialize the underlying digest
</summary>
        </member>
        <member name="M:CEX.Mac.IMac.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the MAC generator.
</summary>
            <param name="MacKey">The HMAC Key</param>
            <param name="IV">The optional IV</param>
        </member>
        <member name="M:CEX.Mac.IMac.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Completes processing and returns the HMAC code
</summary>
            <param name="Output">Output array that receives the hash code</param>
            <param name="OutOffset">Offset within Output array</param>
            <returns>The number of bytes processed</returns>
        </member>
        <member name="M:CEX.Mac.IMac.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Mac.IMac.ComputeMac(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the MAC value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The output Mac code</param>
        </member>
        <member name="M:CEX.Mac.IMac.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the digest
</summary>
            <param name="Input">Hash input data</param>
            <param name="InOffset">Starting position with the Input array</param>
            <param name="Length">Length of data to process</param>
        </member>
        <member name="M:CEX.Mac.IMac.Name">
            <summary>
Get: Algorithm name
</summary>
        </member>
        <member name="M:CEX.Mac.IMac.IsInitialized">
            <summary>
Get: Mac is ready to digest data
</summary>
        </member>
        <member name="M:CEX.Mac.IMac.MacSize">
            <summary>
Get: Size of returned mac in bytes
</summary>
        </member>
        <member name="M:CEX.Mac.IMac.BlockSize">
            <summary>
Get: The Digests internal blocksize in bytes
</summary>
        </member>
        <member name="M:CEX.Mac.IMac.Enumeral">
            <summary>
Get: The macs type name
</summary>
        </member>
        <member name="M:CEX.Mac.IMac.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Mac.IMac.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Mac.IMac">
            <summary>
Message Authentication Code (MAC) Interface
</summary>
        </member>
        <member name="T:CEX.Enumeration.Macs">
            <summary>
Message Authentication Code Generators
</summary>
        </member>
        <member name="F:VMAC">
            <summary>
A Variably Modified Permutation Composition based Message Authentication Code (VMPC-MAC)
</summary>
        </member>
        <member name="F:HMAC">
            <summary>
A Hash based Message Authentication Code wrapper (HMAC)
</summary>
        </member>
        <member name="F:CMAC">
            <summary>
A Cipher based Message Authentication Code wrapper (CMAC)
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoMacException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoMacException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoMacException.Origin">
            <summary>
Get/Set: The origin of the exception in the format Class
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoMacException.Message">
            <summary>
Get/Set: The message associated with the error
</summary>
        </member>
        <member name="T:CEX.Exception.CryptoMacException">
            <summary>
Wraps exceptions thrown within Message Authentication Code operations
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.WriteByte(System.Byte)">
            <summary>
Write a single byte from the stream
</summary>
            <returns>The byte value</returns>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if the file is read only</exception>
        </member>
        <member name="M:CEX.IO.FileStream.Write(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Writes a buffer into the stream
</summary>
            <param name="Buffer">The output buffer to write to the stream</param>
            <param name="Offset">Offset within the output buffer at which to begin</param>
            <param name="Count">The number of bytes to write</param>
            <returns>The number of bytes processed</returns>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if the file is read only</exception>
        </member>
        <member name="M:CEX.IO.FileStream.SetLength(System.UInt32)">
            <summary>
Set the length of the stream
</summary>
            <param name="Length">The desired length</param>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if the file is read only</exception>
        </member>
        <member name="M:CEX.IO.FileStream.Seek(System.UInt32,&lt;unknown type&gt;)">
            <summary>
Seek to a position within the stream
</summary>
            <param name="Offset">The offset position</param>
            <param name="Origin">The starting point</param>
        </member>
        <member name="M:CEX.IO.FileStream.Reset">
            <summary>
Reset and initialize the underlying stream to zero
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.ReadByte">
            <summary>
Read a single byte from the stream
</summary>
            <returns>The byte value</returns>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if the stream is too short or the file is write only</exception>
        </member>
        <member name="M:CEX.IO.FileStream.Read(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Reads a portion of the stream into the buffer
</summary>
            <param name="Buffer">The output buffer receiving the bytes</param>
            <param name="Offset">Offset within the output buffer at which to begin</param>
            <param name="Count">The number of bytes to read</param>
            <returns>The number of bytes processed</returns>
        </member>
        <member name="M:CEX.IO.FileStream.Flush">
            <summary>
Write the stream to disk
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.CopyTo(CEX.IO.IByteStream*)">
            <summary>
Copy this stream to another stream
</summary>
            <param name="Destination">The destination stream</param>
        </member>
        <member name="M:CEX.IO.FileStream.Close">
            <summary>
Close and flush the stream
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CEX.IO.FileStream.FileAccess,CEX.IO.FileStream.FileMode)">
            <summary>
Initialize this class
</summary>
            <param name="FileName">The full path to the file</param>
            <param name="Access">The level of access requested</param>
            <param name="Mode">The file processing mode</param>
        </member>
        <member name="M:CEX.IO.FileStream.Stream">
            <summary>
Get: The underlying stream
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.Position">
            <summary>
Get: The streams current position
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.Length">
            <summary>
Get: The stream length
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.CanWrite">
            <summary>
Get: The stream can be written to
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.CanSeek">
            <summary>
Get: The stream is seekable
</summary>
        </member>
        <member name="M:CEX.IO.FileStream.CanRead">
            <summary>
Get: The stream can be read
</summary>
        </member>
        <member name="T:CEX.IO.FileStream.FileMode">
            <summary>
File operation mode flags
</summary>
        </member>
        <member name="T:CEX.IO.FileStream.FileAccess">
            <summary>
File access type flags
</summary>
        </member>
        <member name="T:CEX.IO.FileStream">
            <summary>
Write data values to a file
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.WriteByte(System.Byte)">
            <summary>
Write a single byte from the stream
</summary>
            <returns>The byte value</returns>
        </member>
        <member name="M:CEX.IO.IByteStream.Write(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Writes a buffer into the stream
</summary>
            <param name="Buffer">The buffer to write to the stream</param>
            <param name="Offset">Offset within the output buffer at which to begin</param>
            <param name="Count">The number of bytes to write</param>
            <returns>The number of bytes written</returns>
            <exception cref="T:CEX.Exception.CryptoProcessingException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:CEX.IO.IByteStream.SetLength(System.UInt32)">
            <summary>
Set the length of the stream
</summary>
            <param name="Length">The desired length</param>
        </member>
        <member name="M:CEX.IO.IByteStream.Seek(System.UInt32,&lt;unknown type&gt;)">
            <summary>
Seek to a position within the stream
</summary>
            <param name="Offset">The offset position</param>
            <param name="Origin">The starting point</param>
        </member>
        <member name="M:CEX.IO.IByteStream.Reset">
            <summary>
Reset and initialize the underlying digest
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.ReadByte">
            <summary>
Read a single byte from the stream
</summary>
            <returns>The byte value</returns>
        </member>
        <member name="M:CEX.IO.IByteStream.Read(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Reads a portion of the stream into the buffer
</summary>
            <param name="Buffer">The output buffer receiving the bytes</param>
            <param name="Offset">Offset within the output buffer at which to begin</param>
            <param name="Count">The number of bytes to read</param>
            <returns>The number of bytes processed</returns>
        </member>
        <member name="M:CEX.IO.IByteStream.Flush">
            <summary>
Write the stream to disk
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.CopyTo(CEX.IO.IByteStream*)">
            <summary>
Copy this stream to another stream
</summary>
            <param name="Destination">The destination stream</param>
        </member>
        <member name="M:CEX.IO.IByteStream.Close">
            <summary>
Close and flush the stream
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.Position">
            <summary>
Get: The streams current position
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.Length">
            <summary>
Get: The stream length
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.CanWrite">
            <summary>
Get: The stream can be written to
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.CanSeek">
            <summary>
Get: The stream is seekable
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.CanRead">
            <summary>
Get: The stream can be read
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.IO.IByteStream.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.IO.IByteStream">
            <summary>
Data stream object interface
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoProcessingException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoProcessingException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoProcessingException.Origin">
            <summary>
Get/Set: The origin of the exception in the format Class
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoProcessingException.Message">
            <summary>
Get/Set: The message associated with the error
</summary>
        </member>
        <member name="T:CEX.Exception.CryptoProcessingException">
            <summary>
Generalized cryptographic error container
</summary>
        </member>
        <member name="T:CEX.IO.SeekOrigin">
            <summary>
Seek origin position flags
</summary>
        </member>
        <member name="F:End">
            <summary>
Start at the end of the stream
</summary>
        </member>
        <member name="F:Current">
            <summary>
Start at the streams current position
</summary>
        </member>
        <member name="F:Begin">
            <summary>
Start at the beginning of the stream
</summary>
        </member>
        <member name="M:CEX.Utility.IntUtils.XORBLK(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
XOR contiguous 16 byte blocks in an array.
<para>The array must be aligned to 16</para></summary>
            <param name="Input">The source array</param>
            <param name="InOffset">Offset within the source array</param>
            <param name="Output">The destination array</param>
            <param name="OutOffset">Offset within the destination array</param>
            <param name="Size">The number of (16 byte block aligned) bytes to process</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR256(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Block XOR 32 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="InOffset">Offset within the source array</param>
            <param name="Output">The destination array</param>
            <param name="OutOffset">Offset within the destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR256(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Block XOR 32 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="Output">The destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR256(System.Byte!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Block XOR 32 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="Output">The destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR128(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Block XOR 16 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="InOffset">Offset within the source array</param>
            <param name="Output">The destination array</param>
            <param name="OutOffset">Offset within the destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR128(System.Byte!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Block XOR 16 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="Output">The destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR128(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Block XOR 16 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="Output">The destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR64(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Block XOR 8 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="InOffset">Offset within the source array</param>
            <param name="Output">The destination array</param>
            <param name="OutOffset">Offset within the destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR64(System.Byte!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Block XOR 8 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="Output">The destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR64(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Block XOR 8 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="Output">The destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR32(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Block XOR 4 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="InOffset">Offset within the source array</param>
            <param name="Output">The destination array</param>
            <param name="OutOffset">Offset within the destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR32(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Block XOR 4 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="Output">The destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.XOR32(System.Byte!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Block XOR 4 bytes
</summary>
            <param name="Input">The source array</param>
            <param name="Output">The destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToWord64s(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convert an array of 64 bit words into a byte array
</summary>
            <param name="Input">The input integer array</param>
            <param name="InOffset">The input arrays starting offset</param>
            <param name="Length">The number of bytes to return</param>
            <param name="Output">The input integer array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.Word64sToBytes(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convert an array of 64 bit words into a byte array
</summary>
            <param name="Input">The input integer array</param>
            <param name="Output">The output byte array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.ToInt64(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;,System.UInt32)">
            <summary>
Convert bytes to a Little Endian 64 bit word
</summary>
            <param name="Input">The input bytes</param>
            <param name="InOffset">The starting offset within the input array</param>
            <returns>The 64 bit integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.ToInt32(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;,System.UInt32)">
            <summary>
Convert bytes to a Little Endian 32 bit word
</summary>
            <param name="Input">The input bytes</param>
            <param name="InOffset">The starting offset within the input array</param>
            <returns>The 32bit integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.ToInt16(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;,System.UInt32)">
            <summary>
Convert bytes to a Little Endian 16 bit word
</summary>
            <param name="Input">The input bytes</param>
            <param name="InOffset">The starting offset within the input array</param>
            <returns>The 16 bit integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.ToInt64(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;)">
            <summary>
Convert bytes to a Little Endian 64 bit word
</summary>
            <param name="Input">The input bytes</param>
            <returns>The 64 bit integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.ToInt32(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;)">
            <summary>
Convert bytes to a Little Endian 32 bit word
</summary>
            <param name="Input">The input bytes</param>
            <returns>The 32 bit integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.ToInt16(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;)">
            <summary>
Convert bytes to a Little Endian 16 bit word
</summary>
            <param name="Input">The input bytes</param>
            <returns>The 16 bit integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.ToBit64(System.UInt64)">
            <summary />
            <param name="Value">The initial value</param>
            <returns />
        </member>
        <member name="M:CEX.Utility.IntUtils.ToBit32(System.UInt32)">
            <summary />
            <param name="Value">The initial value</param>
            <returns />
        </member>
        <member name="M:CEX.Utility.IntUtils.ToBit16(System.UInt16)">
            <summary />
            <param name="Value">The initial value</param>
            <returns />
        </member>
        <member name="M:CEX.Utility.IntUtils.RotrFixed64(System.UInt64,System.Int32)">
            <summary>
Rotate shift an unsigned 64 bit integer to the right
</summary>
            <param name="Value">The initial value</param>
            <param name="Shift">The number of bits to shift</param>
            <returns>The right shifted 64 bit integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.RotlFixed64(System.UInt64,System.Int32)">
            <summary>
Rotate shift an unsigned 64 bit integer to the left
</summary>
            <param name="Value">The initial value</param>
            <param name="Shift">The number of bits to shift</param>
            <returns>The left shifted integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.RotrFixed(System.UInt32,System.UInt32)">
            <summary>
Rotate shift an unsigned 32 bit integer to the right
</summary>
            <param name="Value">The initial value</param>
            <param name="Shift">The number of bits to shift</param>
            <returns>The right shifted integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.RotlFixed(System.UInt32,System.UInt32)">
            <summary>
Rotate shift an unsigned 32 bit integer to the left
</summary>
            <param name="Value">The initial value</param>
            <param name="Y">The number of bits to shift</param>
            <returns>The left shifted integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.RotateRight(System.UInt64,System.Int32)">
            <summary>
Rotate shift an unsigned 64 bit integer to the right
</summary>
            <param name="Value">The initial value</param>
            <param name="Shift">The number of bits to shift</param>
            <returns>The right shifted integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.RotateRight(System.UInt32,System.Int32)">
            <summary>
Rotate shift a 32 bit integer to the right
</summary>
            <param name="Value">The initial value</param>
            <param name="Shift">The number of bits to shift</param>
            <returns>The right shifted integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.RotateLeft(System.UInt64,System.Int32)">
            <summary>
Rotate shift an unsigned 64 bit integer to the left
</summary>
            <param name="Value">The initial value</param>
            <param name="Shift">The number of bits to shift</param>
            <returns>The left shifted integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.RotateLeft(System.UInt32,System.Int32)">
            <summary>
Rotate shift an unsigned 32 bit integer to the left
</summary>
            <param name="Value">The initial value</param>
            <param name="Shift">The number of bits to shift</param>
            <returns>The left shifted integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.Parity(System.UInt64)">
            <summary>
Get the parity bit from a 64 bit integer
</summary>
            <param name="Value">The initial value</param>
            <returns>The parity value</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.Min(System.UInt32,System.UInt32)">
            <summary>
Return the smaller of two values
</summary>
            <param name="A">The first comparison value</param>
            <param name="B">The second comparison value</param>
            <returns>The smaller value</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.Crop(System.UInt64,System.UInt32)">
            <summary>
Crop a 64 bit integer value
</summary>
            <param name="Value">The initial value</param>
            <param name="Size">The number of bits in the new integer</param>
            <returns>The cropped integer</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.Word64ToBytes(System.UInt64!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Convert a system aligned Endian 64 bit word to bytes
</summary>
            <param name="Value">The 64 bit word</param>
            <param name="Output">The destination bytes</param>
            <param name="OutOffset">OutOffset within the destination block</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.Word64ToBytes(System.UInt64!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convert a system aligned Endian 64 bit word to bytes
</summary>
            <param name="Value">The 64 bit word</param>
            <param name="Output">The destination bytes</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.Word32ToBytes(System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Convert a system aligned Endian 32 bit word to bytes
</summary>
            <param name="Value">The 32 bit word</param>
            <param name="Output">The destination bytes</param>
            <param name="OutOffset">OutOffset within the destination block</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.Word32ToBytes(System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convert a system aligned Endian 32 bit word to bytes
</summary>
            <param name="Value">The 32 bit word</param>
            <param name="Output">The destination bytes</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.Word16ToBytes(System.UInt16!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Convert a system aligned Endian 16 bit word to bytes
</summary>
            <param name="Value">The 16 bit word</param>
            <param name="Output">The destination bytes</param>
            <param name="OutOffset">OutOffset within the destination block</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.Word16ToBytes(System.UInt16!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convert a system aligned Endian 16 bit word to bytes
</summary>
            <param name="Value">The 16 bit word</param>
            <param name="Output">The destination bytes</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToWord64(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a byte array to a system aligned 64 bit word
</summary>
            <param name="Input">The source byte array</param>
            <param name="InOffset">InOffset within the source array</param>
            <returns>A 64 bit word in native Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToWord64(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convert a byte array to a system aligned 64 bit word
</summary>
            <param name="Input">The source byte array</param>
            <returns>A 64 bit word in native Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToWord32(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a byte array to a system aligned 32 bit word
</summary>
            <param name="Input">The source byte array</param>
            <param name="InOffset">InOffset within the source array</param>
            <returns>A 32 bit word in native Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToWord32(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convert a byte array to a system aligned 32 bit word
</summary>
            <param name="Input">The source byte array</param>
            <returns>A 32 bit word in native Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToWord16(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a byte array to a system aligned 16 bit word
</summary>
            <param name="Input">The source byte array</param>
            <param name="InOffset">InOffset within the source array</param>
            <returns>A 16 bit word in native Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToWord16(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convert a byte array to a system aligned 16 bit word
</summary>
            <param name="Input">The source byte array</param>
            <returns>A 16 bit word in native Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToLe64(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a byte array to a Little Endian 64 bit dword
</summary>
            <param name="Input">The source byte array</param>
            <param name="InOffset">Offset within the source array</param>
            <returns>A 64 bit word in Little Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToLe32(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a byte array to a Little Endian 32 bit word
</summary>
            <param name="Input">The source byte array</param>
            <param name="InOffset">Offset within the source array</param>
            <returns>A 32 bit word in Little Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToLe16(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a byte array to a Little Endian 16 bit word
</summary>
            <param name="Input">The source byte array</param>
            <param name="InOffset">Offset within the source array</param>
            <returns>A 16 bit word in Little Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.Le64ToBytes(System.UInt64!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a Little Endian 64 bit dword to bytes
</summary>
            <param name="DWord">The 64 bit word</param>
            <param name="Output">The destination bytes</param>
            <param name="OutOffset">OutOffset within the destination block</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.Le32ToBytes(System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a Little Endian 32 bit word to bytes
</summary>
            <param name="Value">The 32 bit word</param>
            <param name="Output">The destination bytes</param>
            <param name="OutOffset">OutOffset within the destination block</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.Le16ToBytes(System.UInt16!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a Little Endian 16 bit word to bytes
</summary>
            <param name="Value">The 16 bit word</param>
            <param name="Output">The destination bytes</param>
            <param name="OutOffset">OutOffset within the destination block</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToBe64(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a byte array to a Big Endian 64 bit dword
</summary>
            <param name="Input">The source byte array</param>
            <param name="InOffset">Offset within the source array</param>
            <returns>A 64 bit word in Big Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToBe32(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a byte array to a Big Endian 32 bit word
</summary>
            <param name="Input">The source byte array</param>
            <param name="InOffset">Offset within the source array</param>
            <returns>A 32 bit word in Big Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytesToBe16(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a byte array to a Big Endian 16 bit word
</summary>
            <param name="Input">The source byte array</param>
            <param name="InOffset">Offset within the source array</param>
            <returns>A 16 bit word in Big Endian format</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.Be64ToBytes(System.UInt64!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a Big Endian 64 bit dword to bytes
</summary>
            <param name="Value">The 64 bit word</param>
            <param name="Output">The destination bytes</param>
            <param name="OutOffset">OutOffset within the destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.Be32ToBytes(System.UInt32!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a Big Endian 32 bit word to bytes
</summary>
            <param name="Value">The 32 bit word</param>
            <param name="Output">The destination bytes</param>
            <param name="OutOffset">OutOffset within the destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.Be16ToBytes(System.UInt16!System.Runtime.CompilerServices.IsConst,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Convert a Big Endian 16 bit word to bytes
</summary>
            <param name="Value">The 16 bit word</param>
            <param name="Output">The destination bytes</param>
            <param name="OutOffset">OutOffset within the destination array</param>
        </member>
        <member name="M:CEX.Utility.IntUtils.ByteReverse(System.UInt64)">
            <summary>
Reverse a 64 bit integer
</summary>
            <param name="Value">The initial value</param>
            <returns>The reversed ulong</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.ByteReverse(System.UInt32)">
            <summary>
Reverse a 32 bit integer
</summary>
            <param name="Value">The initial value</param>
            <returns>The reversed uint</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.ByteReverse(System.UInt16)">
            <summary>
Reverse a 16 bit integer
</summary>
            <param name="Value">The initial value</param>
            <returns>The reversed ushort</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BytePrecision(System.UInt64)">
            <summary>
Get the byte precision
</summary>
            <param name="Value">The sample value</param>
            <returns>The byte precision</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BitReverse(System.UInt64)">
            <summary>
Reverse an unsigned 64 bit integer
</summary>
            <param name="Value">Initial value</param>
            <returns>The reversed ulong</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BitReverse(System.UInt32)">
            <summary>
Reverse an unsigned 32 bit integer
</summary>
            <param name="Value">Initial value</param>
            <returns>The reversed uint</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BitReverse(System.UInt16)">
            <summary>
Reverse an unsigned 16 bit integer
</summary>
            <param name="Value">Initial value</param>
            <returns>The reversed ushort</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BitReverse(System.Byte)">
            <summary>
Reverse a byte
</summary>
            <param name="Value">Initial value</param>
            <returns>The revered byte</returns>
        </member>
        <member name="M:CEX.Utility.IntUtils.BitPrecision(System.UInt64)">
            <summary>
Get a byte value from a 32 bit integer
</summary>
            <param name="Value">The integer value</param>
            <param name="Shift">The number of bytes to shift</param>
            <returns>Bit precision</returns>
            <summary>
Get the bit precision value
</summary>
            <param name="Value">initial value</param>
            <returns>Bit precision</returns>
        </member>
        <member name="T:CEX.Utility.IntUtils">
            <summary>
Integer functions class
</summary>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.Update(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Update the Salt material
</summary>
            <param name="Salt">Pseudo random seed material</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt value is too small</exception>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value; must be at least 1* digest hash size</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the Salt is too small</exception>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Generate pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">The starting position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            <returns>Number of bytes generated</returns>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Generate a block of pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.Dispose">
            <summary>
Finalize objects
</summary>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.#ctor(CEX.Digest.IDigest*)">
            <summary>
Creates a KDF2 Bytes Generator based on the given hash function
</summary>
            <param name="Digest">The digest used</param>
            <exception cref="T:CEX.Exception.CryptoGeneratorException">Thrown if a null digest is used</exception>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.Name">
            <summary>
Get: Cipher name
</summary>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.KeySize">
            <summary>
                <para>Minimum initialization key size in bytes; 
combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.IV">
            <summary>
Get: The current state of the initialization Vector
</summary>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.IsInitialized">
            <summary>
Get: Generator is ready to produce data
</summary>
        </member>
        <member name="M:CEX.Generator.KDF2Drbg.Enumeral">
            <summary>
Get: The generators type name
</summary>
        </member>
        <member name="T:CEX.Generator.KDF2Drbg">
            <summary>
KDF2Drbg: An implementation of an Hash based Key Derivation Function
</summary>
            <example>
                <description>Example using an <c>IGenerator</c> interface:</description>
                <code>
KDF2Drbg rnd(new SHA512());
// initialize
rnd.Initialize(Salt, [Ikm], [Nonce]);
// generate bytes
 rnd.Generate(Output, [Offset], [Size]);
</code>
            </example>
            <seealso cref="T:CEX.Digest.IDigest" />
            <seealso cref="T:CEX.Enumeration.Digests" />
            <remarks>
                <description>Implementation Notes:</description>
                <list type="bullet">
                    <item>
                        <description>Can be initialized with a Digest.</description>
                    </item>
                    <item>
                        <description>Salt size should be multiple of Digest block size.</description>
                    </item>
                    <item>
                        <description>Ikm size should be Digest hash return size.</description>
                    </item>
                    <item>
                        <description>Nonce and Ikm are optional, (but recommended).</description>
                    </item>
                </list>
                <description>Guiding Publications:</description>
                <list type="table">
                    <item>
                        <description>RFC 2898: <a href="http://tools.ietf.org/html/rfc2898">Password-Based Cryptography Specification Version 2.0</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Digest.IDigest.Update(System.Byte)">
            <summary>
Update the message digest with a single byte
</summary>
            <param name="Input">Input byte</param>
        </member>
        <member name="M:CEX.Digest.IDigest.Reset">
            <summary>
Reset the internal state
</summary>
        </member>
        <member name="M:CEX.Digest.IDigest.DoFinal(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>
Do final processing and get the hash value
</summary>
            <param name="Output">The Hash output value array</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:CEX.Digest.IDigest.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Digest.IDigest.ComputeHash(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the Hash value
</summary>
            <param name="Input">Input data</param>
            <param name="Output">The hash output value array</param>
        </member>
        <member name="M:CEX.Digest.IDigest.BlockUpdate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Update the buffer
</summary>
            <param name="Input">Input data</param>
            <param name="InOffset">The starting offset within the Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:CEX.Digest.IDigest.Name">
            <summary>
Get: The Digest name
</summary>
        </member>
        <member name="M:CEX.Digest.IDigest.Enumeral">
            <summary>
Get: The digests type enumeration member
</summary>
        </member>
        <member name="M:CEX.Digest.IDigest.DigestSize">
            <summary>
Get: Size of returned hash value in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.IDigest.BlockSize">
            <summary>
Get: The Digests internal block size in bytes
</summary>
        </member>
        <member name="M:CEX.Digest.IDigest.Dispose">
            <summary>
Finalizer
</summary>
        </member>
        <member name="M:CEX.Digest.IDigest.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Digest.IDigest">
            <summary>
Hash Digest Interface
</summary>
        </member>
        <member name="T:CEX.Enumeration.Digests">
            <summary>
Message Digests
</summary>
        </member>
        <member name="F:Skein1024">
            <summary>
The Skein digest with a 1024 bit return size
</summary>
        </member>
        <member name="F:Skein512">
            <summary>
The Skein digest with a 512 bit return size
</summary>
        </member>
        <member name="F:Skein256">
            <summary>
The Skein digest with a 256 bit return size
</summary>
        </member>
        <member name="F:SHA512">
            <summary>
The SHA-2 digest with a 512 bit return size
</summary>
        </member>
        <member name="F:SHA256">
            <summary>
The SHA-2 digest with a 256 bit return size
</summary>
        </member>
        <member name="F:Keccak512">
            <summary>
The SHA-3 digest based on Keccak with a 512 bit return size
</summary>
        </member>
        <member name="F:Keccak256">
            <summary>
The SHA-3 digest based on Keccak with a 256 bit return size
</summary>
        </member>
        <member name="F:Blake512">
            <summary>
The Blake digest with a 512 bit return size
</summary>
        </member>
        <member name="F:Blake256">
            <summary>
The Blake digest with a 256 bit return size
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoDigestException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoDigestException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoDigestException.Origin">
            <summary>
Get/Set: The origin of the exception in the format Class
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoDigestException.Message">
            <summary>
Get/Set: The message associated with the error
</summary>
        </member>
        <member name="T:CEX.Exception.CryptoDigestException">
            <summary>
Cryptographic digest error container
</summary>
        </member>
        <member name="M:CEX.Generator.IGenerator.Update(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Update the Seed material
</summary>
            <param name="Salt">Pseudo random seed material</param>
        </member>
        <member name="M:CEX.Generator.IGenerator.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
        </member>
        <member name="M:CEX.Generator.IGenerator.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
        </member>
        <member name="M:CEX.Generator.IGenerator.Initialize(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Initialize the generator
</summary>
            <param name="Salt">Salt value</param>
        </member>
        <member name="M:CEX.Generator.IGenerator.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
            <summary>
Generate pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">The starting position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:CEX.Generator.IGenerator.Generate(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Generate a block of pseudo random bytes
</summary>
            <param name="Output">Output array filled with random bytes</param>
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:CEX.Generator.IGenerator.Destroy">
            <summary>
Release all resources associated with the object
</summary>
        </member>
        <member name="M:CEX.Generator.IGenerator.Name">
            <summary>
Algorithm name
</summary>
        </member>
        <member name="M:CEX.Generator.IGenerator.KeySize">
            <summary>
                <para>Minimum initialization key size in bytes; 
combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="M:CEX.Generator.IGenerator.IsInitialized">
            <summary>
Get: Generator is ready to produce data
</summary>
        </member>
        <member name="M:CEX.Generator.IGenerator.Enumeral">
            <summary>
Get: The generators type name
</summary>
        </member>
        <member name="M:CEX.Generator.IGenerator.Dispose">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="M:CEX.Generator.IGenerator.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Generator.IGenerator">
            <summary>
Pseudo random Generator Interface
</summary>
        </member>
        <member name="T:CEX.Enumeration.Generators">
            <summary>
Random Generators
</summary>
        </member>
        <member name="F:SP20Drbg">
            <summary>
An implementation of a Salsa20 Counter based DRBG
</summary>
        </member>
        <member name="F:PBKDF2">
            <summary>
An implementation of a Hash based Key Derivation PKCS#5 Version 2
</summary>
        </member>
        <member name="F:KDF2Drbg">
            <summary>
An implementation of a Hash based Key Derivation Function PBKDF2
</summary>
        </member>
        <member name="F:HKDF">
            <summary>
A Hash based Key Derivation Function HKDF
</summary>
        </member>
        <member name="F:DGCDrbg">
            <summary>
An implementation of a Digest Counter based DRBG
</summary>
        </member>
        <member name="F:CTRDrbg">
            <summary>
An implementation of a Encryption Counter based DRBG
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoGeneratorException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoGeneratorException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoGeneratorException.Origin">
            <summary>
Get/Set: The origin of the exception in the format Class
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoGeneratorException.Message">
            <summary>
Get/Set: The message associated with the error
</summary>
        </member>
        <member name="T:CEX.Exception.CryptoGeneratorException">
            <summary>
Wraps exceptions thrown within Random Generator operations
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ISO7816.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ISO7816.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ISO7816.AddPadding(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Add padding to input array
</summary>
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
            <exception cref="T:CEX.Exception.CryptoPaddingException">Thrown if the padding offset value is longer than the array length</exception>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ISO7816.Name">
            <summary>
Get: Padding name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ISO7816.Enumeral">
            <summary>
Get: The padding modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ISO7816.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.ISO7816.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Padding.ISO7816">
            <summary>
The ISO7816 Padding Scheme
</summary>
            <remarks>
                <description>Guiding Publications:</description>
                <list type="number">
                    <item>
                        <description>ISO/IEC <a href="http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=36134">7816-4:2005</a>.</description>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.IPadding.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.IPadding.GetPaddingLength(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the length of padding in an array
</summary>
            <param name="Input">Padded array of bytes</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.IPadding.AddPadding(std.vector&lt;System.Byte,std.allocator&lt;System.Byte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>
Add padding to input array
</summary>
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            <returns>Length of padding</returns>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.IPadding.Name">
            <summary>
Get: Padding name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.IPadding.Enumeral">
            <summary>
Get: The padding modes type name
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.IPadding.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:CEX.Cipher.Symmetric.Block.Padding.IPadding.#ctor">
            <summary>
CTor: Initialize this class
</summary>
        </member>
        <member name="T:CEX.Cipher.Symmetric.Block.Padding.IPadding">
            <summary>
Padding Mode Interface
</summary>
        </member>
        <member name="T:CEX.Enumeration.PaddingModes">
            <summary>
Block Cipher Padding Modes
</summary>
        </member>
        <member name="F:X923">
            <summary>
X923 Padding Mode
</summary>
        </member>
        <member name="F:TBC">
            <summary>
Trailing Bit Complement Padding Mode
</summary>
        </member>
        <member name="F:PKCS7">
            <summary>
PKCS7 Padding Mode
</summary>
        </member>
        <member name="F:ISO7816">
            <summary>
ISO7816 Padding Mode
</summary>
        </member>
        <member name="F:None">
            <summary>
Specify None if the input should not require padding (block aligned)
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoPaddingException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoPaddingException.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Exception constructor
</summary>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:CEX.Exception.CryptoPaddingException.Origin">
            <summary>
Get/Set: The origin of the exception in the format Class
</summary>
        </member>
        <member name="M:CEX.Exception.CryptoPaddingException.Message">
            <summary>
Get/Set: The message associated with the error
</summary>
        </member>
        <member name="T:CEX.Exception.CryptoPaddingException">
            <summary>
Wraps exceptions thrown within a cipher padding operation
</summary>
        </member>
        <!-- Discarding badly formed XML document comment for member 'T:CEX.Cipher.Symmetric.Stream.ChaCha'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CEX.Prng.CTRPrng'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CEX.Generator.PBKDF2'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CEX.Generator.PBKDF2'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CEX.Prng.CTRPrng'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CEX.Cipher.Symmetric.Stream.ChaCha'. -->
    </members>
</doc>