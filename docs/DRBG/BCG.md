# An implementation of a Block cipher Counter mode Generator DRBG: BCG

## Description:
The Block cipher Counter Generator creates a key-stream by encrypting an incrementing Big Endian ordered 128bit monotonic counter (nonce). 
In parallel mode, the generators counter is divided into staggered counter arrays, allowing for multi-threaded operation. 
The implementation is further parallelized by constructing a larger staggered-parallel counter array, and processing large blocks using 128, 256, or 512 bit SIMD instructions. 
Both of these enhancements still produce the identical output to a sequential counter mode generator, and are the equivalent output to a CTR block-cipher mode encrypting and array of zeroes.

## Initialization and Update: 
The Initialize functions have three different parameter options: the Key which is the primary key, the Nonce used to initialize the internal counter, and the optional Info array which is used if the underlying block-cipher is running in extended mode. 
The Key value must be one of the LegalKeySizes in length, and must be a secret and random value. 
The supported nonce size is the block cipher functions internal block-size, in this library, that is always 128 bits (16 bytes). 
The 16 byte Nonce value should also be a secret value, used to initialize the counter to a non-zero random value. 
The Info parameter maps to the DistributionCode() property of an extended HX cipher, but is ignored when a standard cipher implementation is used. 
The extended cipher modes, and the DistributionCode are recommended, and for best security, the distribution code should be secret, random, and equal in length to the DistributionCodeMax() property 
The Update function uses the seed value to re-key the cipher via the internal key derivation function (cSHAKE). 
The update functions Key parameter, must be a random key value which is added to the existing key state, if a random provider has been specified it is mixed with new entropy, and permuted by a cSHAKE instance to generate the new generator key. 
When using a random provider, the generator can be automatically re-seeded after a specified number of bytes have been generated, using the ReseedThreshold accessor property. 
The nonce and distribution code are retained and reused after the key re-generation operation.

## Multi-Threading: 
The transformation function in a CTR generator is not limited by a dependency chain, this mode can be both SIMD pipelined and multi-threaded. 
Output from the parallelized functions aligns with the output from a standard sequential CTR implementationa output key-stream. 
Parallelism is achieved by pre-calculating the counters positional offset over multiple 'chunks' of key-stream, which are then generated independently across threads. 
The key-stream generated by encrypting the counter array(s), is output as the source of pseudo-random.
Predictive Resistance: 
Predictive and backtracking resistance prevent an attacker who has gained knowledge of generator state at some time from predicting future or previous outputs from the generator. 
The optional resistance mechanism uses an entropy provider to add seed material to the generator at periodic intervals, this new seed material is passed through a cSHAKE generator along with the current state, and the SHAKE permutations pseudo-random output is used to reseed the generator. 
The interval at which this reseeding occurs is 100MB by default, but can be set using the ReseedThreshold() property; once this number of bytes or greater has been generated, the seed is automatically regenerated. 
Predictive resistance is strongly recommended when producing large amounts of pseudo-random (100MB or greater).

## Implementation Notes: 
* The class constructor can either be initialized using a block cipher instance, or using the block ciphers enumeration name. 
* A block cipher or entropy provider instance created using the enumeration constructor, is automatically deleted when the class is destroyed. 
* An entropy provider can be specified through the constructor, which provides a continues stream of entropy to the reseed function, this is strongly recommended with large (+100MB) outputs. 
* The generator can be initialized with either a SymmetricKey or SymmetricSecure key container class, this class must provide a legally sized key and nonce. 
* The LegalKeySizes() property contains a list of supported nonce and key and sizes. 
* There are three LegalKeySizes, minimum, recommended, and maximum, with BCG, the middle value is the recommended seed length for best security; i.e. LegalKeySizes()[1]. 
* The Generate() methods can not be used until the Initialize() function has been called, and the generator has been keyed and is ready to generate pseudo-random output. 
* This implementation has been both pipelined (AVX128, AVX256, or AVX512), and can also be multi-threaded, using any even number of threads. 
* If the system supports Parallel processing, IsParallel() is set to true; passing an output block of ParallelBlockSize() or greater to the Generate function will trigger multi-threaded processing. 
* The ParallelThreadsMax() property is the thread count in the parallel loop (pre-configured automatically); this must be either 1 (IsParallel=false), or an even number no greater than the number of processer cores on the system (including hyperthreads). 
* ParallelBlockSize() is calculated automatically based on the processor(s) L1 data cache size, this property can be user defined, and must be evenly divisible by ParallelMinimumSize(). 
* The ParallelBlockSize() and other properties can be changed through the ParallelProfile() accessor function, but there default values are recommended. 

## Example
```cpp

#include "BCG.h"

BCG rng(BlockCiphers::AES, [Providers::ACP]);
// initialize
rng.Initialize(Key, [Nonce], [Info]);
// generate bytes
rng.Generate(Output, [Offset], [Length]);
```
       
## Public Member Functions

```cpp
BCG(const BCG&)=delete
```
Copy constructor: copy is restricted, this function has been deleted

```cpp
BCG& operator=(const BCG&)=delete
```
Copy operator: copy is restricted, this function has been deleted
 
```cpp
BCG()=delete
```
Default constructor: default constructor is restricted, this function has been deleted

```cpp
BCG(BlockCiphers CipherType, Providers ProviderType=Providers::None, bool Parallel=false)
```
Instantiate the generator using a block-cipher type name, an optional entropy source type, and the parallel processing option
 
```cpp
BCG(IBlockCipher *Cipher, IProvider *Provider=nullptr, bool Parallel=false)
```
Instantiate the generator using a block cipher instance, an optional entropy source, and the parallel processing option
 
```cpp
~BCG() override
```
Destructor: finalize this class

```cpp
const size_t DistributionCodeMax()
```
Read Only: The maximum size of the distribution code in bytes

```cpp
const bool IsInitialized() override
```
Read Only: The generator is ready to produce pseudo-random

```cpp
const bool IsParallel()
```
Read Only: Processor parallelization availability

```cpp
const size_t ParallelBlockSize()
```
Read Only: Parallel block size; the byte-size of the requested output data array passed from the Generate function that triggers parallel processing

```cpp
ParallelOptions &ParallelProfile()
```
Read/Write: Parallel and SIMD capability flags and sizes More...

```cpp
size_t & ReseedThreshold() override
```
Read/Write: The maximum output generated before automatic auto-seed generation when using an entropy provider

```cpp
const size_t SecurityStrength() override
```
Read Only: The estimated classical security strength in bits

```cpp
void Generate(std::vector<byte> &Output) override
```
Fill a standard vector with pseudo-random bytes

```cpp
void Generate(SecureVector<byte> &Output) override
```
Fill a secure vector with pseudo-random bytes

```cpp
void Generate(std::vector<byte> &Output, size_t OutOffset, size_t Length) override
```
Fill a standard vector with pseudo-random bytes using offset and length parameters

```cpp
void Generate(SecureVector<byte> &Output, size_t OutOffset, size_t Length) override
```
Fill a secure vector with pseudo-random bytes using offset and length parameters

```cpp
void Initialize(ISymmetricKey &Parameters) override
```
Initialize the generator with an ISymmetricKey container, containing the key and nonce, and optional info string

```cpp
void ParallelMaxDegree(size_t Degree)
```
Set the maximum number of threads allocated when using multi-threaded processing

```cpp
void Update(const std::vector<byte> &Key) override
```
Update the generators seed value

```cpp
void Update(const SecureVector<byte> &Key) override
```
Update the generators keying material with a secure vector key

## Links
* [NIST SP800-90B](http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf): Recommendation for the Entropy Sources Used for Random Bit Generation. 
* [NIST Fips 140-2](http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf): Security Requirments For Cryptographic Modules. 
* [NIST SP800-22 1a](http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf): A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications. 
* [NIST Security Bounds](http://eprint.iacr.org/2006/379.pdf) for the Codebook-based: Deterministic Random Bit Generator. 
