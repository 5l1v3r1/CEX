# TSX1024: A vectorized and optionally parallelized Threefish-1024 120-round stream cipher implementation

## Description:
This cipher is a vectorized and optionally parallelized implementation of the Threefish-1024 cipher, used by the Skein family of hash functions. 
It is capable of processing data using AVX2 or AVX512 SIMD instructions, and can also optionally employ multi-threaded parallelism. 
An optional authentication component has also been added, and the cipher output can be authenticated using either an SHA2 hash based HMAC, or the Keccak based KMAC message authentication code generators.

The transformation function used by Threefish is not limited by a dependency chain; this mode can be both SIMD pipelined and multi-threaded. 
This is achieved by pre-calculating the counters positional offset over multiple 'chunks' of key-stream, which are then generated independently across threads. 
The key stream generated by encrypting the counter array(s), is used as a source of random, and XOR'd with the message input to produce the cipher text.

When operating in authenticated mode; in an encryption cycle the MAC code is automatically appended to the output cipher-text. 
During a decryption cycle, the code is checked against the new code generated by the MAC generator, and a failure will throw a CryptoAuthenticationFailure exception. 
It is recommended that the decryption function is wrapped in a try/catch block, so that the CryptoAuthenticationFailure exception can be handled by the calling function. 
The supported MAC generator options for TSX1024 are HMAC(SHA2-256/512), and the Keccak based KMAC-256, KMAC-512, and the experimental KMAC-1024.

## Implementation Notes
* The key size is fixed at 128 bytes (1024 bits). 
* The nonce size is fixed at 16 bytes (128 bits), and should be a random vector. 
* The Info string is optional, but can be used to create a tweakable cipher; it must be 16 bytes in length. 
* The internal block size is 128 bytes wide. 
* Permutation rounds have been increased from the standard Threefish-1024 implementation of 80, and are fixed at 120. 
* This cipher is capable of authentication by setting the constructors StreamAuthenticators enumeration to one of the HMAC or KMAC options. 
* In authentication mode, during encryption the MAC code is automatically appended to the output cipher-text after each transform call, during decryption, this MAC code is checked and authentication failure will generate a CryptoAuthenticationFailure exception. 
* If authentication is enabled, the cipher-key and MAC seed are generated using cSHAKE, this will change the cipher-text output. 
* In authenticated mode, the internal keys generated by cSHAKE will be unique with each MAC generator, each authentication option should be considered a seperate and distinct variant of the cipher, for example, CSX512-SHAKE512 or CSX512-HMAC512 
* If authentication is enabled, the cipher-key and MAC key are generated using cSHAKE, the SHAKE generator takes the ciphers formal class name as part of the customization string; changing the authentication mode will create a cipher-text output unique to the ciphers configuration. 
* The Info string is optional, but can be used to create a tweakable cipher; must be 16 bytes in length. 
* Permutation rounds are fixed at 80, but can be changed to 40, by removing the CEX_CHACHA512_STRONG definition from the CexConfig file. 
* The class functions are virtual, and can be accessed from an IStreamCipher instance. 
* The transformation methods can not be called until the Initialize(ISymmetricKey) function has been called. 
* Encryption can both be pipelined (AVX, AVX2, or AVX512), and multi-threaded with any even number of threads, the configuration can be modified using the ParallelProfile() accessor function. 
* If the system supports Parallel processing, and ParallelProfile().IsParallel() is set to true; passing an input block of ParallelProfile().ParallelBlockSize() to the transform will be auto parallelized. 
* The ParallelProfile().ParallelThreadsMax() property is used as the thread count in the parallel loop; this must be an even number no greater than the number of processer cores on the system. 
* ParallelProfile().ParallelBlockSize() is calculated automatically based on processor(s) cache size but can be user defined, but must be evenly divisible by ParallelProfile().ParallelMinimumSize(). 
* The ParallelBlockSize() can be changed through the ParallelProfile() property, the initial size is calculated automatically based on the systems capabilities, and modifying this vale is not recommended 

## Example
```cpp
#include "TSX512.h"

// Encrypt and add a MAC code to an array: 
SymmetricKey kp(Key, Nonce);
TSX512 cipher(StreamAuthenticators::HMACSHA256);
// initialize for encryption
cipher.Initialize(true, kp);
cipher.Transform(Input, InOffset, Output, OutOffset, Length);

// Decrypt and authenticate an array: 
SymmetricKey kp(Key, Nonce);
TSX512 cipher(StreamAuthenticators::HMACSHA256);
// initialize for decryption
cipher.Initialize(false, kp);

// decrypt the ciphertext, if the authentication fails an exception is thrown
try
{
    cipher.Transform(Input, InOffset, Output, OutOffset, Length);
}
catch (CryptoAuthenticationFailure)
{
    // do something...
}
```
       
## Public Member Functions
```cpp
TSX1024(const TSX1024&)=delete
 ```
Copy constructor: copy is restricted, this function has been deleted

```cpp
TSX1024& operator=(const TSX1024&)=delete
```
Copy operator: copy is restricted, this function has been deleted

```cpp
TSX1024(StreamAuthenticators AuthenticatorType=StreamAuthenticators::KMAC256)
``` 
Initialize the Threefish-1024 cipher

```cpp
~TSX1024() override
``` 
Destructor: finalize this class

```cpp
const StreamCiphers Enumeral() override
``` 
Read Only: The stream ciphers enumeration type name

```cpp
const bool IsAuthenticator() override
```
Read Only: The cipher has authentication enabled

```cpp
const bool IsEncryption() override
``` 
Read Only: The cipher has been initialized for encryption

```cpp
const bool IsInitialized() override
``` 
Read Only: The cipher is ready to transform data

```cpp
const bool IsParallel() override
``` 
Read Only: Processor parallelization availability

```cpp
const std::vector<SymmetricKeySize> &LegalKeySizes() override
``` 
Read Only: Array of SymmetricKeySize containers, containing legal cipher input key sizes

```cpp
const std::string Name() override
``` 
Read Only: The stream ciphers formal implementation name

```cpp
const size_t ParallelBlockSize() override
``` 
Read Only: Parallel block size; the byte-size of the input/output data arrays passed to a transform that trigger parallel processing

```cpp
ParallelOptions &ParallelProfile() override
``` 
Read/Write: Parallel and SIMD capability flags and recommended sizes

```cpp
const std::vector<byte> Tag() override
``` 
Read Only: The current standard-vector MAC tag value

```cpp
const void Tag (SecureVector<byte> &Output) override
```
Copy the MAC tag to a secure-vector

```cpp
const size_t TagSize() override
``` 
Read Only: The legal tag length in bytes

```cpp
void Initialize(bool Encryption, ISymmetricKey &Parameters) override
``` 
Initialize the cipher with an ISymmetricKey key container

```cpp
void ParallelMaxDegree(size_t Degree) override
``` 
Set the maximum number of threads allocated when using multi-threaded processing

```cpp
void SetAssociatedData(const std::vector<byte> &Input, const size_t Offset, const size_t Length) override
``` 
Add additional data to the authentication generator

```cpp
void Transform(const std::vector<byte> &Input, size_t InOffset, std::vector<byte> &Output, size_t OutOffset, size_t Length) override
``` 
Encrypt/Decrypt an array of bytes with offset and length parameters

## Links
* [The Skein Hash Function](https://www.schneier.com/academic/paperfiles/skein1.3.pdf) Family Skein V1.1. 
* [NIST Round 3](https://www.schneier.com/academic/paperfiles/skein-1.3-modifications.pdf) Tweak Description. 
* [Skein Provable Security](https://www.schneier.com/academic/paperfiles/skein-proofs.pdf) Support for the Skein Hash Family. 
* [NIST SHA3 Third-Round Report](http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf) of the SHA-3 Cryptographic Hash Algorithm Competition>. 
* [FIPS 202](http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf): Permutation Based Hash and Extendable Output Functions 
* [NIST SP800-185](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf) SHA-3 Derived Functions. 
* [Team Keccak](https://keccak.team/index.html) Homepage
