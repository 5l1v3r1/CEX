# MCS: An Encrypt and Authenticate AEAD stream cipher implementation (Modular Cipher Stream)

## Description:
The MCS stream cipher is an Authenticate Encrypt and Additional Data (AEAD) authenticated cipher. 
MCS is an online cipher, meaning it can stream data of any size, without needing to know the data size in advance. 
It also has provable security, dependant upon the block cipher used by the mode. 
MCS first encrypts the plaintext using a Big-Endian counter mode (CTR), then processes that cipher-text using a MAC function for data authentication. 
When each transform encryption call is completed, the MAC code is generated and appended to the output vector automatically. 
Decryption performs these steps in reverse, processing the cipher-text bytes through the MAC function, and if authentication succeeds, then decrypting the data to plain-text. 
During decryption, if the MAC codes do not match, a CryptoAuthenticationFailure exception error is thrown, this is checked before the cipher-text is decrypted.

The encryption and decryption functions of the MCS mode can be multi-threaded. This is achieved by processing multiple blocks of message input independently across threads. 
The MCS stream cipher also leverages SIMD instructions to 'double parallelize' those segments. An input block assigned to a thread uses SIMD instructions to decrypt/encrypt blocks in parallel, depending on which framework is runtime available, AVX, AVX2, or AVX512 SIMD instructions. 
Input blocks equal to, or divisble by the ParallelBlockSize() are processed in parallel on supported systems. The cipher transform is parallelizable, however the authentication pass, is processed sequentially.

## Implementation Notes
* Supported key sizes are 32, 64, and 128 bytes (256, 512, and 1024 bits). 
* The required Nonce size is 16 bytes (128 bits). 
* The ISymmetricKey info value can be used as a cipher tweak to create a unique ciphertext and MAC output. 
* The ciphers Initialize function can use either a SymmetricKey, or an encrypted SymmetricSecureKey key container. 
* The internal block input-size is fixed at 16 bytes wide (128 bits). 
* This cipher is capable of authentication by setting the constructors StreamAuthenticators enumeration to Poly1305, or one of the HMAC or KMAC options. 
* In authentication mode, during encryption the MAC code is automatically appended to the output cipher-text, during decryption, this MAC code is checked and authentication failure will generate a CryptoAuthenticationFailure exception. 
* If authentication is enabled, the cipher and MAC keys are generated by passing the input cipher-key through an instance of cSHAKE, this will yield a different cipher-text output from non-authenticated modes. 
* In authenticated mode, the internal keys generated by cSHAKE will be unique with each MAC generator, each authentication option should be considered a seperate and distinct variant of the cipher, for example, MCS-RHX512-SHAKE512 or MCS-SHX512-HMAC512 
* The Info string is optional, but can be used to create a tweakable cipher, this can be used for adding additional key material, or using a second key to restrict decryption to a domain based system. 
* In the extended ciphers, permutation rounds are fixed 22, 30, and 38 when using the Rijndael cipher, or 40, 48, and 64 with the Serpent based cipher, for 256, 512, and 1024-bit keys; standard variants use the fixed standard round assignments. 
* Authentication using Poly1305, HMAC, or KMAC, can be invoked by setting the StreamAuthenticators parameter in the constructor, when set to None, authentication is disabled. 
* The class functions are virtual, and can be accessed from an IStreamCipher instance. 
* The transformation methods can not be called until the Initialize(ISymmetricKey) function has been called. 
* Encryption can both be pipelined (AVX, AVX2, or AVX512), and multi-threaded with any even number of threads, the configuration can be modified using the ParallelProfile() accessor function. 
* If the system supports Parallel processing, and ParallelProfile().IsParallel() is set to true; passing an input block of ParallelBlockSize() to the transform will be auto-parallelized. 
* The ParallelProfile().ParallelThreadsMax() property is used as the thread count in the parallel loop; it defaults to the maximum number of available virtual cores, but is user-assignable, and must be an even number no greater than the number of processer cores on the system. 
* ParallelProfile().ParallelBlockSize() is calculated automatically based on processor(s) cache size but can be user defined, but must be evenly divisible by ParallelProfile().ParallelMinimumSize(). 
* The ParallelBlockSize(), IsParallel(), and ParallelThreadsMax() accessors, can be changed through the ParallelProfile() property, but this has been auto-calculated based on the systems hardware, modifications are not recommended 

## Example
```cpp
#include "MCS.h"

// Encrypt an array of bytes
SymmetricKey kp(Key, Nonce);
// initialize the Rijndael cipher with the SHAKE-256 key-schedule extension
MCS cipher(BlockCiphers::RHXS256, StreamAuthenticators::KMAC256);
// mac code is appended to the cipher-text stream in authentication mode
cipher.Initialize(true, kp);
cipher.Transform(Input, InOffset, Output, OutOffset, Length);

// Decrypt and authenticate an array: 
SymmetricKey kp(Key, Nonce);
MCS cipher(BlockCiphers::RHXS256, StreamAuthenticators::KMAC256);
// initialize for decryption
cipher.Initialize(false, kp);

// decrypt the ciphertext and catch authentication failures
try
{
    cipher.Transform(Input, InOffset, Output, OutOffset, Length);
}
catch (CryptoAuthenticationFailure)
{
    // authentication has failed, do something...
}
```
       
## Public Member Functions
```cpp
MCS(const MCS&)=delete
 ```
Copy constructor: copy is restricted, this function has been deleted

```cpp
MCS& operator=(const MCS&)=delete
```
Copy operator: copy is restricted, this function has been deleted

```cpp
MCS(BlockCiphers CipherType=BlockCiphers::RHXH256, StreamAuthenticators AuthenticatorType=StreamAuthenticators::KMAC256)
``` 
Initialize the Cipher Mode using a block cipher type name and optional authentication MAC

```cpp
~MCS() override
``` 
Destructor: finalize this class

```cpp
const StreamCiphers Enumeral() override
``` 
Read Only: The stream ciphers enumeration type name

```cpp
const bool IsAuthenticator() override
```
Read Only: The cipher has authentication enabled

```cpp
const bool IsEncryption() override
``` 
Read Only: The cipher has been initialized for encryption

```cpp
const bool IsInitialized() override
``` 
Read Only: The cipher is ready to transform data

```cpp
const bool IsParallel() override
``` 
Read Only: Processor parallelization availability

```cpp
const std::vector<SymmetricKeySize> &LegalKeySizes() override
``` 
Read Only: Array of SymmetricKeySize containers, containing legal cipher input key sizes

```cpp
const std::string Name() override
``` 
Read Only: The stream ciphers formal implementation name

```cpp
const size_t ParallelBlockSize() override
``` 
Read Only: Parallel block size; the byte-size of the input/output data arrays passed to a transform that trigger parallel processing

```cpp
ParallelOptions &ParallelProfile() override
``` 
Read/Write: Parallel and SIMD capability flags and recommended sizes

```cpp
const std::vector<byte> Tag() override
``` 
Read Only: The current standard-vector MAC tag value

```cpp
const void Tag (SecureVector<byte> &Output) override
```
Copy the MAC tag to a secure-vector

```cpp
const size_t TagSize() override
``` 
Read Only: The legal tag length in bytes

```cpp
void Initialize(bool Encryption, ISymmetricKey &Parameters) override
``` 
Initialize the cipher with an ISymmetricKey key container

```cpp
void ParallelMaxDegree(size_t Degree) override
``` 
Set the maximum number of threads allocated when using multi-threaded processing

```cpp
void SetAssociatedData(const std::vector<byte> &Input, const size_t Offset, const size_t Length) override
``` 
Add additional data to the authentication generator

```cpp
void Transform(const std::vector<byte> &Input, size_t InOffset, std::vector<byte> &Output, size_t OutOffset, size_t Length) override
``` 
Encrypt/Decrypt an array of bytes with offset and length parameters

## Links
* NIST AES [Fips 197](http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf)
* Serpent [Specification](http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf)
* [Fips-202](http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf): The SHA-3 Standard 
* [SP800-185](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf): SHA-3 Derived Functions 
* [RFC 2104](http://tools.ietf.org/html/rfc2104): HMAC: Keyed-Hashing for Message Authentication. 
* [Fips 198-1](http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf): The Keyed-Hash Message Authentication Code (HMAC). 
* [Fips 180-4](http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf): Secure Hash Standard (SHS)
