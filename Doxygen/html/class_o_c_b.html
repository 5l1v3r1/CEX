<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>CEX++: OCB Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cexlogo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CEX++
   &#160;<span id="projectnumber">1.0.0.5</span>
   </div>
   <div id="projectbrief">The CEX Cryptographic Library in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_o_c_b-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OCB Class Reference<div class="ingroups"><a class="el" href="group___c_e_x.html">CEX</a> &raquo; <a class="el" href="group___cipher.html">Cipher</a> &raquo; <a class="el" href="group___symmetric.html">Symmetric</a> &raquo; <a class="el" href="group___block.html">Block</a> &raquo; <a class="el" href="group___mode.html">Mode</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An Offset CodeBook Authenticated Block Cipher Mode  
 <a href="class_o_c_b.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_o_c_b_8h_source.html">OCB.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OCB:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_c_b.png" usemap="#OCB_map" alt=""/>
  <map id="OCB_map" name="OCB_map">
<area href="class_i_aead_mode.html" title="An AEAD Cipher Mode virtual interface class. " alt="IAeadMode" shape="rect" coords="0,56,85,80"/>
<area href="class_i_cipher_mode.html" title="Block Cipher standard Mode virtual interface class. " alt="ICipherMode" shape="rect" coords="0,0,85,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ba7659bd9baeac752c802074a84513e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a6ba7659bd9baeac752c802074a84513e">OCB</a> (const <a class="el" href="class_o_c_b.html">OCB</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6ba7659bd9baeac752c802074a84513e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="#a6ba7659bd9baeac752c802074a84513e">More...</a><br /></td></tr>
<tr class="separator:a6ba7659bd9baeac752c802074a84513e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaeb46c7bd480301d9da165fba39617a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_c_b.html">OCB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#afaeb46c7bd480301d9da165fba39617a">operator=</a> (const <a class="el" href="class_o_c_b.html">OCB</a> &amp;)=delete</td></tr>
<tr class="memdesc:afaeb46c7bd480301d9da165fba39617a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="#afaeb46c7bd480301d9da165fba39617a">More...</a><br /></td></tr>
<tr class="separator:afaeb46c7bd480301d9da165fba39617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f546b1158a30108acbd24b038ea6e35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a5f546b1158a30108acbd24b038ea6e35">OCB</a> ()=delete</td></tr>
<tr class="memdesc:a5f546b1158a30108acbd24b038ea6e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor: default is restricted, this function has been deleted  <a href="#a5f546b1158a30108acbd24b038ea6e35">More...</a><br /></td></tr>
<tr class="separator:a5f546b1158a30108acbd24b038ea6e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9f2577bcd8d1e2454e84b1697c410b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a5b9f2577bcd8d1e2454e84b1697c410b">OCB</a> (<a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a> <a class="el" href="class_o_c_b.html#afd829803c32eb77aee606ad892081794">CipherType</a>)</td></tr>
<tr class="memdesc:a5b9f2577bcd8d1e2454e84b1697c410b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Cipher Mode using a block cipher type name  <a href="#a5b9f2577bcd8d1e2454e84b1697c410b">More...</a><br /></td></tr>
<tr class="separator:a5b9f2577bcd8d1e2454e84b1697c410b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9056aa777b1328aa340e67b1beed24ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a9056aa777b1328aa340e67b1beed24ba">OCB</a> (<a class="el" href="class_i_block_cipher.html">IBlockCipher</a> *Cipher)</td></tr>
<tr class="memdesc:a9056aa777b1328aa340e67b1beed24ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Cipher Mode using a block cipher instance  <a href="#a9056aa777b1328aa340e67b1beed24ba">More...</a><br /></td></tr>
<tr class="separator:a9056aa777b1328aa340e67b1beed24ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132660d42f0bc041399f32aa0beb9e4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a132660d42f0bc041399f32aa0beb9e4f">~OCB</a> () override</td></tr>
<tr class="memdesc:a132660d42f0bc041399f32aa0beb9e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="#a132660d42f0bc041399f32aa0beb9e4f">More...</a><br /></td></tr>
<tr class="separator:a132660d42f0bc041399f32aa0beb9e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ee69258e82479618df2dcb01ec3c92"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#aa4ee69258e82479618df2dcb01ec3c92">AutoIncrement</a> () override</td></tr>
<tr class="memdesc:aa4ee69258e82479618df2dcb01ec3c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/Write: Enable auto-incrementing of the input nonce, each time the Finalize method is called.  <a href="#aa4ee69258e82479618df2dcb01ec3c92">More...</a><br /></td></tr>
<tr class="separator:aa4ee69258e82479618df2dcb01ec3c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae395c7e893e5e3a1e174fe456a02656c"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#ae395c7e893e5e3a1e174fe456a02656c">BlockSize</a> () override</td></tr>
<tr class="memdesc:ae395c7e893e5e3a1e174fe456a02656c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Block size of internal cipher in bytes  <a href="#ae395c7e893e5e3a1e174fe456a02656c">More...</a><br /></td></tr>
<tr class="separator:ae395c7e893e5e3a1e174fe456a02656c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd829803c32eb77aee606ad892081794"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#afd829803c32eb77aee606ad892081794">CipherType</a> () override</td></tr>
<tr class="memdesc:afd829803c32eb77aee606ad892081794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The block ciphers formal type name  <a href="#afd829803c32eb77aee606ad892081794">More...</a><br /></td></tr>
<tr class="separator:afd829803c32eb77aee606ad892081794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66326a91ecc996cdf8b7ef2cc49d46f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_block_cipher.html">IBlockCipher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#ab66326a91ecc996cdf8b7ef2cc49d46f">Engine</a> () override</td></tr>
<tr class="memdesc:ab66326a91ecc996cdf8b7ef2cc49d46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The underlying Block Cipher instance  <a href="#ab66326a91ecc996cdf8b7ef2cc49d46f">More...</a><br /></td></tr>
<tr class="separator:ab66326a91ecc996cdf8b7ef2cc49d46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755b6da31aa40852e950fcc848c66ab5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___enumeration.html#ga1d4ccc36db403dcb914cd7c4bac557a1">CipherModes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a755b6da31aa40852e950fcc848c66ab5">Enumeral</a> () override</td></tr>
<tr class="memdesc:a755b6da31aa40852e950fcc848c66ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The Cipher Modes enumeration type name  <a href="#a755b6da31aa40852e950fcc848c66ab5">More...</a><br /></td></tr>
<tr class="separator:a755b6da31aa40852e950fcc848c66ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1dcfb0ee25a1e21b9dedcee5e5a3d8"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a7a1dcfb0ee25a1e21b9dedcee5e5a3d8">IsEncryption</a> () override</td></tr>
<tr class="memdesc:a7a1dcfb0ee25a1e21b9dedcee5e5a3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: True if initialized for encryption, False for decryption  <a href="#a7a1dcfb0ee25a1e21b9dedcee5e5a3d8">More...</a><br /></td></tr>
<tr class="separator:a7a1dcfb0ee25a1e21b9dedcee5e5a3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac054ef51c8dae24d1c9c12e8f8e3d042"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#ac054ef51c8dae24d1c9c12e8f8e3d042">IsInitialized</a> () override</td></tr>
<tr class="memdesc:ac054ef51c8dae24d1c9c12e8f8e3d042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The Block Cipher is ready to transform data  <a href="#ac054ef51c8dae24d1c9c12e8f8e3d042">More...</a><br /></td></tr>
<tr class="separator:ac054ef51c8dae24d1c9c12e8f8e3d042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2b86580a1b14267e90bbf6c6d9c152"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#add2b86580a1b14267e90bbf6c6d9c152">IsParallel</a> () override</td></tr>
<tr class="memdesc:add2b86580a1b14267e90bbf6c6d9c152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Processor parallelization availability.  <a href="#add2b86580a1b14267e90bbf6c6d9c152">More...</a><br /></td></tr>
<tr class="separator:add2b86580a1b14267e90bbf6c6d9c152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea33c836608d1d17b1d373c82c44711"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a6ea33c836608d1d17b1d373c82c44711">LegalKeySizes</a> () override</td></tr>
<tr class="memdesc:a6ea33c836608d1d17b1d373c82c44711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Array of allowed cipher input key byte-sizes  <a href="#a6ea33c836608d1d17b1d373c82c44711">More...</a><br /></td></tr>
<tr class="separator:a6ea33c836608d1d17b1d373c82c44711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9206709c4e2a08fef8876696de604683"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a9206709c4e2a08fef8876696de604683">MaxTagSize</a> () override</td></tr>
<tr class="memdesc:a9206709c4e2a08fef8876696de604683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The maximum legal tag length in bytes  <a href="#a9206709c4e2a08fef8876696de604683">More...</a><br /></td></tr>
<tr class="separator:a9206709c4e2a08fef8876696de604683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec30189d6718f566a84724fe71013b6"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a0ec30189d6718f566a84724fe71013b6">MinTagSize</a> () override</td></tr>
<tr class="memdesc:a0ec30189d6718f566a84724fe71013b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The minimum legal tag length in bytes  <a href="#a0ec30189d6718f566a84724fe71013b6">More...</a><br /></td></tr>
<tr class="separator:a0ec30189d6718f566a84724fe71013b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544148125a612f6e7256f77dda442a83"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a544148125a612f6e7256f77dda442a83">Name</a> () override</td></tr>
<tr class="memdesc:a544148125a612f6e7256f77dda442a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The cipher mode name  <a href="#a544148125a612f6e7256f77dda442a83">More...</a><br /></td></tr>
<tr class="separator:a544148125a612f6e7256f77dda442a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64238d7750cee7890c9535159496b609"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a64238d7750cee7890c9535159496b609">ParallelBlockSize</a> () override</td></tr>
<tr class="memdesc:a64238d7750cee7890c9535159496b609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Parallel block size; the byte-size of the input/output data arrays passed to a transform that trigger parallel processing.  <a href="#a64238d7750cee7890c9535159496b609">More...</a><br /></td></tr>
<tr class="separator:a64238d7750cee7890c9535159496b609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae146062c1088efe0bc8657f89d44f5e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parallel_options.html">ParallelOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#ae146062c1088efe0bc8657f89d44f5e2">ParallelProfile</a> () override</td></tr>
<tr class="memdesc:ae146062c1088efe0bc8657f89d44f5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/Write: Parallel and SIMD capability flags and sizes  <a href="#ae146062c1088efe0bc8657f89d44f5e2">More...</a><br /></td></tr>
<tr class="separator:ae146062c1088efe0bc8657f89d44f5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acf50ea8253f911b05368f0b090ce3b"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a4acf50ea8253f911b05368f0b090ce3b">PreserveAD</a> () override</td></tr>
<tr class="memdesc:a4acf50ea8253f911b05368f0b090ce3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/Write: Persist a one-time associated data for the entire session.  <a href="#a4acf50ea8253f911b05368f0b090ce3b">More...</a><br /></td></tr>
<tr class="separator:a4acf50ea8253f911b05368f0b090ce3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52002791c389e332731fa1660db059e1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a52002791c389e332731fa1660db059e1">Tag</a> () override</td></tr>
<tr class="memdesc:a52002791c389e332731fa1660db059e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Returns the full finalized MAC code value array  <a href="#a52002791c389e332731fa1660db059e1">More...</a><br /></td></tr>
<tr class="separator:a52002791c389e332731fa1660db059e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678efdf36202c3ec42c8190afdf5eec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a678efdf36202c3ec42c8190afdf5eec7">DecryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:a678efdf36202c3ec42c8190afdf5eec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a single block of bytes.  <a href="#a678efdf36202c3ec42c8190afdf5eec7">More...</a><br /></td></tr>
<tr class="separator:a678efdf36202c3ec42c8190afdf5eec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161e0fb6814b78435959e97558a5119b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a161e0fb6814b78435959e97558a5119b">DecryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:a161e0fb6814b78435959e97558a5119b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a block of bytes with offset parameters.  <a href="#a161e0fb6814b78435959e97558a5119b">More...</a><br /></td></tr>
<tr class="separator:a161e0fb6814b78435959e97558a5119b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3eb0bd7c41ce21317044454b2b1f48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a2d3eb0bd7c41ce21317044454b2b1f48">EncryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:a2d3eb0bd7c41ce21317044454b2b1f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a single block of bytes.  <a href="#a2d3eb0bd7c41ce21317044454b2b1f48">More...</a><br /></td></tr>
<tr class="separator:a2d3eb0bd7c41ce21317044454b2b1f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9252f54700cb1975dfb07014eb8c8fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#ae9252f54700cb1975dfb07014eb8c8fe">EncryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:ae9252f54700cb1975dfb07014eb8c8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a block of bytes using offset parameters.  <a href="#ae9252f54700cb1975dfb07014eb8c8fe">More...</a><br /></td></tr>
<tr class="separator:ae9252f54700cb1975dfb07014eb8c8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf8fbbdc74ca035dd86ed58345bb91f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a8cf8fbbdc74ca035dd86ed58345bb91f">Finalize</a> (std::vector&lt; byte &gt; &amp;Output, const size_t Offset, const size_t Length) override</td></tr>
<tr class="memdesc:a8cf8fbbdc74ca035dd86ed58345bb91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the MAC code (Tag) and copy it to the Output array.  <a href="#a8cf8fbbdc74ca035dd86ed58345bb91f">More...</a><br /></td></tr>
<tr class="separator:a8cf8fbbdc74ca035dd86ed58345bb91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8140cac3aa9f34c0fd6ffecb35319e08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a8140cac3aa9f34c0fd6ffecb35319e08">Initialize</a> (bool Encryption, <a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;KeyParams) override</td></tr>
<tr class="memdesc:a8140cac3aa9f34c0fd6ffecb35319e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Cipher instance.  <a href="#a8140cac3aa9f34c0fd6ffecb35319e08">More...</a><br /></td></tr>
<tr class="separator:a8140cac3aa9f34c0fd6ffecb35319e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a0789889cb956c3638784b3f8cd596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#a79a0789889cb956c3638784b3f8cd596">ParallelMaxDegree</a> (size_t Degree) override</td></tr>
<tr class="memdesc:a79a0789889cb956c3638784b3f8cd596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of threads allocated when using multi-threaded processing.  <a href="#a79a0789889cb956c3638784b3f8cd596">More...</a><br /></td></tr>
<tr class="separator:a79a0789889cb956c3638784b3f8cd596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d5a8d62870879168a7d40dc3d48bf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#ad0d5a8d62870879168a7d40dc3d48bf2">SetAssociatedData</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t Offset, const size_t Length) override</td></tr>
<tr class="memdesc:ad0d5a8d62870879168a7d40dc3d48bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add additional data to the authentication generator.  <a href="#ad0d5a8d62870879168a7d40dc3d48bf2">More...</a><br /></td></tr>
<tr class="separator:ad0d5a8d62870879168a7d40dc3d48bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27021f2aaba536f1e9f639f532d91c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#ae27021f2aaba536f1e9f639f532d91c7">Transform</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset, const size_t Length) override</td></tr>
<tr class="memdesc:ae27021f2aaba536f1e9f639f532d91c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a length of bytes with offset parameters.  <a href="#ae27021f2aaba536f1e9f639f532d91c7">More...</a><br /></td></tr>
<tr class="separator:ae27021f2aaba536f1e9f639f532d91c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92ff46c16e890369355d9221ed6d9b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_c_b.html#ad92ff46c16e890369355d9221ed6d9b4">Verify</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t Offset, const size_t Length) override</td></tr>
<tr class="memdesc:ad92ff46c16e890369355d9221ed6d9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the internal MAC code and compare it with the tag contained in the Input array.  <a href="#ad92ff46c16e890369355d9221ed6d9b4">More...</a><br /></td></tr>
<tr class="separator:ad92ff46c16e890369355d9221ed6d9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_aead_mode"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_aead_mode')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_aead_mode.html">IAeadMode</a></td></tr>
<tr class="memitem:a42066de39d76426fbb7bba804b60667e inherit pub_methods_class_i_aead_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_aead_mode.html#a42066de39d76426fbb7bba804b60667e">IAeadMode</a> (const <a class="el" href="class_i_aead_mode.html">IAeadMode</a> &amp;)=delete</td></tr>
<tr class="memdesc:a42066de39d76426fbb7bba804b60667e inherit pub_methods_class_i_aead_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="#a42066de39d76426fbb7bba804b60667e">More...</a><br /></td></tr>
<tr class="separator:a42066de39d76426fbb7bba804b60667e inherit pub_methods_class_i_aead_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8b2abeb522b923e87faa0e956de47a inherit pub_methods_class_i_aead_mode"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_aead_mode.html">IAeadMode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_aead_mode.html#a0b8b2abeb522b923e87faa0e956de47a">operator=</a> (const <a class="el" href="class_i_aead_mode.html">IAeadMode</a> &amp;)=delete</td></tr>
<tr class="memdesc:a0b8b2abeb522b923e87faa0e956de47a inherit pub_methods_class_i_aead_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="#a0b8b2abeb522b923e87faa0e956de47a">More...</a><br /></td></tr>
<tr class="separator:a0b8b2abeb522b923e87faa0e956de47a inherit pub_methods_class_i_aead_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db2790e9218e806bd34046bf3aac04a inherit pub_methods_class_i_aead_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_aead_mode.html#a4db2790e9218e806bd34046bf3aac04a">IAeadMode</a> ()</td></tr>
<tr class="memdesc:a4db2790e9218e806bd34046bf3aac04a inherit pub_methods_class_i_aead_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the IAeadMode virtual interface class  <a href="#a4db2790e9218e806bd34046bf3aac04a">More...</a><br /></td></tr>
<tr class="separator:a4db2790e9218e806bd34046bf3aac04a inherit pub_methods_class_i_aead_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f02f52967fd0cdc00311f69ac0f239 inherit pub_methods_class_i_aead_mode"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_aead_mode.html#a26f02f52967fd0cdc00311f69ac0f239">~IAeadMode</a> () noexcept</td></tr>
<tr class="memdesc:a26f02f52967fd0cdc00311f69ac0f239 inherit pub_methods_class_i_aead_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="#a26f02f52967fd0cdc00311f69ac0f239">More...</a><br /></td></tr>
<tr class="separator:a26f02f52967fd0cdc00311f69ac0f239 inherit pub_methods_class_i_aead_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_cipher_mode"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_cipher_mode')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_cipher_mode.html">ICipherMode</a></td></tr>
<tr class="memitem:a947413f3a4cdd09c69c72bdd75c91c06 inherit pub_methods_class_i_cipher_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cipher_mode.html#a947413f3a4cdd09c69c72bdd75c91c06">ICipherMode</a> (const <a class="el" href="class_i_cipher_mode.html">ICipherMode</a> &amp;)=delete</td></tr>
<tr class="memdesc:a947413f3a4cdd09c69c72bdd75c91c06 inherit pub_methods_class_i_cipher_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="#a947413f3a4cdd09c69c72bdd75c91c06">More...</a><br /></td></tr>
<tr class="separator:a947413f3a4cdd09c69c72bdd75c91c06 inherit pub_methods_class_i_cipher_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6860aaea83eaa2fa194247d03971ba73 inherit pub_methods_class_i_cipher_mode"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_cipher_mode.html">ICipherMode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cipher_mode.html#a6860aaea83eaa2fa194247d03971ba73">operator=</a> (const <a class="el" href="class_i_cipher_mode.html">ICipherMode</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6860aaea83eaa2fa194247d03971ba73 inherit pub_methods_class_i_cipher_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="#a6860aaea83eaa2fa194247d03971ba73">More...</a><br /></td></tr>
<tr class="separator:a6860aaea83eaa2fa194247d03971ba73 inherit pub_methods_class_i_cipher_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283a39fde808aedfd73820c6ae0feda inherit pub_methods_class_i_cipher_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cipher_mode.html#aa283a39fde808aedfd73820c6ae0feda">ICipherMode</a> ()</td></tr>
<tr class="memdesc:aa283a39fde808aedfd73820c6ae0feda inherit pub_methods_class_i_cipher_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the ICipherMode virtual interface class  <a href="#aa283a39fde808aedfd73820c6ae0feda">More...</a><br /></td></tr>
<tr class="separator:aa283a39fde808aedfd73820c6ae0feda inherit pub_methods_class_i_cipher_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3ec68d89511d48a38aff60937f9e67 inherit pub_methods_class_i_cipher_mode"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cipher_mode.html#a3a3ec68d89511d48a38aff60937f9e67">~ICipherMode</a> () noexcept</td></tr>
<tr class="memdesc:a3a3ec68d89511d48a38aff60937f9e67 inherit pub_methods_class_i_cipher_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="#a3a3ec68d89511d48a38aff60937f9e67">More...</a><br /></td></tr>
<tr class="separator:a3a3ec68d89511d48a38aff60937f9e67 inherit pub_methods_class_i_cipher_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An Offset CodeBook Authenticated Block Cipher Mode </p>
<p>Encrypting a single block of bytes: </p><div class="fragment"><div class="line"><a class="code" href="class_o_c_b.html">OCB</a> cipher(BlockCiphers::Rijndael);</div>
<div class="line"><span class="comment">// initialize for encryption</span></div>
<div class="line">cipher.Initialize(<span class="keyword">true</span>, <a class="code" href="class_symmetric_key.html">SymmetricKey</a>(<a class="code" href="group___digest.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>, <a class="code" href="group___digest.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">Nonce</a>, [Info]));</div>
<div class="line"><span class="comment">// encrypt one block</span></div>
<div class="line"><span class="keywordtype">size_t</span> encLen = cipher.BlockSize();</div>
<div class="line">cipher.Transform(Input, 0, Output, 0, encLen);</div>
<div class="line"><span class="comment">// append the mac code to the output</span></div>
<div class="line">cipher.Finalize(Output, encLen);</div>
</div><!-- fragment --> <p>Decrypting a block of bytes: </p><div class="fragment"><div class="line"><a class="code" href="class_o_c_b.html">OCB</a> cipher(BlockCiphers::Rijndael);</div>
<div class="line"><span class="comment">// initialize for decryption</span></div>
<div class="line">cipher.Initialize(<span class="keyword">false</span>, <a class="code" href="class_symmetric_key.html">SymmetricKey</a>(<a class="code" href="group___digest.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>, <a class="code" href="group___digest.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">Nonce</a>, [Associated Data]));</div>
<div class="line"><span class="comment">// calculate offset; mac code should always be last block after ciphertext</span></div>
<div class="line"><span class="keywordtype">size_t</span> decLen = Input.size() - cipher.BlockSize();</div>
<div class="line"><span class="comment">// decrypt a block</span></div>
<div class="line">cipher.Transform(Input, 0, Output, 0, decLen);</div>
<div class="line"><span class="comment">// generate the internal mac code and compare it</span></div>
<div class="line"><span class="keywordflow">if</span> (!cipher.Verify(Input, decLen))</div>
<div class="line">    <span class="keywordflow">throw</span>;</div>
</div><!-- fragment --> <p><b>Overview:</b> </p>
<p>The OCB Cipher Mode is an Authenticate Encrypt and Additional Data (AEAD) authenticated mode. <br />
OCB is an online mode, meaning it can stream data of any size, without needing to know the data size in advance. <br />
It also has provable security, dependant on the block cipher used by the mode. <br />
OCB first XORs the plain-text into a checksum, which is used in the finalizer to create the MAC tag. <br />
A nonce is generated and XOR'd with the encrypted plain-text to create the cipher-text. <br />
Decryption performs these steps in reverse, creating a nonce and the cipher-text bytes through the decryption function, then adding the plain-text to a checksum. <br />
The Verify(Input, Offset) function can be used to compare the MAC code embedded in the cipher-text with the code generated during the decryption process. <br />
The Finalize(Output, Offset, Length) function writes the MAC code to an output stream in either encryption or decryption operation modes. </p>
<p><b>Description:</b> </p>
<p><em>Legend:</em> <br />
<b>C</b>=ciphertext, <b>P</b>=plaintext, <b>k</b>=key, <b>E</b>=encrypt, <b>D</b>=decrypt, <b>Mk</b>=keyed mac, <b>T</b>=mac code <br />
<em>Encryption</em> <br />
for i ...n (Ci = Ek(Pi), T = Mk(Ci)). CT = C||T. <br />
<em>Decryption</em> <br />
for i ...n (T = Mk(Ci), Pi = D(Ci)). PT = P||T.</p>
<p><b>Multi-Threading:</b> </p>
<p>The encryption and decryption functions of OCB mode can be multi-threaded. This is achieved by processing multiple blocks of message input independently across threads. <br />
The OCB parallel mode also leverages SIMD instructions to 'double parallelize' those segments. An input block assigned to a thread uses SIMD instructions to decrypt/encrypt 4 or 8 blocks in parallel per cycle, depending on which framework is runtime available, 128 or 256 SIMD instructions. <br />
Input blocks equal to, or divisble by the ParallelBlockSize() are processed in parallel on supported systems. Sequential processing is used when the system dows not support SIMD or has only one core, or a standard an input blockis less than the parallel block size.</p>
<p>Implementation Notes: </p><ul>
<li>
OCB is an AEAD authenticated mode, additional data such as packet header information can be added to the authentication process. </li>
<li>
Additional data can be added using the SetAssociatedData(Input, Offset, Length) call. </li>
<li>
Calling the Finalize(Output, Offset, Length) function writes the MAC code to the output array in either encryption or decryption operation mode. </li>
<li>
The Verify(Input, Offset, Length) function can be used to compare the MAC code embedded with the cipher-text to the internal MAC code generated after a Decryption cycle. </li>
<li>
Encryption and decryption can both be pipelined (SSE3-128 or AVX-256), and multi-threaded. </li>
<li>
If the system supports Parallel processing, and IsParallel() is set to true; passing an input block of ParallelBlockSize() to the transform will be auto parallelized. </li>
<li>
ParallelBlockSize() is calculated automatically based on the processor(s) L1 data cache size, this property can be user defined, and must be evenly divisible by ParallelMinimumSize(). </li>
<li>
The ParallelBlockSize() can be changed through the ParallelProfile() property </li>
<li>
Parallel block calculation ex. <code>ParallelBlockSize = N - (N % .ParallelMinimumSize);</code> </li>
</ul>
<p>Guiding Publications: </p><ol>
<li>
RFC 7253: The <a href="https://www.rfc-editor.org/rfc/pdfrfc/rfc7253.txt.pdf">OCB Authenticated-Encryption</a> Algorithm. </li>
<li>
The Software Performance of <a href="http://web.cs.ucdavis.edu/~rogaway/papers/ae.pdf">Authenticated-Encryption</a> Modes </li>
<li>
OCB <a href="http://web.cs.ucdavis.edu/~rogaway/ocb/ocb-faq.htm">FAQ</a> sheet. </li>
<li>
RFC 5116: <a href="https://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6ba7659bd9baeac752c802074a84513e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OCB::OCB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_c_b.html">OCB</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: copy is restricted, this function has been deleted </p>

</div>
</div>
<a class="anchor" id="a5f546b1158a30108acbd24b038ea6e35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OCB::OCB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor: default is restricted, this function has been deleted </p>

</div>
</div>
<a class="anchor" id="a5b9f2577bcd8d1e2454e84b1697c410b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OCB::OCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a>&#160;</td>
          <td class="paramname"><em>CipherType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the Cipher Mode using a block cipher type name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CipherType</td><td>The formal enumeration name of a block cipher</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception::CryptoCipherModeException</td><td>Thrown if an undefined block cipher type name is selected</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9056aa777b1328aa340e67b1beed24ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OCB::OCB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_block_cipher.html">IBlockCipher</a> *&#160;</td>
          <td class="paramname"><em>Cipher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the Cipher Mode using a block cipher instance </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cipher</td><td>The uninitialized block cipher instance; can not be null</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception::CryptoCipherModeException</td><td>Thrown if a null block cipher is used</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a132660d42f0bc041399f32aa0beb9e4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OCB::~OCB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor: finalize this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa4ee69258e82479618df2dcb01ec3c92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool &amp; OCB::AutoIncrement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read/Write: Enable auto-incrementing of the input nonce, each time the Finalize method is called. </p>
<p>Treats the Nonce value loaded during Initialize as a monotonic counter; incrementing the value by 1 and re-calculating the working set each time the cipher is finalized. If set to false, requires a re-key after each finalizer cycle.</p>

<p>Implements <a class="el" href="class_i_aead_mode.html#a945fb5422ae3a0b5821ca6ab7d4dcef1">IAeadMode</a>.</p>

</div>
</div>
<a class="anchor" id="ae395c7e893e5e3a1e174fe456a02656c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t OCB::BlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Block size of internal cipher in bytes </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a84a1320fbd9b6a9b077072acf66715ae">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="afd829803c32eb77aee606ad892081794"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a> OCB::CipherType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The block ciphers formal type name </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#af20a1f1a85bcc13ca03670b3cf94491a">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="a678efdf36202c3ec42c8190afdf5eec7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OCB::DecryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt a single block of bytes. </p>
<p>Decrypts one block of bytes beginning at a zero index. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of encrypted bytes</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of decrypted bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a3f0210d1097cf69bce107824d4dfa6da">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="a161e0fb6814b78435959e97558a5119b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OCB::DecryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt a block of bytes with offset parameters. </p>
<p>Decrypts one block of bytes using the designated offsets. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of encrypted bytes</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset within the input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of decrypted bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset within the output array</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a567520f345d7cbc99f356d357ac8086c">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="a2d3eb0bd7c41ce21317044454b2b1f48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OCB::EncryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt a single block of bytes. </p>
<p>Encrypts one block of bytes beginning at a zero index. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of plain text bytes</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of encrypted bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a2662c08e4ca778ca45496506e954af4a">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="ae9252f54700cb1975dfb07014eb8c8fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OCB::EncryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt a block of bytes using offset parameters. </p>
<p>Encrypts one block of bytes using the designated offsets. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of plain text bytes</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset within the input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of encrypted bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset within the output array</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a94d24281759928169f725b4943c02527">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="ab66326a91ecc996cdf8b7ef2cc49d46f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_block_cipher.html">IBlockCipher</a> * OCB::Engine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The underlying Block Cipher instance </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a11c630e63903b83044397876f6276ce9">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="a755b6da31aa40852e950fcc848c66ab5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___enumeration.html#ga1d4ccc36db403dcb914cd7c4bac557a1">CipherModes</a> OCB::Enumeral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The Cipher Modes enumeration type name </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a94f085c15d16a8f37192f302773e5bb2">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="a8cf8fbbdc74ca035dd86ed58345bb91f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OCB::Finalize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the MAC code (Tag) and copy it to the Output array. </p>
<p>The output array must be of sufficient length to receive the MAC code. This function finalizes the Encryption/Decryption cycle, all data must be processed before this function is called. Initialize(bool, ISymmetricKey) must be called before the cipher can be re-used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The output array that receives the authentication code</td></tr>
    <tr><td class="paramname">Offset</td><td>Starting offset within the output array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of MAC code bytes to write to the output array. </td></tr>
  </table>
  </dd>
</dl>
<p>Must be no greater then the MAC functions output size, and no less than the minimum Tag size of 12 bytes.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception::CryptoCipherModeException</td><td>Thrown if the cipher is not initialized, or output array is too small</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_aead_mode.html#a2681463ce01ff59ebc09672664dd0b02">IAeadMode</a>.</p>

</div>
</div>
<a class="anchor" id="a8140cac3aa9f34c0fd6ffecb35319e08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OCB::Initialize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Encryption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;&#160;</td>
          <td class="paramname"><em>KeyParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the Cipher instance. </p>
<p>The legal symmetric key and nonce sizes are contained in the LegalKeySizes() property. The Info parameter of the SymmetricKey can be used as the initial associated data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Encryption</td><td>True if cipher is used for encryption, false to decrypt</td></tr>
    <tr><td class="paramname">KeyParams</td><td>SymmetricKey containing the encryption Key and Nonce</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if a null or invalid Key/Nonce is used</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a03d0f798bf5001564d6d53df1ca4f5fb">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="a7a1dcfb0ee25a1e21b9dedcee5e5a3d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool OCB::IsEncryption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: True if initialized for encryption, False for decryption </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a6b9e5e05b83c6e84e6082d0b6334d470">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="ac054ef51c8dae24d1c9c12e8f8e3d042"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool OCB::IsInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The Block Cipher is ready to transform data </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a1b57c47c070538abb55e96e09e7ce5a2">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="add2b86580a1b14267e90bbf6c6d9c152"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool OCB::IsParallel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Processor parallelization availability. </p>
<p>Indicates whether parallel processing is available with this mode. If parallel capable, input/output data arrays passed to the transform must be ParallelBlockSize in bytes to trigger parallelization.</p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a7851dee20f03d50db63ea951c0ad697d">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="a6ea33c836608d1d17b1d373c82c44711"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp; OCB::LegalKeySizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Array of allowed cipher input key byte-sizes </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a530595c8040b12a19a21d14f840547ab">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="a9206709c4e2a08fef8876696de604683"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t OCB::MaxTagSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The maximum legal tag length in bytes </p>

<p>Implements <a class="el" href="class_i_aead_mode.html#a78b9f3137d60c26fd4a8a3776ee2880e">IAeadMode</a>.</p>

</div>
</div>
<a class="anchor" id="a0ec30189d6718f566a84724fe71013b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t OCB::MinTagSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The minimum legal tag length in bytes </p>

<p>Implements <a class="el" href="class_i_aead_mode.html#a139ce4df79d754b41c7eb62220bbb7f6">IAeadMode</a>.</p>

</div>
</div>
<a class="anchor" id="a544148125a612f6e7256f77dda442a83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string OCB::Name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The cipher mode name </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#af060eb48e27685b266b7526be3e5db9e">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="afaeb46c7bd480301d9da165fba39617a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_c_b.html">OCB</a>&amp; OCB::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_c_b.html">OCB</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator: copy is restricted, this function has been deleted </p>

</div>
</div>
<a class="anchor" id="a64238d7750cee7890c9535159496b609"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t OCB::ParallelBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Parallel block size; the byte-size of the input/output data arrays passed to a transform that trigger parallel processing. </p>
<p>This value can be changed through the ParallelProfile class.</p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#ae39d8aaa19ad006669bfbc593b904c15">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="a79a0789889cb956c3638784b3f8cd596"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OCB::ParallelMaxDegree </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of threads allocated when using multi-threaded processing. </p>
<p>When set to zero, thread count is set automatically. If set to 1, sets IsParallel() to false and runs in sequential mode. Thread count must be an even number, and not exceed the number of processor cores.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Degree</td><td>The desired number of threads</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a9985b6851274ada2137ea7496a91671d">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="ae146062c1088efe0bc8657f89d44f5e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parallel_options.html">ParallelOptions</a> &amp; OCB::ParallelProfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read/Write: Parallel and SIMD capability flags and sizes </p>
<p>The maximum number of threads allocated when using multi-threaded processing can be set with the ParallelMaxDegree() property. The ParallelBlockSize() property is auto-calculated, but can be changed; the value must be evenly divisible by ParallelMinimumSize(). Changes to these values must be made before the Initialize(SymmetricKey) function is called.</p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#ae0c45109dd147c8d8db02fb02561379f">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="a4acf50ea8253f911b05368f0b090ce3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool &amp; OCB::PreserveAD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read/Write: Persist a one-time associated data for the entire session. </p>
<p>Allows the use of a single SetAssociatedData() call to apply the MAC data to all segments. Finalize and Verify can be called multiple times, applying the initial associated data to each finalize cycle.</p>

<p>Implements <a class="el" href="class_i_aead_mode.html#a99fa6d52d3cb43703d3c0bc0f9adb6c1">IAeadMode</a>.</p>

</div>
</div>
<a class="anchor" id="ad0d5a8d62870879168a7d40dc3d48bf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OCB::SetAssociatedData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add additional data to the authentication generator. </p>
<p>Must be called after Initialize(bool, ISymmetricKey), and before any processing of plaintext or ciphertext input. This function can only be called once per each initialization/finalization cycle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to process</td></tr>
    <tr><td class="paramname">Offset</td><td>Starting offset within the input array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception::CryptoCipherModeException</td><td>Thrown if state has been processed</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_aead_mode.html#ae0a604354f048e6dbbb8f6bc34d24d88">IAeadMode</a>.</p>

</div>
</div>
<a class="anchor" id="a52002791c389e332731fa1660db059e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; byte &gt; OCB::Tag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Returns the full finalized MAC code value array </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception::CryptoCipherModeException</td><td>Thrown if the cipher has not been finalized</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_aead_mode.html#ad19fd97a58a68c9f8f02bc366135abf8">IAeadMode</a>.</p>

</div>
</div>
<a class="anchor" id="ae27021f2aaba536f1e9f639f532d91c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OCB::Transform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a length of bytes with offset parameters. </p>
<p>This method processes a specified length of bytes, utilizing offsets incremented by the caller. If IsParallel() is set to true, and the length is at least ParallelBlockSize(), the transform is run in parallel processing mode. To disable parallel processing, set the ParallelOptions().IsParallel() property to false. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset within the input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset within the output array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to transform</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a26e54aafa8eb9259ed291eb22009874d">ICipherMode</a>.</p>

</div>
</div>
<a class="anchor" id="ad92ff46c16e890369355d9221ed6d9b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OCB::Verify </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the internal MAC code and compare it with the tag contained in the Input array. </p>
<p>This function finalizes the Decryption cycle and generates the MAC tag. The cipher must be set for Decryption and the cipher-text bytes fully processed before calling this function. Verify can be called in place of a Finalize(Output, Offset, Length) call, or after finalization. Initialize(bool, ISymmetricKey) must be called before the cipher can be re-used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array containing the expected authentication code</td></tr>
    <tr><td class="paramname">Offset</td><td>Starting offset within the input array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to compare. </td></tr>
  </table>
  </dd>
</dl>
<p>Must be no greater then the MAC functions output size, and no less than the MinTagSize() size.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns false if the MAC code does not match</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception::CryptoCipherModeException</td><td>Thrown if the cipher is not initialized for decryption</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_aead_mode.html#affc499278bec892d22da47a3d7905527">IAeadMode</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>CEX/<a class="el" href="_documentation_8h_source.html">Documentation.h</a></li>
<li>CEX/<a class="el" href="_o_c_b_8h_source.html">OCB.h</a></li>
<li>CEX/OCB.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
