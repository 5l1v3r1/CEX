<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CEX++: BCG Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="dragon13sm.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CEX++
   &#160;<span id="projectnumber">1.0.0.7</span>
   </div>
   <div id="projectbrief">The CEX Cryptographic Library in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_b_c_g-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BCG Class Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group___c_e_x.html">CEX</a> &raquo; <a class="el" href="group___drbg.html">Drbg</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An implementation of a Block cipher Counter mode Generator DRBG  
 <a href="class_b_c_g.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_b_c_g_8h_source.html">BCG.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BCG:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_b_c_g.png" usemap="#BCG_map" alt=""/>
  <map id="BCG_map" name="BCG_map">
<area href="class_drbg_base.html" title="The KDF base class; this is not an operable class " alt="DrbgBase" shape="rect" coords="0,56,68,80"/>
<area href="class_i_drbg.html" title="Deterministic Random Byte Generator (DRBG) interface class " alt="IDrbg" shape="rect" coords="0,0,68,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab02d1ba865322337634440c5788b49bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#ab02d1ba865322337634440c5788b49bb">BCG</a> (const <a class="el" href="class_b_c_g.html">BCG</a> &amp;)=delete</td></tr>
<tr class="memdesc:ab02d1ba865322337634440c5788b49bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="#ab02d1ba865322337634440c5788b49bb">More...</a><br /></td></tr>
<tr class="separator:ab02d1ba865322337634440c5788b49bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f54c233e2973574100786381aeaeb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_c_g.html">BCG</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#aa1f54c233e2973574100786381aeaeb3">operator=</a> (const <a class="el" href="class_b_c_g.html">BCG</a> &amp;)=delete</td></tr>
<tr class="memdesc:aa1f54c233e2973574100786381aeaeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="#aa1f54c233e2973574100786381aeaeb3">More...</a><br /></td></tr>
<tr class="separator:aa1f54c233e2973574100786381aeaeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27609a237f77349c4ffd99410abc46aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a27609a237f77349c4ffd99410abc46aa">BCG</a> (<a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a> CipherType=BlockCiphers::AES, <a class="el" href="group___enumeration.html#ga1ec0d2ca9981dcdfec5108ea9c38a9d0">Providers</a> ProviderType=<a class="el" href="group___enumeration.html#gga1ec0d2ca9981dcdfec5108ea9c38a9d0a6adf97f83acf6453d4a6a4b1070f3754">Providers::None</a>, bool Parallel=false)</td></tr>
<tr class="memdesc:a27609a237f77349c4ffd99410abc46aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate the class using a block cipher type-name, an optional entropy source type, and optional kdf hash-engine  <a href="#a27609a237f77349c4ffd99410abc46aa">More...</a><br /></td></tr>
<tr class="separator:a27609a237f77349c4ffd99410abc46aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ca52d80afc0b0da610edae3a625d1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#ad2ca52d80afc0b0da610edae3a625d1c">BCG</a> (<a class="el" href="class_i_block_cipher.html">IBlockCipher</a> *Cipher, <a class="el" href="class_i_provider.html">IProvider</a> *Provider=nullptr, bool Parallel=false)</td></tr>
<tr class="memdesc:ad2ca52d80afc0b0da610edae3a625d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate the class using a block cipher instance and an optional entropy source  <a href="#ad2ca52d80afc0b0da610edae3a625d1c">More...</a><br /></td></tr>
<tr class="separator:ad2ca52d80afc0b0da610edae3a625d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157e4235d9bf823bc82f7ba4ce8e0b7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a157e4235d9bf823bc82f7ba4ce8e0b7c">~BCG</a> () override</td></tr>
<tr class="memdesc:a157e4235d9bf823bc82f7ba4ce8e0b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="#a157e4235d9bf823bc82f7ba4ce8e0b7c">More...</a><br /></td></tr>
<tr class="separator:a157e4235d9bf823bc82f7ba4ce8e0b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c4faf37476728b4d8f1b530d8afd29"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a92c4faf37476728b4d8f1b530d8afd29">DistributionCodeMax</a> ()</td></tr>
<tr class="memdesc:a92c4faf37476728b4d8f1b530d8afd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The maximum size of the distribution code in bytes.  <a href="#a92c4faf37476728b4d8f1b530d8afd29">More...</a><br /></td></tr>
<tr class="separator:a92c4faf37476728b4d8f1b530d8afd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ce1a986bf78705d34c264b387ab79e"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#ab9ce1a986bf78705d34c264b387ab79e">IsInitialized</a> () override</td></tr>
<tr class="memdesc:ab9ce1a986bf78705d34c264b387ab79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Generator is ready to produce random  <a href="#ab9ce1a986bf78705d34c264b387ab79e">More...</a><br /></td></tr>
<tr class="separator:ab9ce1a986bf78705d34c264b387ab79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc01c357c7dca150b4923147700cd29a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#adc01c357c7dca150b4923147700cd29a">IsParallel</a> ()</td></tr>
<tr class="memdesc:adc01c357c7dca150b4923147700cd29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Processor parallelization availability.  <a href="#adc01c357c7dca150b4923147700cd29a">More...</a><br /></td></tr>
<tr class="separator:adc01c357c7dca150b4923147700cd29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3499efaf56858f1c3c5b731deb4e0646"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a3499efaf56858f1c3c5b731deb4e0646">ParallelBlockSize</a> ()</td></tr>
<tr class="memdesc:a3499efaf56858f1c3c5b731deb4e0646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Parallel block size; the byte-size of the requested output data array passed from the Generate function that triggers parallel processing.  <a href="#a3499efaf56858f1c3c5b731deb4e0646">More...</a><br /></td></tr>
<tr class="separator:a3499efaf56858f1c3c5b731deb4e0646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af778714a15e399de72765ecb84e5b375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parallel_options.html">ParallelOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#af778714a15e399de72765ecb84e5b375">ParallelProfile</a> ()</td></tr>
<tr class="memdesc:af778714a15e399de72765ecb84e5b375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/Write: Parallel and SIMD capability flags and sizes  <a href="#af778714a15e399de72765ecb84e5b375">More...</a><br /></td></tr>
<tr class="separator:af778714a15e399de72765ecb84e5b375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe43c4053a53f2babae478906cb9367"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#abbe43c4053a53f2babae478906cb9367">ReseedThreshold</a> () override</td></tr>
<tr class="memdesc:abbe43c4053a53f2babae478906cb9367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/Write: The maximum output generated between automatic internal seed generation  <a href="#abbe43c4053a53f2babae478906cb9367">More...</a><br /></td></tr>
<tr class="separator:abbe43c4053a53f2babae478906cb9367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668962a434759e4e2a30a397a04147f2"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a668962a434759e4e2a30a397a04147f2">SecurityStrength</a> () override</td></tr>
<tr class="memdesc:a668962a434759e4e2a30a397a04147f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The security strength in bits  <a href="#a668962a434759e4e2a30a397a04147f2">More...</a><br /></td></tr>
<tr class="separator:a668962a434759e4e2a30a397a04147f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa4cdd8a6f6d9d4843a7d179c73c476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a2fa4cdd8a6f6d9d4843a7d179c73c476">Generate</a> (std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:a2fa4cdd8a6f6d9d4843a7d179c73c476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a standard vector with pseudo-random bytes  <a href="#a2fa4cdd8a6f6d9d4843a7d179c73c476">More...</a><br /></td></tr>
<tr class="separator:a2fa4cdd8a6f6d9d4843a7d179c73c476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37fc9bcde42b7de43f178bdb9276352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#aa37fc9bcde42b7de43f178bdb9276352">Generate</a> (SecureVector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:aa37fc9bcde42b7de43f178bdb9276352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a secure vector with pseudo-random bytes  <a href="#aa37fc9bcde42b7de43f178bdb9276352">More...</a><br /></td></tr>
<tr class="separator:aa37fc9bcde42b7de43f178bdb9276352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b5644b28ffc75608a0a1b417973182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#ab8b5644b28ffc75608a0a1b417973182">Generate</a> (std::vector&lt; byte &gt; &amp;Output, size_t OutOffset, size_t Length) override</td></tr>
<tr class="memdesc:ab8b5644b28ffc75608a0a1b417973182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a standard vector with pseudo-random bytes using offset and length parameters  <a href="#ab8b5644b28ffc75608a0a1b417973182">More...</a><br /></td></tr>
<tr class="separator:ab8b5644b28ffc75608a0a1b417973182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccbb3b7eb133d9652ed83d9eb98beee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a2ccbb3b7eb133d9652ed83d9eb98beee">Generate</a> (SecureVector&lt; byte &gt; &amp;Output, size_t OutOffset, size_t Length) override</td></tr>
<tr class="memdesc:a2ccbb3b7eb133d9652ed83d9eb98beee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a secure vector with pseudo-random bytes using offset and length parameters  <a href="#a2ccbb3b7eb133d9652ed83d9eb98beee">More...</a><br /></td></tr>
<tr class="separator:a2ccbb3b7eb133d9652ed83d9eb98beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01113115b3afd7ee9ee8486c16a0f733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a01113115b3afd7ee9ee8486c16a0f733">Initialize</a> (<a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;KeyParams) override</td></tr>
<tr class="memdesc:a01113115b3afd7ee9ee8486c16a0f733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the generator with a SymmetricKey structure containing the key, and optional nonce, and info string.  <a href="#a01113115b3afd7ee9ee8486c16a0f733">More...</a><br /></td></tr>
<tr class="separator:a01113115b3afd7ee9ee8486c16a0f733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a059b32655cfbb8720f77927f3ae06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a14a059b32655cfbb8720f77927f3ae06">Initialize</a> (const std::vector&lt; byte &gt; &amp;<a class="el" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>)</td></tr>
<tr class="memdesc:a14a059b32655cfbb8720f77927f3ae06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the generator with a key.  <a href="#a14a059b32655cfbb8720f77927f3ae06">More...</a><br /></td></tr>
<tr class="separator:a14a059b32655cfbb8720f77927f3ae06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6562f1cbceabf18db54f3ef12efe3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#ada6562f1cbceabf18db54f3ef12efe3e">Initialize</a> (const std::vector&lt; byte &gt; &amp;<a class="el" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>, const std::vector&lt; byte &gt; &amp;<a class="el" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">Nonce</a>)</td></tr>
<tr class="memdesc:ada6562f1cbceabf18db54f3ef12efe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the generator with key and nonce arrays.  <a href="#ada6562f1cbceabf18db54f3ef12efe3e">More...</a><br /></td></tr>
<tr class="separator:ada6562f1cbceabf18db54f3ef12efe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409176c7dd4d5ddd3b172c5293a43db6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a409176c7dd4d5ddd3b172c5293a43db6">Initialize</a> (const std::vector&lt; byte &gt; &amp;<a class="el" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>, const std::vector&lt; byte &gt; &amp;<a class="el" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">Nonce</a>, const std::vector&lt; byte &gt; &amp;Info)</td></tr>
<tr class="memdesc:a409176c7dd4d5ddd3b172c5293a43db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the generator with a key, a nonce array, and an information string.  <a href="#a409176c7dd4d5ddd3b172c5293a43db6">More...</a><br /></td></tr>
<tr class="separator:a409176c7dd4d5ddd3b172c5293a43db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dc8e0545ff7351e8a7bfa97df35713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#a44dc8e0545ff7351e8a7bfa97df35713">ParallelMaxDegree</a> (size_t Degree)</td></tr>
<tr class="memdesc:a44dc8e0545ff7351e8a7bfa97df35713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of threads allocated when using multi-threaded processing.  <a href="#a44dc8e0545ff7351e8a7bfa97df35713">More...</a><br /></td></tr>
<tr class="separator:a44dc8e0545ff7351e8a7bfa97df35713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cfbf45c3c3c3ec7147c9cb23b3f1df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_c_g.html#ae4cfbf45c3c3c3ec7147c9cb23b3f1df">Update</a> (const std::vector&lt; byte &gt; &amp;<a class="el" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>) override</td></tr>
<tr class="memdesc:ae4cfbf45c3c3c3ec7147c9cb23b3f1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the generators seed value.  <a href="#ae4cfbf45c3c3c3ec7147c9cb23b3f1df">More...</a><br /></td></tr>
<tr class="separator:ae4cfbf45c3c3c3ec7147c9cb23b3f1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_drbg_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_drbg_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_drbg_base.html">DrbgBase</a></td></tr>
<tr class="memitem:a87e053da7226d2789afd5d043c3df719 inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#a87e053da7226d2789afd5d043c3df719">DrbgBase</a> (const <a class="el" href="class_drbg_base.html">DrbgBase</a> &amp;)=delete</td></tr>
<tr class="memdesc:a87e053da7226d2789afd5d043c3df719 inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="class_drbg_base.html#a87e053da7226d2789afd5d043c3df719">More...</a><br /></td></tr>
<tr class="separator:a87e053da7226d2789afd5d043c3df719 inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af181a5b777b0835df26230403ce333f0 inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_drbg_base.html">DrbgBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#af181a5b777b0835df26230403ce333f0">operator=</a> (const <a class="el" href="class_drbg_base.html">DrbgBase</a> &amp;)=delete</td></tr>
<tr class="memdesc:af181a5b777b0835df26230403ce333f0 inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="class_drbg_base.html#af181a5b777b0835df26230403ce333f0">More...</a><br /></td></tr>
<tr class="separator:af181a5b777b0835df26230403ce333f0 inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fbd4e92ee069c424409f095780c71e inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#ae8fbd4e92ee069c424409f095780c71e">DrbgBase</a> ()=delete</td></tr>
<tr class="memdesc:ae8fbd4e92ee069c424409f095780c71e inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor: the default constructor is restricted, this function has been deleted  <a href="class_drbg_base.html#ae8fbd4e92ee069c424409f095780c71e">More...</a><br /></td></tr>
<tr class="separator:ae8fbd4e92ee069c424409f095780c71e inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3cd62ec0984f430500e13724fb0561 inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#a8b3cd62ec0984f430500e13724fb0561">DrbgBase</a> (<a class="el" href="group___enumeration.html#ga8889084a5726d1d32ee6b0a6066cdaae">Drbgs</a> <a class="el" href="class_drbg_base.html#a6e70e47f63286b4d088aad61a9777ffa">Enumeral</a>, std::string &amp;<a class="el" href="class_drbg_base.html#ab738f0a3709ffe54d16c5bc9ff64914f">Name</a>, std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp;KeySizes, ulong MaxOutput, size_t MaxRequest, size_t MaxReseed)</td></tr>
<tr class="memdesc:a8b3cd62ec0984f430500e13724fb0561 inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: instantiate this class (private member)  <a href="class_drbg_base.html#a8b3cd62ec0984f430500e13724fb0561">More...</a><br /></td></tr>
<tr class="separator:a8b3cd62ec0984f430500e13724fb0561 inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318d9b55d09206b3a8081038eff47fbd inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#a318d9b55d09206b3a8081038eff47fbd">~DrbgBase</a> ()</td></tr>
<tr class="memdesc:a318d9b55d09206b3a8081038eff47fbd inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="class_drbg_base.html#a318d9b55d09206b3a8081038eff47fbd">More...</a><br /></td></tr>
<tr class="separator:a318d9b55d09206b3a8081038eff47fbd inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e70e47f63286b4d088aad61a9777ffa inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___enumeration.html#ga8889084a5726d1d32ee6b0a6066cdaae">Drbgs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#a6e70e47f63286b4d088aad61a9777ffa">Enumeral</a> () override</td></tr>
<tr class="memdesc:a6e70e47f63286b4d088aad61a9777ffa inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The prngs type name  <a href="class_drbg_base.html#a6e70e47f63286b4d088aad61a9777ffa">More...</a><br /></td></tr>
<tr class="separator:a6e70e47f63286b4d088aad61a9777ffa inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4300ef8d2b1d53a4a25e6d4536fc6ab3 inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#a4300ef8d2b1d53a4a25e6d4536fc6ab3">LegalKeySizes</a> () const override</td></tr>
<tr class="memdesc:a4300ef8d2b1d53a4a25e6d4536fc6ab3 inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Available KDF Key Sizes in SymmetricKeySize containers  <a href="class_drbg_base.html#a4300ef8d2b1d53a4a25e6d4536fc6ab3">More...</a><br /></td></tr>
<tr class="separator:a4300ef8d2b1d53a4a25e6d4536fc6ab3 inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dd8c5b533f536198d96a8819ed9c7e inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top">const ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#a91dd8c5b533f536198d96a8819ed9c7e">MaxOutputSize</a> () override</td></tr>
<tr class="memdesc:a91dd8c5b533f536198d96a8819ed9c7e inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The maximum number of bytes that can be generated with a generator instance  <a href="class_drbg_base.html#a91dd8c5b533f536198d96a8819ed9c7e">More...</a><br /></td></tr>
<tr class="separator:a91dd8c5b533f536198d96a8819ed9c7e inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc735bf3b0f131a1c3ffe25ebff448da inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#abc735bf3b0f131a1c3ffe25ebff448da">MaxRequestSize</a> () override</td></tr>
<tr class="memdesc:abc735bf3b0f131a1c3ffe25ebff448da inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The maximum number of bytes that can be generated in a single request  <a href="class_drbg_base.html#abc735bf3b0f131a1c3ffe25ebff448da">More...</a><br /></td></tr>
<tr class="separator:abc735bf3b0f131a1c3ffe25ebff448da inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae750bd31b66bd0ecbe439ff5d5b0322f inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#ae750bd31b66bd0ecbe439ff5d5b0322f">MaxReseedCount</a> () override</td></tr>
<tr class="memdesc:ae750bd31b66bd0ecbe439ff5d5b0322f inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The maximum number of times the generator can be reseeded  <a href="class_drbg_base.html#ae750bd31b66bd0ecbe439ff5d5b0322f">More...</a><br /></td></tr>
<tr class="separator:ae750bd31b66bd0ecbe439ff5d5b0322f inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab738f0a3709ffe54d16c5bc9ff64914f inherit pub_methods_class_drbg_base"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_drbg_base.html#ab738f0a3709ffe54d16c5bc9ff64914f">Name</a> () override</td></tr>
<tr class="memdesc:ab738f0a3709ffe54d16c5bc9ff64914f inherit pub_methods_class_drbg_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The KDF generators formal class name  <a href="class_drbg_base.html#ab738f0a3709ffe54d16c5bc9ff64914f">More...</a><br /></td></tr>
<tr class="separator:ab738f0a3709ffe54d16c5bc9ff64914f inherit pub_methods_class_drbg_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_drbg"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_drbg')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_drbg.html">IDrbg</a></td></tr>
<tr class="memitem:ab3a970f0af96f788b1e65a1426fa19d6 inherit pub_methods_class_i_drbg"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_drbg.html#ab3a970f0af96f788b1e65a1426fa19d6">IDrbg</a> (const <a class="el" href="class_i_drbg.html">IDrbg</a> &amp;)=delete</td></tr>
<tr class="memdesc:ab3a970f0af96f788b1e65a1426fa19d6 inherit pub_methods_class_i_drbg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="class_i_drbg.html#ab3a970f0af96f788b1e65a1426fa19d6">More...</a><br /></td></tr>
<tr class="separator:ab3a970f0af96f788b1e65a1426fa19d6 inherit pub_methods_class_i_drbg"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb908205abf9118566fcab276992b13 inherit pub_methods_class_i_drbg"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_drbg.html">IDrbg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_drbg.html#a7eb908205abf9118566fcab276992b13">operator=</a> (const <a class="el" href="class_i_drbg.html">IDrbg</a> &amp;)=delete</td></tr>
<tr class="memdesc:a7eb908205abf9118566fcab276992b13 inherit pub_methods_class_i_drbg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="class_i_drbg.html#a7eb908205abf9118566fcab276992b13">More...</a><br /></td></tr>
<tr class="separator:a7eb908205abf9118566fcab276992b13 inherit pub_methods_class_i_drbg"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac503c35c2cf1f5d2c224f7fe18e802f5 inherit pub_methods_class_i_drbg"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_drbg.html#ac503c35c2cf1f5d2c224f7fe18e802f5">IDrbg</a> ()</td></tr>
<tr class="memdesc:ac503c35c2cf1f5d2c224f7fe18e802f5 inherit pub_methods_class_i_drbg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: instantiate this class  <a href="class_i_drbg.html#ac503c35c2cf1f5d2c224f7fe18e802f5">More...</a><br /></td></tr>
<tr class="separator:ac503c35c2cf1f5d2c224f7fe18e802f5 inherit pub_methods_class_i_drbg"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa779f47ba55bd738b9702fb434ac8d34 inherit pub_methods_class_i_drbg"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_drbg.html#aa779f47ba55bd738b9702fb434ac8d34">~IDrbg</a> () noexcept</td></tr>
<tr class="memdesc:aa779f47ba55bd738b9702fb434ac8d34 inherit pub_methods_class_i_drbg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="class_i_drbg.html#aa779f47ba55bd738b9702fb434ac8d34">More...</a><br /></td></tr>
<tr class="separator:aa779f47ba55bd738b9702fb434ac8d34 inherit pub_methods_class_i_drbg"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of a Block cipher Counter mode Generator DRBG </p>
<p>Generate an array of pseudo-random bytes: </p><div class="fragment"><div class="line"><a class="code" href="class_b_c_g.html">BCG</a> rng(BlockCiphers::AES, Digests::SHA512, [<a class="code" href="group___enumeration.html#gga1ec0d2ca9981dcdfec5108ea9c38a9d0acbc6e9792f97c17c170caeb83895c44e">Providers::CSP</a>]);</div><div class="line"><span class="comment">// initialize</span></div><div class="line">rng.Initialize(<a class="code" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>, [<a class="code" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">Nonce</a>], [Info]);</div><div class="line"><span class="comment">// generate bytes</span></div><div class="line">rng.Generate(Output, [Offset], [Length]);</div></div><!-- fragment --> <p><b>Overview:</b> </p>
<p>The Counter mode generates a key-stream by encrypting successive values of an incrementing Big Endian ordered 128bit counter array (nonce). <br />
In parallel mode, the generators counter is increased by a number factored from the number of input blocks, allowing for a multi-threaded operation. <br />
The implementation is further parallelized by constructing a larger 'staggered' counter array, and processing large blocks using 128 or 256 SIMD instructions.</p>
<p><b>Description:</b> </p>
<p><em>Legend:</em> <br />
 <b>C</b>=pseudo-random, <b>K</b>=seed, <b>E</b>=encrypt <br />
<em>Generate</em> <br />
R0 ← IV. For 1 ≤ j ≤ t, Cj ← EK(Cj), C+1.</p>
<p><br />
 <b>Initialization and Update:</b> </p>
<p>The Initialize functions have three different parameter options: the Key which is the primary key, the Nonce used to initialize the internal counter, and the Info which is used in the Generate function. <br />
The Key value must be one of the LegalKeySizes() in length, and must be a secret and random value. <br />
The supported seed-sizes are calculated based on the block ciphers functions internal block size, and can vary depending on which cipher is used to instantiate the generator. <br />
The 16 byte (NonceSize) Nonce value is another secret value, used to initialize the counter to a non-zero random value. <br />
The Info parameter maps to the DistributionCode() property of an extended HX cipher, but is ignored when a standard cipher implementation is used. <br />
The DistributionCode is recommended, and for best security, should be secret, random, and equal in length to the DistributionCodeMax() property <br />
 The Update function uses the seed value to re-key the cipher via the internal key derivation function. <br />
The update functions Key parameter, must be a random seed value equal in length to the seed used to initialize the generator.</p>
<p><b>Multi-Threading:</b> </p>
<p>The transformation function in a CTR generator is not limited by a dependency chain; this mode can be both SIMD pipelined and multi-threaded. <br />
Output from the parallelized functions aligns with the output from a standard sequential CTR implementation processing an all zeroes input array. <br />
Parallelism is achieved by pre-calculating the counters positional offset over multiple 'chunks' of key-stream, which are then generated independently across threads. <br />
 The key stream generated by encrypting the counter array(s), is output as the source of pseudo-random.</p>
<p><b>Predictive Resistance:</b> </p>
<p>Predictive and backtracking resistance prevent an attacker who has gained knowledge of generator state at some time from predicting future or previous outputs from the generator. <br />
The optional resistance mechanism uses an entropy provider to add seed material to the generator, this new seed material is passed through a KDF2 generator along with the current state, the output is used to reseed the generator. <br />
The interval at which this reseeding occurs is 1mb by default, but can be set using the ReseedThreshold() property; once this number of bytes or greater has been generated, the seed is regenerated. <br />
 Predictive resistance is strongly recommended when producing large amounts of pseudo-random (10kb or greater).</p>
<p>Implementation Notes: </p><ul>
<li>
The class constructor can either be initialized with a block cipher instance, or using the block ciphers enumeration name. </li>
<li>
A block cipher or entropy provider instance created using the enumeration constructor, is automatically deleted when the class is destroyed. </li>
<li>
An entropy provider can be specified through the constructor, which provides a continues stream of entropy to the reseed and generate functions, this is stronly recommended with large (+10kb) outputs. </li>
<li>
The generator can be initialized with either a SymmetricKey key container class, or with a Key and optional inputs of Nonce and Info. </li>
<li>
The LegalKeySizes() property contains a list of supported seed sizes. </li>
<li>
The LegalKeySizes() property contains a list of the supported seed sizes; note that if using the Nonce parameter of the Initialize function the combined (Key + Nonce) must equal a legal size. </li>
<li>
There are three LegalKeySizes, minimum, recommended, and maximum, with BCG, the middle value is the recommended seed length for best security; i.e. LegalKeySizes()[1]. </li>
<li>
The Generate() methods can not be used until an Initialize() function has been called, and the generator is seeded. </li>
<li>
In a block cipher counter based generator, the encryption function can be both pipelined (SSE3-128 or AVX-256), and multi-threaded. </li>
<li>
If the system supports Parallel processing, IsParallel() is set to true; passing an output block of ParallelBlockSize() to the Generate function. </li>
<li>
The ParallelThreadsMax() property is the thread count in the parallel loop (pre-configured automatically); this must be either 1 (IsParallel=false), or an even number no greater than the number of processer cores on the system. </li>
<li>
ParallelBlockSize() is calculated automatically based on the processor(s) L1 data cache size, this property can be user defined, and must be evenly divisible by ParallelMinimumSize(). </li>
<li>
The ParallelBlockSize() can be changed through the ParallelProfile() property </li>
<li>
Parallel block calculation ex. <code>ParallelBlockSize = N - (N % .ParallelMinimumSize);</code> </li>
</ul>
<p>Guiding Publications: </p><ol>
<li>
NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>: Recommendation for the Entropy Sources Used for Random Bit Generation. </li>
<li>
NIST <a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Fips 140-2</a>: Security Requirments For Cryptographic Modules. </li>
<li>
NIST <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">SP800-22 1a</a>: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications. </li>
<li>
NIST <a href="http://eprint.iacr.org/2006/379.pdf">Security Bounds</a> for the Codebook-based: Deterministic Random Bit Generator. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab02d1ba865322337634440c5788b49bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02d1ba865322337634440c5788b49bb">&#9670;&nbsp;</a></span>BCG() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BCG::BCG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_c_g.html">BCG</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: copy is restricted, this function has been deleted </p>

</div>
</div>
<a id="a27609a237f77349c4ffd99410abc46aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27609a237f77349c4ffd99410abc46aa">&#9670;&nbsp;</a></span>BCG() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BCG::BCG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a>&#160;</td>
          <td class="paramname"><em>CipherType</em> = <code>BlockCiphers::AES</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumeration.html#ga1ec0d2ca9981dcdfec5108ea9c38a9d0">Providers</a>&#160;</td>
          <td class="paramname"><em>ProviderType</em> = <code><a class="el" href="group___enumeration.html#gga1ec0d2ca9981dcdfec5108ea9c38a9d0a6adf97f83acf6453d4a6a4b1070f3754">Providers::None</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiate the class using a block cipher type-name, an optional entropy source type, and optional kdf hash-engine </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CipherType</td><td>The block cipher type to instantiate as the primary generator. </td></tr>
  </table>
  </dd>
</dl>
<p>The primary pseudo-random function, the default is AES.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ProviderType</td><td>The random provider-type, used to instantiate the entropy source. </td></tr>
  </table>
  </dd>
</dl>
<p>Adding a random provider enables predictive resistance, and is recommended for large data (&gt;= 1MB).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parallel</td><td>Enable/disable the multi-threading engine; default is false. </td></tr>
  </table>
  </dd>
</dl>
<p>Parallel processing configuration can be tuned via the ParallelProfile accessor function.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if an unrecognized block cipher type name is used</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2ca52d80afc0b0da610edae3a625d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ca52d80afc0b0da610edae3a625d1c">&#9670;&nbsp;</a></span>BCG() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BCG::BCG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_block_cipher.html">IBlockCipher</a> *&#160;</td>
          <td class="paramname"><em>Cipher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_provider.html">IProvider</a> *&#160;</td>
          <td class="paramname"><em>Provider</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiate the class using a block cipher instance and an optional entropy source </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cipher</td><td>The block cipher instance, acting as the primary pseudo-random function</td></tr>
    <tr><td class="paramname">Provider</td><td>The [optional] entropy source, enabling predictive resistance; can be set to nullptr. </td></tr>
  </table>
  </dd>
</dl>
<p>Adding a random provider enables predictive resistance, and is strongly recommended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parallel</td><td>Enable/disable the multi-threading engine; default is false. </td></tr>
  </table>
  </dd>
</dl>
<p>Parallel processing configuration can be tuned via the ParallelProfile accessor function.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if a null block cipher is used</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a157e4235d9bf823bc82f7ba4ce8e0b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157e4235d9bf823bc82f7ba4ce8e0b7c">&#9670;&nbsp;</a></span>~BCG()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BCG::~BCG </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor: finalize this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a92c4faf37476728b4d8f1b530d8afd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c4faf37476728b4d8f1b530d8afd29">&#9670;&nbsp;</a></span>DistributionCodeMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t BCG::DistributionCodeMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Only: The maximum size of the distribution code in bytes. </p>
<p>The distribution code can be used as a secondary source of entropy (secret) in an HX ciphers HKDF key expansion function. For best security, the distribution code should be random, secret, and equal in size to this value.</p>

</div>
</div>
<a id="a2fa4cdd8a6f6d9d4843a7d179c73c476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa4cdd8a6f6d9d4843a7d179c73c476">&#9670;&nbsp;</a></span>Generate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BCG::Generate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a standard vector with pseudo-random bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The output standard vector to fill with random bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if the generator is not initialized, the output size is misaligned, the maximum request size is exceeded, or if the maximum reseed requests are exceeded</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_drbg.html#a871fd18ab7bdf5dd177dde83432d2696">IDrbg</a>.</p>

</div>
</div>
<a id="aa37fc9bcde42b7de43f178bdb9276352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37fc9bcde42b7de43f178bdb9276352">&#9670;&nbsp;</a></span>Generate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BCG::Generate </td>
          <td>(</td>
          <td class="paramtype">SecureVector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a secure vector with pseudo-random bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The output secure vector to fill with random bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if the generator is not initialized, the output size is misaligned, the maximum request size is exceeded, or if the maximum reseed requests are exceeded</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_drbg.html#a20b97d7d1c9d3e3e478d0d55fe8190ec">IDrbg</a>.</p>

</div>
</div>
<a id="ab8b5644b28ffc75608a0a1b417973182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b5644b28ffc75608a0a1b417973182">&#9670;&nbsp;</a></span>Generate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BCG::Generate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a standard vector with pseudo-random bytes using offset and length parameters </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The output standard vector to fill with random bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting position within the output array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to generate</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if the generator is not initialized, the output size is misaligned, the maximum request size is exceeded, or if the maximum reseed requests are exceeded</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_drbg.html#a7d423af67ac8967741b1843b43971f5e">IDrbg</a>.</p>

</div>
</div>
<a id="a2ccbb3b7eb133d9652ed83d9eb98beee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccbb3b7eb133d9652ed83d9eb98beee">&#9670;&nbsp;</a></span>Generate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BCG::Generate </td>
          <td>(</td>
          <td class="paramtype">SecureVector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a secure vector with pseudo-random bytes using offset and length parameters </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The output secure vector to fill with random bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting position within the output array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to generate</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if the generator is not initialized, the output size is misaligned, the maximum request size is exceeded, or if the maximum reseed requests are exceeded</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_drbg.html#a92ec2c9f208e752769ef1fa26885a537">IDrbg</a>.</p>

</div>
</div>
<a id="a01113115b3afd7ee9ee8486c16a0f733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01113115b3afd7ee9ee8486c16a0f733">&#9670;&nbsp;</a></span>Initialize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BCG::Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;&#160;</td>
          <td class="paramname"><em>KeyParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the generator with a SymmetricKey structure containing the key, and optional nonce, and info string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">KeyParams</td><td>The SymmetricKey containing the generators keying material</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if the seed is not a legal seed size</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_drbg.html#a2f4774cd3d6f777ac8a4434565bbb96c">IDrbg</a>.</p>

</div>
</div>
<a id="a14a059b32655cfbb8720f77927f3ae06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a059b32655cfbb8720f77927f3ae06">&#9670;&nbsp;</a></span>Initialize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BCG::Initialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the generator with a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>The primary key array used to seed the generator</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if the seed is not a legal seed size</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada6562f1cbceabf18db54f3ef12efe3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6562f1cbceabf18db54f3ef12efe3e">&#9670;&nbsp;</a></span>Initialize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BCG::Initialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nonce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the generator with key and nonce arrays. </p>
<p>The combined Key and Nonce length must equal a LegalSeedSize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>The primary key array used to seed the generator</td></tr>
    <tr><td class="paramname">Nonce</td><td>The nonce value containing an additional source of entropy</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if the seed is not a legal seed size</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409176c7dd4d5ddd3b172c5293a43db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409176c7dd4d5ddd3b172c5293a43db6">&#9670;&nbsp;</a></span>Initialize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BCG::Initialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nonce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the generator with a key, a nonce array, and an information string. </p>
<p>The combined Key and Nonce length must equal a LegalSeedSize. The Info parameter maps to an extended HX cipher DistributionCode property. For best security this value should be secret, random and DistributionCodeMax in length. If a standard cipher is used, the Info parameter is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>The primary key array used to seed the generator</td></tr>
    <tr><td class="paramname">Nonce</td><td>The nonce value used as an additional source of entropy</td></tr>
    <tr><td class="paramname">Info</td><td>The information string or nonce used to create a unique distribution or as a third source of entropy</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if the key is not a legal size</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9ce1a986bf78705d34c264b387ab79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ce1a986bf78705d34c264b387ab79e">&#9670;&nbsp;</a></span>IsInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool BCG::IsInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Generator is ready to produce random </p>

<p>Implements <a class="el" href="class_i_drbg.html#adbff51f7009375e91073451b2acbb4fd">IDrbg</a>.</p>

</div>
</div>
<a id="adc01c357c7dca150b4923147700cd29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc01c357c7dca150b4923147700cd29a">&#9670;&nbsp;</a></span>IsParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool BCG::IsParallel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Only: Processor parallelization availability. </p>
<p>Indicates whether parallel processing is available on this system. If parallel capable, the internal buffer is generated using multiple parallel streams.</p>

</div>
</div>
<a id="aa1f54c233e2973574100786381aeaeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f54c233e2973574100786381aeaeb3">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_c_g.html">BCG</a>&amp; BCG::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_c_g.html">BCG</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator: copy is restricted, this function has been deleted </p>

</div>
</div>
<a id="a3499efaf56858f1c3c5b731deb4e0646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3499efaf56858f1c3c5b731deb4e0646">&#9670;&nbsp;</a></span>ParallelBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t BCG::ParallelBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Only: Parallel block size; the byte-size of the requested output data array passed from the Generate function that triggers parallel processing. </p>
<p>This value can be changed through the ParallelProfile class.</p>

</div>
</div>
<a id="a44dc8e0545ff7351e8a7bfa97df35713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44dc8e0545ff7351e8a7bfa97df35713">&#9670;&nbsp;</a></span>ParallelMaxDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BCG::ParallelMaxDegree </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of threads allocated when using multi-threaded processing. </p>
<p>When set to zero, thread count is set automatically. If set to 1, runs in sequential mode. Thread count must be an even number, and not exceed the number of processor cores (times 2 for hyperthreading).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Degree</td><td>The desired number of threads</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if an invalid degree setting is used</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af778714a15e399de72765ecb84e5b375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af778714a15e399de72765ecb84e5b375">&#9670;&nbsp;</a></span>ParallelProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parallel_options.html">ParallelOptions</a> &amp; BCG::ParallelProfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read/Write: Parallel and SIMD capability flags and sizes </p>
<p>The maximum number of threads allocated when using multi-threaded processing can be set with the ParallelMaxDegree() property. The ParallelBlockSize() property is auto-calculated, but can be changed; the value must be evenly divisible by ParallelMinimumSize(). Changes to these values must be made before the Initialize(SymmetricKey) function is called.</p>

</div>
</div>
<a id="abbe43c4053a53f2babae478906cb9367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe43c4053a53f2babae478906cb9367">&#9670;&nbsp;</a></span>ReseedThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t &amp; BCG::ReseedThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read/Write: The maximum output generated between automatic internal seed generation </p>

<p>Implements <a class="el" href="class_i_drbg.html#aa09c6f5d57f335e4466854c73ef1cb37">IDrbg</a>.</p>

</div>
</div>
<a id="a668962a434759e4e2a30a397a04147f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668962a434759e4e2a30a397a04147f2">&#9670;&nbsp;</a></span>SecurityStrength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t BCG::SecurityStrength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The security strength in bits </p>

<p>Implements <a class="el" href="class_i_drbg.html#a620be3a5ed3faa9c111afc1f0222b79e">IDrbg</a>.</p>

</div>
</div>
<a id="ae4cfbf45c3c3c3ec7147c9cb23b3f1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cfbf45c3c3c3ec7147c9cb23b3f1df">&#9670;&nbsp;</a></span>Update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BCG::Update </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the generators seed value. </p>
<p>Triggers a reseed with the new seed. The seed value must be equal in size to the seed used to initialize the generator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>The secret seed array</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoGeneratorException</td><td>Thrown if the seed is too small</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_drbg.html#a7c2ae576f76fc6f10d067b5dee50852b">IDrbg</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/<a class="el" href="_b_c_g_8h_source.html">BCG.h</a></li>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/BCG.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
