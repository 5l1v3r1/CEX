<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CEX++: HBA Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CEX++
   &#160;<span id="projectnumber">1.0.0.8</span>
   </div>
   <div id="projectbrief">The CEX Cryptographic Library in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_h_b_a-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HBA Class Reference<div class="ingroups"><a class="el" href="group___c_e_x.html">CEX</a> &raquo; <a class="el" href="group___cipher.html">Cipher</a> &raquo; <a class="el" href="group___block.html">Block</a> &raquo; <a class="el" href="group___mode.html">Mode</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A block cipher CTR mode with Hash Based Authentication, an AEAD cipher mode (HBA). An Encrypt and Authenticate AEAD block cipher mode.  
 <a href="class_h_b_a.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_h_b_a_8h_source.html">HBA.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for HBA:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_h_b_a.png" usemap="#HBA_map" alt=""/>
  <map id="HBA_map" name="HBA_map">
<area href="class_i_aead_mode.html" title="An AEAD block-cipher mode virtual interface class." alt="IAeadMode" shape="rect" coords="0,0,77,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a26540c0f537404414ccbd37e42c786c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a26540c0f537404414ccbd37e42c786c6">HBA</a> (const <a class="el" href="class_h_b_a.html">HBA</a> &amp;)=delete</td></tr>
<tr class="memdesc:a26540c0f537404414ccbd37e42c786c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="#a26540c0f537404414ccbd37e42c786c6">More...</a><br /></td></tr>
<tr class="separator:a26540c0f537404414ccbd37e42c786c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb3d62334245bc0de96e08e81b10cc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_b_a.html">HBA</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a4fb3d62334245bc0de96e08e81b10cc9">operator=</a> (const <a class="el" href="class_h_b_a.html">HBA</a> &amp;)=delete</td></tr>
<tr class="memdesc:a4fb3d62334245bc0de96e08e81b10cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="#a4fb3d62334245bc0de96e08e81b10cc9">More...</a><br /></td></tr>
<tr class="separator:a4fb3d62334245bc0de96e08e81b10cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719a1c42180dd507f822a8cbc3f23192"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a719a1c42180dd507f822a8cbc3f23192">HBA</a> ()=delete</td></tr>
<tr class="memdesc:a719a1c42180dd507f822a8cbc3f23192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor: default is restricted, this function has been deleted  <a href="#a719a1c42180dd507f822a8cbc3f23192">More...</a><br /></td></tr>
<tr class="separator:a719a1c42180dd507f822a8cbc3f23192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5048c13f89d2cc5f4e26a6010ce95e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#aac5048c13f89d2cc5f4e26a6010ce95e">HBA</a> (<a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a> CipherType, <a class="el" href="group___enumeration.html#ga62629810dc7b52fdfb37d80f03d62274">StreamAuthenticators</a> AuthenticatorType)</td></tr>
<tr class="memdesc:aac5048c13f89d2cc5f4e26a6010ce95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Cipher Mode using a block cipher type name.  <a href="#aac5048c13f89d2cc5f4e26a6010ce95e">More...</a><br /></td></tr>
<tr class="separator:aac5048c13f89d2cc5f4e26a6010ce95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb056952caef0dc235ae36a6ea270dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a7eb056952caef0dc235ae36a6ea270dd">HBA</a> (<a class="el" href="class_i_block_cipher.html">IBlockCipher</a> *Cipher, <a class="el" href="group___enumeration.html#ga62629810dc7b52fdfb37d80f03d62274">StreamAuthenticators</a> AuthenticatorType)</td></tr>
<tr class="memdesc:a7eb056952caef0dc235ae36a6ea270dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Cipher Mode using a block cipher instance, and specify the authentication generator type.  <a href="#a7eb056952caef0dc235ae36a6ea270dd">More...</a><br /></td></tr>
<tr class="separator:a7eb056952caef0dc235ae36a6ea270dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9304f05d06f8a749c1a50c3469f1d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a2e9304f05d06f8a749c1a50c3469f1d6">~HBA</a> () override</td></tr>
<tr class="memdesc:a2e9304f05d06f8a749c1a50c3469f1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="#a2e9304f05d06f8a749c1a50c3469f1d6">More...</a><br /></td></tr>
<tr class="separator:a2e9304f05d06f8a749c1a50c3469f1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fdd612fe04d2c5b5e2546c269a3e69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___enumeration.html#ga69ec43083306f45cbe77033dfe17cbba">AeadModes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a11fdd612fe04d2c5b5e2546c269a3e69">Enumeral</a> () override</td></tr>
<tr class="memdesc:a11fdd612fe04d2c5b5e2546c269a3e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The Cipher Modes enumeration type name  <a href="#a11fdd612fe04d2c5b5e2546c269a3e69">More...</a><br /></td></tr>
<tr class="separator:a11fdd612fe04d2c5b5e2546c269a3e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b0614f0d446e596359468177b9c3aa"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a61b0614f0d446e596359468177b9c3aa">IsEncryption</a> () override</td></tr>
<tr class="memdesc:a61b0614f0d446e596359468177b9c3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: True if initialized for encryption, false for decryption  <a href="#a61b0614f0d446e596359468177b9c3aa">More...</a><br /></td></tr>
<tr class="separator:a61b0614f0d446e596359468177b9c3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f128d4537f308416123136bbe8e58b"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a04f128d4537f308416123136bbe8e58b">IsInitialized</a> () override</td></tr>
<tr class="memdesc:a04f128d4537f308416123136bbe8e58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The Block Cipher is ready to transform data  <a href="#a04f128d4537f308416123136bbe8e58b">More...</a><br /></td></tr>
<tr class="separator:a04f128d4537f308416123136bbe8e58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b5aa7842dd6dc83e7f960351814380"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#af2b5aa7842dd6dc83e7f960351814380">IsParallel</a> () override</td></tr>
<tr class="memdesc:af2b5aa7842dd6dc83e7f960351814380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Processor parallelization availability.  <a href="#af2b5aa7842dd6dc83e7f960351814380">More...</a><br /></td></tr>
<tr class="separator:af2b5aa7842dd6dc83e7f960351814380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1e88d4422db21cd7a47a92270cd2ca"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a3c1e88d4422db21cd7a47a92270cd2ca">LegalKeySizes</a> () override</td></tr>
<tr class="memdesc:a3c1e88d4422db21cd7a47a92270cd2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Array of allowed cipher input key byte-sizes  <a href="#a3c1e88d4422db21cd7a47a92270cd2ca">More...</a><br /></td></tr>
<tr class="separator:a3c1e88d4422db21cd7a47a92270cd2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b49018ce92bd9707fc31d6e7f2b29c"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#aa0b49018ce92bd9707fc31d6e7f2b29c">Name</a> () override</td></tr>
<tr class="memdesc:aa0b49018ce92bd9707fc31d6e7f2b29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The mode and cipher name  <a href="#aa0b49018ce92bd9707fc31d6e7f2b29c">More...</a><br /></td></tr>
<tr class="separator:aa0b49018ce92bd9707fc31d6e7f2b29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf064e0b1bcc3282edd6ba9db63c387"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a5cf064e0b1bcc3282edd6ba9db63c387">ParallelBlockSize</a> () override</td></tr>
<tr class="memdesc:a5cf064e0b1bcc3282edd6ba9db63c387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Parallel block size; the byte-size of the input/output data arrays passed to a transform that trigger parallel processing.  <a href="#a5cf064e0b1bcc3282edd6ba9db63c387">More...</a><br /></td></tr>
<tr class="separator:a5cf064e0b1bcc3282edd6ba9db63c387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f7ea7cf798196d0c1cdd67fe52c4e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parallel_options.html">ParallelOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a32f7ea7cf798196d0c1cdd67fe52c4e0">ParallelProfile</a> () override</td></tr>
<tr class="memdesc:a32f7ea7cf798196d0c1cdd67fe52c4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/Write: Parallel and SIMD capability flags and sizes  <a href="#a32f7ea7cf798196d0c1cdd67fe52c4e0">More...</a><br /></td></tr>
<tr class="separator:a32f7ea7cf798196d0c1cdd67fe52c4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7f82c47d011e38a6d317ba6dd72839"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a4c7f82c47d011e38a6d317ba6dd72839">Tag</a> () override</td></tr>
<tr class="memdesc:a4c7f82c47d011e38a6d317ba6dd72839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The current standard-vector MAC tag value  <a href="#a4c7f82c47d011e38a6d317ba6dd72839">More...</a><br /></td></tr>
<tr class="separator:a4c7f82c47d011e38a6d317ba6dd72839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2719f6ca68afacc21e5a62148787523"><td class="memItemLeft" align="right" valign="top">const void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#ae2719f6ca68afacc21e5a62148787523">Tag</a> (SecureVector&lt; byte &gt; &amp;Output)</td></tr>
<tr class="memdesc:ae2719f6ca68afacc21e5a62148787523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the internal MAC tag to a secure-vector  <a href="#ae2719f6ca68afacc21e5a62148787523">More...</a><br /></td></tr>
<tr class="separator:ae2719f6ca68afacc21e5a62148787523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40289f111ccfcdb181e55a75b14c91db"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a40289f111ccfcdb181e55a75b14c91db">TagSize</a> () override</td></tr>
<tr class="memdesc:a40289f111ccfcdb181e55a75b14c91db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The MAC code length in bytes  <a href="#a40289f111ccfcdb181e55a75b14c91db">More...</a><br /></td></tr>
<tr class="separator:a40289f111ccfcdb181e55a75b14c91db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee06f19ab0bba52b3506670b2040a710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#aee06f19ab0bba52b3506670b2040a710">Initialize</a> (bool Encryption, <a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;Parameters) override</td></tr>
<tr class="memdesc:aee06f19ab0bba52b3506670b2040a710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Cipher instance.  <a href="#aee06f19ab0bba52b3506670b2040a710">More...</a><br /></td></tr>
<tr class="separator:aee06f19ab0bba52b3506670b2040a710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73de9f4d595c5b7115cb52ff1f25145d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a73de9f4d595c5b7115cb52ff1f25145d">ParallelMaxDegree</a> (size_t Degree) override</td></tr>
<tr class="memdesc:a73de9f4d595c5b7115cb52ff1f25145d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of threads allocated when using multi-threaded processing.  <a href="#a73de9f4d595c5b7115cb52ff1f25145d">More...</a><br /></td></tr>
<tr class="separator:a73de9f4d595c5b7115cb52ff1f25145d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6f591b2c7ebc65bcb2695145d4ff26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#aef6f591b2c7ebc65bcb2695145d4ff26">SetAssociatedData</a> (const std::vector&lt; byte &gt; &amp;Input, size_t Offset, size_t Length) override</td></tr>
<tr class="memdesc:aef6f591b2c7ebc65bcb2695145d4ff26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add additional data to the message authentication code generator.  <a href="#aef6f591b2c7ebc65bcb2695145d4ff26">More...</a><br /></td></tr>
<tr class="separator:aef6f591b2c7ebc65bcb2695145d4ff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19353e1d105e0843d2336304bdbd229b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#a19353e1d105e0843d2336304bdbd229b">SetAssociatedData</a> (const SecureVector&lt; byte &gt; &amp;Input, size_t Offset, size_t Length) override</td></tr>
<tr class="memdesc:a19353e1d105e0843d2336304bdbd229b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add additional data to the message authentication code generator using a memory-locked vector.  <a href="#a19353e1d105e0843d2336304bdbd229b">More...</a><br /></td></tr>
<tr class="separator:a19353e1d105e0843d2336304bdbd229b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79ae58f777408fab9e07b77d7225e6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_b_a.html#af79ae58f777408fab9e07b77d7225e6e">Transform</a> (const std::vector&lt; byte &gt; &amp;Input, size_t InOffset, std::vector&lt; byte &gt; &amp;Output, size_t OutOffset, size_t Length) override</td></tr>
<tr class="memdesc:af79ae58f777408fab9e07b77d7225e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a length of bytes with offset and length parameters.  <a href="#af79ae58f777408fab9e07b77d7225e6e">More...</a><br /></td></tr>
<tr class="separator:af79ae58f777408fab9e07b77d7225e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_aead_mode"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_aead_mode')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_aead_mode.html">IAeadMode</a></td></tr>
<tr class="memitem:a42066de39d76426fbb7bba804b60667e inherit pub_methods_class_i_aead_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_aead_mode.html#a42066de39d76426fbb7bba804b60667e">IAeadMode</a> (const <a class="el" href="class_i_aead_mode.html">IAeadMode</a> &amp;)=delete</td></tr>
<tr class="memdesc:a42066de39d76426fbb7bba804b60667e inherit pub_methods_class_i_aead_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="class_i_aead_mode.html#a42066de39d76426fbb7bba804b60667e">More...</a><br /></td></tr>
<tr class="separator:a42066de39d76426fbb7bba804b60667e inherit pub_methods_class_i_aead_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8b2abeb522b923e87faa0e956de47a inherit pub_methods_class_i_aead_mode"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_aead_mode.html">IAeadMode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_aead_mode.html#a0b8b2abeb522b923e87faa0e956de47a">operator=</a> (const <a class="el" href="class_i_aead_mode.html">IAeadMode</a> &amp;)=delete</td></tr>
<tr class="memdesc:a0b8b2abeb522b923e87faa0e956de47a inherit pub_methods_class_i_aead_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="class_i_aead_mode.html#a0b8b2abeb522b923e87faa0e956de47a">More...</a><br /></td></tr>
<tr class="separator:a0b8b2abeb522b923e87faa0e956de47a inherit pub_methods_class_i_aead_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db2790e9218e806bd34046bf3aac04a inherit pub_methods_class_i_aead_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_aead_mode.html#a4db2790e9218e806bd34046bf3aac04a">IAeadMode</a> ()</td></tr>
<tr class="memdesc:a4db2790e9218e806bd34046bf3aac04a inherit pub_methods_class_i_aead_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the IAeadMode virtual interface class  <a href="class_i_aead_mode.html#a4db2790e9218e806bd34046bf3aac04a">More...</a><br /></td></tr>
<tr class="separator:a4db2790e9218e806bd34046bf3aac04a inherit pub_methods_class_i_aead_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f02f52967fd0cdc00311f69ac0f239 inherit pub_methods_class_i_aead_mode"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_aead_mode.html#a26f02f52967fd0cdc00311f69ac0f239">~IAeadMode</a> () noexcept</td></tr>
<tr class="memdesc:a26f02f52967fd0cdc00311f69ac0f239 inherit pub_methods_class_i_aead_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="class_i_aead_mode.html#a26f02f52967fd0cdc00311f69ac0f239">More...</a><br /></td></tr>
<tr class="separator:a26f02f52967fd0cdc00311f69ac0f239 inherit pub_methods_class_i_aead_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A block cipher CTR mode with Hash Based Authentication, an AEAD cipher mode (HBA). An Encrypt and Authenticate AEAD block cipher mode. </p>
<p>Encrypting a 1kb vector of bytes: </p><div class="fragment"><div class="line"><span class="comment">// create an instance using the RHX cipher and the Keccak based KMAC-256</span></div><div class="line"><a class="code" href="class_h_b_a.html">HBA</a> cipher(BlockCiphers::RHXS256, <a class="code" href="group___enumeration.html#gga62629810dc7b52fdfb37d80f03d62274a1421b85b6d4ee9a863d5b1588c880103">StreamAuthenticators::KMAC256</a>);</div><div class="line"><span class="comment">// initialize for encryption</span></div><div class="line">cipher.Initialize(<span class="keyword">true</span>, <a class="code" href="class_symmetric_key.html">SymmetricKey</a>(<a class="code" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>, <a class="code" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">Nonce</a>, [Info]));</div><div class="line"><span class="comment">// encrypt 1024 bytes, and finalize the mac, the code is appended to the end of the output vector</span></div><div class="line">cipher.Transform(Input, 0, Output, 0, 1024);</div></div><!-- fragment --> <p>Decrypting a 1kb vector of bytes: </p><div class="fragment"><div class="line"><span class="comment">// create an instance using the RHX cipher and the Keccak based KMAC-256</span></div><div class="line"><a class="code" href="class_h_b_a.html">HBA</a> cipher(BlockCiphers::RHXS256, <a class="code" href="group___enumeration.html#gga62629810dc7b52fdfb37d80f03d62274a1421b85b6d4ee9a863d5b1588c880103">StreamAuthenticators::KMAC256</a>);</div><div class="line"><span class="comment">// initialize for decryption</span></div><div class="line">cipher.Initialize(<span class="keyword">false</span>, <a class="code" href="class_symmetric_key.html">SymmetricKey</a>(<a class="code" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>, <a class="code" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">Nonce</a>, [Info]));</div><div class="line"></div><div class="line"><span class="comment">// decrypt 1024 bytes, if the authentication fails a CryptoAuthenticationFailure exception is thrown</span></div><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line">    cipher.Transform(Input, 0, Output, 0, 1024);</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span> (<a class="code" href="class_crypto_authentication_failure.html">CryptoAuthenticationFailure</a> <span class="keyword">const</span> &amp;ex)</div><div class="line">{</div><div class="line">    <span class="comment">// authentication has failed, do something..</span></div><div class="line">}</div></div><!-- fragment --> <p><b>Overview:</b> </p>
<p>The HBA Cipher Mode is an Authenticate Encrypt and Additional Data (AEAD) authenticated block-cipher mode. <br />
HBA has provable security, the security-level dependant on the block cipher and MAC functions used by the mode. <br />
HBA first encrypts the plaintext using a block-cipher counter mode (CTR), then processes that cipher-text using either an HMAC(SHA2) or KMAC, MAC authentication code generator. <br />
When encryption is completed, the MAC code is generated and appended to the output stream after each call to Transform(Input, InOffset, OLutput, OutOffset, Length) function. <br />
Decryption performs these steps in reverse, processing the cipher-text bytes through the MAC function, then decrypting the data to plain-text. <br />
If during the authentication stage of decryption the MAC code check fails, a CryptoAuthenticationFailure exception is generated, and the cipher-text is not decrypted.</p>
<p><b>Description:</b> </p>
<p><em>Legend:</em> <br />
<b>C</b>=ciphertext, <b>P</b>=plaintext, <b>k</b>=key, <b>E</b>=encrypt, <b>D</b>=decrypt, <b>Mk</b>=keyed mac, <b>T</b>=mac code <br />
<em>Encryption</em> <br />
For i ...n (Ci = Ek(Pi), T = Mk(Ci)). CT = C||T. <br />
<em>Decryption</em> <br />
For i ...n (T = Mk(Ci), Pi = D(Ci)). PT = P||T.</p>
<p><b>Multi-Threading:</b> </p>
<p>The encryption and decryption functions of the HBA mode can be multi-threaded. This is achieved by processing multiple blocks of message input independently across threads. <br />
The HBA parallel mode also leverages SIMD instructions to 'double parallelize' those segments. <br />
An input block assigned to a thread uses SIMD instructions to decrypt/encrypt 4, 8, or 16 blocks in parallel per cycle, depending on which framework is runtime available, AVX, AVX2, or AVX512 instructions. <br />
Input blocks equal to, or divisble by the ParallelBlockSize() are processed in parallel on supported systems, this can be disabled through the ParallelProfile accessor function. <br />
The cipher transform is parallelizable, however the authentication pass, (HMAC/KMAC), is processed sequentially. (though this implementation does support the Intel SHA2-256 SIMD instructions).</p>
<p><b>API and Usage:</b> </p>
<p>The constructor HBA(BlockCiphers, StreamAuthenticators), has enumeration options for the base block-cipher type, and the MAC generator type. The advanced constructer HBA(IBlockCipher*, StreamAuthenticators), takes a pointer to an uninitalized block-cipher instance. Instances of the cipher and generator are created and assigned to internal unique pointers. <br />
The initialization function Initialize(bool, ISymmetricKey), sets the cipher mode to encryption or decryption mode, and initializes the state with the user supplied key parameters. <br />
The SetAssociatedData(Input, Offset, Length) function updates the MAC generator with associatiated data. <br />
The Transform(Input, InOffset, Output, OutOffset, Length) function process a data array, and returns the transformed data. in Encryption mode, the input is encrypted and that cipher-text is added to the MAC generator, a MAC code is generated and appended to the cipher-text. <br />
In Decryption mode, the cipher-text is first processed by the MAC generator and the resulting MAC code is compared to the code appended to the cipher-text. If the codes do not match, the cipher-text has failed authentication, a CryptoAuthenticationFailure exception is raised, and the cipher-text is not decrypted. HBA is not an 'online' cipher mode, one in which multiple calls to transform are be made, where the cipher-text is decrypted and the MAC updated in tandem, and the cipher-text is authenticated only after a finalization call is made. This implementation, does not use the online mode format, but instead adds or authenticates a MAC each time the Transform function is called. If during decryption, the MAC authentication check fails, an exception is raised and no decryption of the cipher-text takes place, thus making this implementation immune to chosen ciphertext attacks that target the underlying block-cipher. </p>
<p>Implementation Notes: </p><ul>
<li>
HBA is an AEAD authenticated mode, additional data such as packet header information can be added to the authentication process. </li>
<li>
Additional data can be added using the SetAssociatedData(Input, Offset, Length) call, and during Initialize, using the Info parameter of the SymmetricKey. </li>
<li>
Each time the Transform function is called, this mode either adds a MAC code to the end of the output stream [encryption], or checks the MAC code appended to the cipher-text [decryption]. </li>
<li>
The Transform(Input, InOffset, Output, OutOffset, Length) function adds a MAC code to the end of the output stream in Encryption mode; the output vector must be sized to allow for the full length of the cipher-text and the MAC tag (TagSize() property). </li>
<li>
In Decryption mode, the Transform function MACs the input cipher-text and compares the output to the MAC code appended to the input stream; if the MAC check fails, a CryptoAuthenticationFailure exception is raised. </li>
<li>
Encryption and decryption can both be pipelined (AVX/AVX2/AVX512), and multi-threaded with any even number of threads up to the processors total [virtual] processing cores. </li>
<li>
If the system supports Parallel processing, and IsParallel() is set to true; passing an input block of ParallelBlockSize() to the transform will be auto parallelized. </li>
<li>
The recommended parallel input block-size ParallelBlockSize(), is calculated automatically based on the processor(s) L1/L2 cache sizes, the algorithms code-cache requirements, and available memory. </li>
<li>
The ParallelBlockSize(), IsParallel(), and ParallelThreadsMax() accessors, can be changed through the ParallelProfile() property, this value can be user defined, but must be evenly divisible by ParallelMinimumSize(). </li>
</ul>
<p>Guiding Publications: </p><ol>
<li>
NIST <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</a>. </li>
<li>
NIST <a href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">Rijndael ammended</a>. </li>
<li>
NIST <a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">SHA-2 Standard</a>. </li>
<li>
RFC <a href="http://tools.ietf.org/html/rfc2104">2104</a>: HMAC: Keyed-Hashing for Message Authentication. </li>
<li>
Fips <a href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198-1</a>: The Keyed-Hash Message Authentication Code (HMAC). </li>
<li>
SHA3 <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">Fips202</a>. </li>
<li>
NIST <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pd">SP800-185</a>. </li>
<li>
RFC 5116: <a href="https://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a26540c0f537404414ccbd37e42c786c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26540c0f537404414ccbd37e42c786c6">&#9670;&nbsp;</a></span>HBA() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HBA::HBA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_b_a.html">HBA</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: copy is restricted, this function has been deleted </p>

</div>
</div>
<a id="a719a1c42180dd507f822a8cbc3f23192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719a1c42180dd507f822a8cbc3f23192">&#9670;&nbsp;</a></span>HBA() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HBA::HBA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor: default is restricted, this function has been deleted </p>

</div>
</div>
<a id="aac5048c13f89d2cc5f4e26a6010ce95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5048c13f89d2cc5f4e26a6010ce95e">&#9670;&nbsp;</a></span>HBA() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HBA::HBA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a>&#160;</td>
          <td class="paramname"><em>CipherType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumeration.html#ga62629810dc7b52fdfb37d80f03d62274">StreamAuthenticators</a>&#160;</td>
          <td class="paramname"><em>AuthenticatorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the Cipher Mode using a block cipher type name. </p>
<p>The cipher instance is created and destroyed automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CipherType</td><td>The enumeration name of the block cipher</td></tr>
    <tr><td class="paramname">AuthenticatorType</td><td>The enumeration name of the MAC generator</td></tr>
  </table>
  </dd>
</dl>
<p>,</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if an invalid block cipher type is used</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eb056952caef0dc235ae36a6ea270dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb056952caef0dc235ae36a6ea270dd">&#9670;&nbsp;</a></span>HBA() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HBA::HBA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_block_cipher.html">IBlockCipher</a> *&#160;</td>
          <td class="paramname"><em>Cipher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___enumeration.html#ga62629810dc7b52fdfb37d80f03d62274">StreamAuthenticators</a>&#160;</td>
          <td class="paramname"><em>AuthenticatorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the Cipher Mode using a block cipher instance, and specify the authentication generator type. </p>
<p>The cipher instance is created and destroyed automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cipher</td><td>An uninitialized Block Cipher instance; can not be null</td></tr>
    <tr><td class="paramname">AuthenticatorType</td><td>The enumeration name of the MAC generator</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if a null block cipher is used</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e9304f05d06f8a749c1a50c3469f1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9304f05d06f8a749c1a50c3469f1d6">&#9670;&nbsp;</a></span>~HBA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HBA::~HBA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor: finalize this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a11fdd612fe04d2c5b5e2546c269a3e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fdd612fe04d2c5b5e2546c269a3e69">&#9670;&nbsp;</a></span>Enumeral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___enumeration.html#ga69ec43083306f45cbe77033dfe17cbba">AeadModes</a> HBA::Enumeral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The Cipher Modes enumeration type name </p>

<p>Implements <a class="el" href="class_i_aead_mode.html#a0762a0d5cfeeeae3cfe1bcbd45926a1a">IAeadMode</a>.</p>

</div>
</div>
<a id="aee06f19ab0bba52b3506670b2040a710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee06f19ab0bba52b3506670b2040a710">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HBA::Initialize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Encryption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;&#160;</td>
          <td class="paramname"><em>Parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the Cipher instance. </p>
<p>The legal symmetric key and nonce sizes are contained in the LegalKeySizes() property. The Info parameter of the SymmetricKey can be used as the initial associated data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Encryption</td><td>Set to true if cipher is used for encryption, false for decryption mode</td></tr>
    <tr><td class="paramname">Parameters</td><td>SymmetricKey containing the encryption Key and Nonce</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if a null or invalid Key/Nonce is used</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_aead_mode.html#a30ec3942cb83d43876b6437b2aa37933">IAeadMode</a>.</p>

</div>
</div>
<a id="a61b0614f0d446e596359468177b9c3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b0614f0d446e596359468177b9c3aa">&#9670;&nbsp;</a></span>IsEncryption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool HBA::IsEncryption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: True if initialized for encryption, false for decryption </p>

<p>Implements <a class="el" href="class_i_aead_mode.html#adfc47cc44fe535fecdf2ea9035d31132">IAeadMode</a>.</p>

</div>
</div>
<a id="a04f128d4537f308416123136bbe8e58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f128d4537f308416123136bbe8e58b">&#9670;&nbsp;</a></span>IsInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool HBA::IsInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The Block Cipher is ready to transform data </p>

<p>Implements <a class="el" href="class_i_aead_mode.html#a5a78231c21ebe5b465920cdfde7750f1">IAeadMode</a>.</p>

</div>
</div>
<a id="af2b5aa7842dd6dc83e7f960351814380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b5aa7842dd6dc83e7f960351814380">&#9670;&nbsp;</a></span>IsParallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool HBA::IsParallel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Processor parallelization availability. </p>
<p>Indicates whether parallel processing is available with this mode. If parallel capable, input/output data arrays passed to the transform must be ParallelBlockSize in bytes to trigger parallelization.</p>

<p>Implements <a class="el" href="class_i_aead_mode.html#abf9d62806e790c57fb878ee9ccda1045">IAeadMode</a>.</p>

</div>
</div>
<a id="a3c1e88d4422db21cd7a47a92270cd2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1e88d4422db21cd7a47a92270cd2ca">&#9670;&nbsp;</a></span>LegalKeySizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp; HBA::LegalKeySizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Array of allowed cipher input key byte-sizes </p>

<p>Implements <a class="el" href="class_i_aead_mode.html#a7a2317dc86d6ee4d16260f5f816f7eb6">IAeadMode</a>.</p>

</div>
</div>
<a id="aa0b49018ce92bd9707fc31d6e7f2b29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b49018ce92bd9707fc31d6e7f2b29c">&#9670;&nbsp;</a></span>Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string HBA::Name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The mode and cipher name </p>

<p>Implements <a class="el" href="class_i_aead_mode.html#a9784e4725e9febe9d06c83bb328efb64">IAeadMode</a>.</p>

</div>
</div>
<a id="a4fb3d62334245bc0de96e08e81b10cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb3d62334245bc0de96e08e81b10cc9">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_b_a.html">HBA</a>&amp; HBA::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_b_a.html">HBA</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator: copy is restricted, this function has been deleted </p>

</div>
</div>
<a id="a5cf064e0b1bcc3282edd6ba9db63c387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf064e0b1bcc3282edd6ba9db63c387">&#9670;&nbsp;</a></span>ParallelBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t HBA::ParallelBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Parallel block size; the byte-size of the input/output data arrays passed to a transform that trigger parallel processing. </p>
<p>This value can be changed through the ParallelProfile class.</p>

<p>Implements <a class="el" href="class_i_aead_mode.html#a83a824dc299cd19f0c7cf313b426c07e">IAeadMode</a>.</p>

</div>
</div>
<a id="a73de9f4d595c5b7115cb52ff1f25145d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73de9f4d595c5b7115cb52ff1f25145d">&#9670;&nbsp;</a></span>ParallelMaxDegree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HBA::ParallelMaxDegree </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of threads allocated when using multi-threaded processing. </p>
<p>When set to zero, thread count is set automatically. If set to 1, sets IsParallel() to false and runs in sequential mode. Thread count must be an even number, and not exceed the number of processor cores.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Degree</td><td>The number of threads to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if the degree parameter is invalid</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_aead_mode.html#abccf2f58eab5d4a42cb340d60895c225">IAeadMode</a>.</p>

</div>
</div>
<a id="a32f7ea7cf798196d0c1cdd67fe52c4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f7ea7cf798196d0c1cdd67fe52c4e0">&#9670;&nbsp;</a></span>ParallelProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parallel_options.html">ParallelOptions</a> &amp; HBA::ParallelProfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read/Write: Parallel and SIMD capability flags and sizes </p>
<p>The maximum number of threads allocated when using multi-threaded processing can be set with the ParallelMaxDegree() property. The ParallelBlockSize() property is auto-calculated, but can be changed; the value must be evenly divisible by ParallelMinimumSize(). Changes to these values must be made before the Initialize(SymmetricKey) function is called.</p>

<p>Implements <a class="el" href="class_i_aead_mode.html#a597d277f9b895a9f02451a46971da06a">IAeadMode</a>.</p>

</div>
</div>
<a id="aef6f591b2c7ebc65bcb2695145d4ff26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6f591b2c7ebc65bcb2695145d4ff26">&#9670;&nbsp;</a></span>SetAssociatedData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HBA::SetAssociatedData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add additional data to the message authentication code generator. </p>
<p>Must be set before the transformation call. This function can only be called once per each initialization/finalization cycle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input standard-vector of bytes to process</td></tr>
    <tr><td class="paramname">Offset</td><td>The starting offset within the input vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if state has been processed</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_aead_mode.html#a6523ab4680898c42ad9aaf9963042163">IAeadMode</a>.</p>

</div>
</div>
<a id="a19353e1d105e0843d2336304bdbd229b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19353e1d105e0843d2336304bdbd229b">&#9670;&nbsp;</a></span>SetAssociatedData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HBA::SetAssociatedData </td>
          <td>(</td>
          <td class="paramtype">const SecureVector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add additional data to the message authentication code generator using a memory-locked vector. </p>
<p>Must be set before the transformation call. This function can only be called once per each initialization/finalization cycle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input secure-vector of bytes to process</td></tr>
    <tr><td class="paramname">Offset</td><td>The starting offset within the input vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if state has been processed</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_aead_mode.html#a38623af3de1429255606cf08e2358363">IAeadMode</a>.</p>

</div>
</div>
<a id="a4c7f82c47d011e38a6d317ba6dd72839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7f82c47d011e38a6d317ba6dd72839">&#9670;&nbsp;</a></span>Tag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; byte &gt; HBA::Tag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The current standard-vector MAC tag value </p>

<p>Implements <a class="el" href="class_i_aead_mode.html#ad19fd97a58a68c9f8f02bc366135abf8">IAeadMode</a>.</p>

</div>
</div>
<a id="ae2719f6ca68afacc21e5a62148787523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2719f6ca68afacc21e5a62148787523">&#9670;&nbsp;</a></span>Tag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void HBA::Tag </td>
          <td>(</td>
          <td class="paramtype">SecureVector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the internal MAC tag to a secure-vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The secure-vector receiving the MAC code</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_aead_mode.html#ac9d19693f6cdeee2682a3172acf04354">IAeadMode</a>.</p>

</div>
</div>
<a id="a40289f111ccfcdb181e55a75b14c91db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40289f111ccfcdb181e55a75b14c91db">&#9670;&nbsp;</a></span>TagSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t HBA::TagSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The MAC code length in bytes </p>

<p>Implements <a class="el" href="class_i_aead_mode.html#acd71f9f704694974157f002883fdef4b">IAeadMode</a>.</p>

</div>
</div>
<a id="af79ae58f777408fab9e07b77d7225e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79ae58f777408fab9e07b77d7225e6e">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HBA::Transform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a length of bytes with offset and length parameters. </p>
<p>This method processes a specified length of bytes, utilizing offsets incremented by the caller. In encryption mode, the message data is encrypted, and the cipher-text is used by the MAC generator to calculate the MAC code, which is appended to the output array. In decryption mode, the input cipher-text is added to the MAC generator, and an internal code is generated. This code is compared to the MAC code contained in the cipher-text; if the codes do not match a CryptoAuthenticationFailure exception is thrown. If IsParallel() is set to true, and the length is at least ParallelBlockSize(), the transform is run in parallel processing mode. To disable parallel processing, set the ParallelOptions().IsParallel() property to false. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input vector of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the input vector</td></tr>
    <tr><td class="paramname">Output</td><td>The output vector of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to transform</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_aead_mode.html#afc6e773b9a3940a62217d1c6caac4e8e">IAeadMode</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/<a class="el" href="_documentation_8h_source.html">Documentation.h</a></li>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/<a class="el" href="_h_b_a_8h_source.html">HBA.h</a></li>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/HBA.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
