<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>CEX++: SHX Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cexlogo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CEX++
   &#160;<span id="projectnumber">1.0.0.5</span>
   </div>
   <div id="projectbrief">The CEX Cryptographic Library in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_s_h_x-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SHX Class Reference<div class="ingroups"><a class="el" href="group___c_e_x.html">CEX</a> &raquo; <a class="el" href="group___cipher.html">Cipher</a> &raquo; <a class="el" href="group___symmetric.html">Symmetric</a> &raquo; <a class="el" href="group___block.html">Block</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A Serpent cipher extended with an (optional) HKDF powered Key Schedule  
 <a href="class_s_h_x.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_h_x_8h_source.html">SHX.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SHX:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_h_x.png" usemap="#SHX_map" alt=""/>
  <map id="SHX_map" name="SHX_map">
<area href="class_i_block_cipher.html" title="The Block Cipher Interface class " alt="IBlockCipher" shape="rect" coords="0,0,84,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a947459e40103c2a6914dd40975a8241e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a947459e40103c2a6914dd40975a8241e">SHX</a> (const <a class="el" href="class_s_h_x.html">SHX</a> &amp;)=delete</td></tr>
<tr class="memdesc:a947459e40103c2a6914dd40975a8241e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="#a947459e40103c2a6914dd40975a8241e">More...</a><br /></td></tr>
<tr class="separator:a947459e40103c2a6914dd40975a8241e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cb46bd84672148ca65465cadccde0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_h_x.html">SHX</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ab7cb46bd84672148ca65465cadccde0c">operator=</a> (const <a class="el" href="class_s_h_x.html">SHX</a> &amp;)=delete</td></tr>
<tr class="memdesc:ab7cb46bd84672148ca65465cadccde0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="#ab7cb46bd84672148ca65465cadccde0c">More...</a><br /></td></tr>
<tr class="separator:ab7cb46bd84672148ca65465cadccde0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ad63b6940c8b5002ecab75fe55606e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ac5ad63b6940c8b5002ecab75fe55606e">SHX</a> (<a class="el" href="group___enumeration.html#gab52dd4d279d842e68f46a2a0499c10c3">Digests</a> DigestType=Digests::None, size_t <a class="el" href="class_s_h_x.html#a5610f0429f24030730a3072a0390d431">Rounds</a>=32)</td></tr>
<tr class="memdesc:ac5ad63b6940c8b5002ecab75fe55606e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate the class with optional transformation rounds, and KDF engine type settings  <a href="#ac5ad63b6940c8b5002ecab75fe55606e">More...</a><br /></td></tr>
<tr class="separator:ac5ad63b6940c8b5002ecab75fe55606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6365f6f7ae249876e33debc86e51f7d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a6365f6f7ae249876e33debc86e51f7d4">SHX</a> (<a class="el" href="class_i_digest.html">IDigest</a> *Digest, size_t <a class="el" href="class_s_h_x.html#a5610f0429f24030730a3072a0390d431">Rounds</a>=40)</td></tr>
<tr class="memdesc:a6365f6f7ae249876e33debc86e51f7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate the class with a Digest instance (HKDF mode), and with optional transformation rounds settings  <a href="#a6365f6f7ae249876e33debc86e51f7d4">More...</a><br /></td></tr>
<tr class="separator:a6365f6f7ae249876e33debc86e51f7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac729986516e62fbb21cc0812d82f77d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ac729986516e62fbb21cc0812d82f77d5">~SHX</a> () override</td></tr>
<tr class="memdesc:ac729986516e62fbb21cc0812d82f77d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="#ac729986516e62fbb21cc0812d82f77d5">More...</a><br /></td></tr>
<tr class="separator:ac729986516e62fbb21cc0812d82f77d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d73865bee9745ae15d76b07aee91a3"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3">BlockSize</a> () override</td></tr>
<tr class="memdesc:a55d73865bee9745ae15d76b07aee91a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Unit block size of internal cipher in bytes.  <a href="#a55d73865bee9745ae15d76b07aee91a3">More...</a><br /></td></tr>
<tr class="separator:a55d73865bee9745ae15d76b07aee91a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433739e562fa270770d5f123a693e959"><td class="memItemLeft" align="right" valign="top">std::vector&lt; byte &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a433739e562fa270770d5f123a693e959">DistributionCode</a> () override</td></tr>
<tr class="memdesc:a433739e562fa270770d5f123a693e959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/Write: Reads or Sets the Info (personalization string) value in the HKDF initialization parameters.  <a href="#a433739e562fa270770d5f123a693e959">More...</a><br /></td></tr>
<tr class="separator:a433739e562fa270770d5f123a693e959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea6e92b9321ad8acc1398a3f5cecb89"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#aaea6e92b9321ad8acc1398a3f5cecb89">DistributionCodeMax</a> () override</td></tr>
<tr class="memdesc:aaea6e92b9321ad8acc1398a3f5cecb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The maximum size of the distribution code in bytes.  <a href="#aaea6e92b9321ad8acc1398a3f5cecb89">More...</a><br /></td></tr>
<tr class="separator:aaea6e92b9321ad8acc1398a3f5cecb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af434ded19889286371bcf7861196f215"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#af434ded19889286371bcf7861196f215">Enumeral</a> () override</td></tr>
<tr class="memdesc:af434ded19889286371bcf7861196f215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The block ciphers type name  <a href="#af434ded19889286371bcf7861196f215">More...</a><br /></td></tr>
<tr class="separator:af434ded19889286371bcf7861196f215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb576085c0558aecb5d0299344c2c1c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a8fb576085c0558aecb5d0299344c2c1c">IsEncryption</a> () override</td></tr>
<tr class="memdesc:a8fb576085c0558aecb5d0299344c2c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Initialized for encryption, false for decryption.  <a href="#a8fb576085c0558aecb5d0299344c2c1c">More...</a><br /></td></tr>
<tr class="separator:a8fb576085c0558aecb5d0299344c2c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ea567917110bd918296b618851ba9f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ac4ea567917110bd918296b618851ba9f">IsInitialized</a> () override</td></tr>
<tr class="memdesc:ac4ea567917110bd918296b618851ba9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Cipher is ready to transform data  <a href="#ac4ea567917110bd918296b618851ba9f">More...</a><br /></td></tr>
<tr class="separator:ac4ea567917110bd918296b618851ba9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512d2284eb6705001f4923b34491cff4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___enumeration.html#gab52dd4d279d842e68f46a2a0499c10c3">Digests</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a512d2284eb6705001f4923b34491cff4">KdfEngine</a> () override</td></tr>
<tr class="memdesc:a512d2284eb6705001f4923b34491cff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The extended ciphers HKDF digest type  <a href="#a512d2284eb6705001f4923b34491cff4">More...</a><br /></td></tr>
<tr class="separator:a512d2284eb6705001f4923b34491cff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7006f75c0b2e55ea722f55f2b2942d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a5c7006f75c0b2e55ea722f55f2b2942d">LegalKeySizes</a> () override</td></tr>
<tr class="memdesc:a5c7006f75c0b2e55ea722f55f2b2942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Available Encryption Key Sizes in bytes  <a href="#a5c7006f75c0b2e55ea722f55f2b2942d">More...</a><br /></td></tr>
<tr class="separator:a5c7006f75c0b2e55ea722f55f2b2942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cfb0400aab1523c0299d1c8663bada"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a69cfb0400aab1523c0299d1c8663bada">LegalRounds</a> () override</td></tr>
<tr class="memdesc:a69cfb0400aab1523c0299d1c8663bada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Available transformation round assignments  <a href="#a69cfb0400aab1523c0299d1c8663bada">More...</a><br /></td></tr>
<tr class="separator:a69cfb0400aab1523c0299d1c8663bada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fad5c65ff282d1064cdbdf71e414f2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ae9fad5c65ff282d1064cdbdf71e414f2">Name</a> () override</td></tr>
<tr class="memdesc:ae9fad5c65ff282d1064cdbdf71e414f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The block ciphers class name  <a href="#ae9fad5c65ff282d1064cdbdf71e414f2">More...</a><br /></td></tr>
<tr class="separator:ae9fad5c65ff282d1064cdbdf71e414f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5610f0429f24030730a3072a0390d431"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a5610f0429f24030730a3072a0390d431">Rounds</a> () override</td></tr>
<tr class="memdesc:a5610f0429f24030730a3072a0390d431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The number of transformation rounds processed by the transform  <a href="#a5610f0429f24030730a3072a0390d431">More...</a><br /></td></tr>
<tr class="separator:a5610f0429f24030730a3072a0390d431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2810f584c4cb58792b07c36df64acf4"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ac2810f584c4cb58792b07c36df64acf4">StateCacheSize</a> () override</td></tr>
<tr class="memdesc:ac2810f584c4cb58792b07c36df64acf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The sum size in bytes (plus some allowance for externals) of the classes persistant state.  <a href="#ac2810f584c4cb58792b07c36df64acf4">More...</a><br /></td></tr>
<tr class="separator:ac2810f584c4cb58792b07c36df64acf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac192252a9b19b528474cad6704baf772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ac192252a9b19b528474cad6704baf772">DecryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:ac192252a9b19b528474cad6704baf772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a single block of bytes.  <a href="#ac192252a9b19b528474cad6704baf772">More...</a><br /></td></tr>
<tr class="separator:ac192252a9b19b528474cad6704baf772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5ba9f06e186169823a401f6ecebcb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a0e5ba9f06e186169823a401f6ecebcb8">DecryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:a0e5ba9f06e186169823a401f6ecebcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a block of bytes with offset parameters.  <a href="#a0e5ba9f06e186169823a401f6ecebcb8">More...</a><br /></td></tr>
<tr class="separator:a0e5ba9f06e186169823a401f6ecebcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55de346752869ad04bea165a1766e1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ae55de346752869ad04bea165a1766e1c">EncryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:ae55de346752869ad04bea165a1766e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a block of bytes.  <a href="#ae55de346752869ad04bea165a1766e1c">More...</a><br /></td></tr>
<tr class="separator:ae55de346752869ad04bea165a1766e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cbc84fd64a7dc5d9937ffebaabb470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a13cbc84fd64a7dc5d9937ffebaabb470">EncryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:a13cbc84fd64a7dc5d9937ffebaabb470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a block of bytes with offset parameters.  <a href="#a13cbc84fd64a7dc5d9937ffebaabb470">More...</a><br /></td></tr>
<tr class="separator:a13cbc84fd64a7dc5d9937ffebaabb470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace967cd9459e1f501b8cf32b9906fc69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ace967cd9459e1f501b8cf32b9906fc69">Initialize</a> (bool Encryption, <a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;KeyParams) override</td></tr>
<tr class="memdesc:ace967cd9459e1f501b8cf32b9906fc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the cipher  <a href="#ace967cd9459e1f501b8cf32b9906fc69">More...</a><br /></td></tr>
<tr class="separator:ace967cd9459e1f501b8cf32b9906fc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3a38afd6bfba3da04e7f0d7aa4bdb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a6c3a38afd6bfba3da04e7f0d7aa4bdb9">Transform</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:a6c3a38afd6bfba3da04e7f0d7aa4bdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a block of bytes.  <a href="#a6c3a38afd6bfba3da04e7f0d7aa4bdb9">More...</a><br /></td></tr>
<tr class="separator:a6c3a38afd6bfba3da04e7f0d7aa4bdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d46323c3a0c7f5b0d92cf20e8efac7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a0d46323c3a0c7f5b0d92cf20e8efac7a">Transform</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:a0d46323c3a0c7f5b0d92cf20e8efac7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a block of bytes with offset parameters.  <a href="#a0d46323c3a0c7f5b0d92cf20e8efac7a">More...</a><br /></td></tr>
<tr class="separator:a0d46323c3a0c7f5b0d92cf20e8efac7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf52d2a29c15cab5ab3bfe672f9befc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a5bf52d2a29c15cab5ab3bfe672f9befc">Transform512</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:a5bf52d2a29c15cab5ab3bfe672f9befc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform 4 blocks of bytes.  <a href="#a5bf52d2a29c15cab5ab3bfe672f9befc">More...</a><br /></td></tr>
<tr class="separator:a5bf52d2a29c15cab5ab3bfe672f9befc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb00192f15984eadd77b5cc2ba91298d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#adb00192f15984eadd77b5cc2ba91298d">Transform1024</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:adb00192f15984eadd77b5cc2ba91298d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform 8 blocks of bytes.  <a href="#adb00192f15984eadd77b5cc2ba91298d">More...</a><br /></td></tr>
<tr class="separator:adb00192f15984eadd77b5cc2ba91298d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dc1b611c104db2c21e5672b9086be4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a17dc1b611c104db2c21e5672b9086be4">Transform2048</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:a17dc1b611c104db2c21e5672b9086be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform 16 blocks of bytes.  <a href="#a17dc1b611c104db2c21e5672b9086be4">More...</a><br /></td></tr>
<tr class="separator:a17dc1b611c104db2c21e5672b9086be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_block_cipher"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_block_cipher')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_block_cipher.html">IBlockCipher</a></td></tr>
<tr class="memitem:ab7f96ce0a0cccb943f2d446a3191353a inherit pub_methods_class_i_block_cipher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_block_cipher.html#ab7f96ce0a0cccb943f2d446a3191353a">IBlockCipher</a> (const <a class="el" href="class_i_block_cipher.html">IBlockCipher</a> &amp;)=delete</td></tr>
<tr class="memdesc:ab7f96ce0a0cccb943f2d446a3191353a inherit pub_methods_class_i_block_cipher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="#ab7f96ce0a0cccb943f2d446a3191353a">More...</a><br /></td></tr>
<tr class="separator:ab7f96ce0a0cccb943f2d446a3191353a inherit pub_methods_class_i_block_cipher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c37b7bfc13c33527c07bbe38bae074 inherit pub_methods_class_i_block_cipher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_block_cipher.html">IBlockCipher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_block_cipher.html#ac9c37b7bfc13c33527c07bbe38bae074">operator=</a> (const <a class="el" href="class_i_block_cipher.html">IBlockCipher</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac9c37b7bfc13c33527c07bbe38bae074 inherit pub_methods_class_i_block_cipher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="#ac9c37b7bfc13c33527c07bbe38bae074">More...</a><br /></td></tr>
<tr class="separator:ac9c37b7bfc13c33527c07bbe38bae074 inherit pub_methods_class_i_block_cipher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a572aa6de3828f4c1e245f159212271 inherit pub_methods_class_i_block_cipher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_block_cipher.html#a1a572aa6de3828f4c1e245f159212271">IBlockCipher</a> ()</td></tr>
<tr class="memdesc:a1a572aa6de3828f4c1e245f159212271 inherit pub_methods_class_i_block_cipher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: Instantiate this class  <a href="#a1a572aa6de3828f4c1e245f159212271">More...</a><br /></td></tr>
<tr class="separator:a1a572aa6de3828f4c1e245f159212271 inherit pub_methods_class_i_block_cipher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16af8e77a95711cf94416f3f080a259 inherit pub_methods_class_i_block_cipher"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_block_cipher.html#ad16af8e77a95711cf94416f3f080a259">~IBlockCipher</a> () noexcept</td></tr>
<tr class="memdesc:ad16af8e77a95711cf94416f3f080a259 inherit pub_methods_class_i_block_cipher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="#ad16af8e77a95711cf94416f3f080a259">More...</a><br /></td></tr>
<tr class="separator:ad16af8e77a95711cf94416f3f080a259 inherit pub_methods_class_i_block_cipher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Serpent cipher extended with an (optional) HKDF powered Key Schedule </p>
<p>Example of encrypting a block: </p><div class="fragment"><div class="line"><a class="code" href="class_c_t_r.html">CTR</a> cipher(Enumeration::BlockCiphers::SHX);</div>
<div class="line"><span class="comment">// initialize for encryption</span></div>
<div class="line">cipher.Initialize(<span class="keyword">true</span>, <a class="code" href="class_symmetric_key.html">SymmetricKey</a>(<a class="code" href="group___digest.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>, <a class="code" href="group___digest.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">Nonce</a>));</div>
<div class="line"><span class="comment">// encrypt a block</span></div>
<div class="line">cipher.Transform(Input, 0, Output, 0);</div>
</div><!-- fragment --> <p>Description: </p>
<p>SHX is a Serpent implementation that can use a standard configuration on key sizes up to 32 bytes (256 bits), an extended key size of 64 bytes (512 bits), or unlimited key sizes greater than 64 bytes. <br />
On <a class="el" href="class_s_h_x.html#a5c7006f75c0b2e55ea722f55f2b2942d" title="Read Only: Available Encryption Key Sizes in bytes ">LegalKeySizes</a> larger than 64 bytes, an HKDF random bytes generator is used to expand the <code>working key</code> integer array. <br />
In HKDF extended mode, the number of <code>transformation rounds</code> can be user assigned (through the constructor) to between 16 and 64 rounds. Increasing the number of transformation rounds processed within the ciphers rounds function creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. <br />
SHX is capable of processing up to 64 rounds, that is twice the number of rounds used in a standard implementation of Serpent. When using e.g. SHA-2 256, a minimum key size for is 32 bytes, further blocks of can be added to the key so long as they align; (n * hash size), ex. 64, 128, 192 bytes.. there is no upper maximum. </p>
<p>Changes to SHX Version 1.2: </p>
<p>Version 1.2 of the cipher has changes to the HKDF powered key schedule, which may make it incompatable with previous versions of the cipher. <br />
Previous versions split the key into salt and key arrays, and processed these arrays with the HKDF Extract step, which compresses the key material into a pseudo random key used to initialize the HMAC. <br />
The previous versions also added the Info parameter through the HKDF Initialize(key, salt, info) function. <br />
The Info parameter is now set through a property added to the HKDF implementation, so using the Initialize function to load the Info string is no longer required. <br />
This allows for loading the key into HKDF with the Initialize(key) function, which bypasses the extract step, but can still use the Info parameter to provide additional entropy. <br />
The key is used by HKDF to initialize the HMAC. The HMAC key can use up to the hash functions internal block size before a compression cycle is called, reducing the key size to the hash functions output size. <br />
The best size for maximum security is to set the HMAC key to the hash functions block size, this initializes the HMAC with a full block of keying material. <br />
HKDF cycles it's internal state, a one byte counter, and the Info parameter through the HMAC to generate the expanded key. <br />
For best security, it is desirable to have the HMAC process input equal to the hash functions block size, i.e. no zero byte padding is processed by the compression function. <br />
The Info parameter can now be used as an additional source of keying material, if sized to the DistributionCodeMax() property, blocks of state+counter+info are equal to the hash functions block size, this is the best possible security configuration.</p>
<p>When using SHA-2 256, a minimum key size for SHX is 32 bytes, larger lengths of input key can be used so long as it aligns; (n * hash size), ex. 64, 128, 192 bytes.. there is no upper maximum. <br />
The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake2, Keccak, SHA-2 or Skein. <br />
Valid key sizes can be determined at runtime using the <a class="el" href="class_s_h_x.html#a5c7006f75c0b2e55ea722f55f2b2942d" title="Read Only: Available Encryption Key Sizes in bytes ">LegalKeySizes</a> property, based on the digest selected. When using the extended mode, the legal key sizes are determined based on the selected digests hash output size, ex. SHA256 the minimum legal key size is 256 bits (32 bytes), the recommended size is 2* the hash size, or 512 bits (64 bytes). <br />
The number of transformation rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. <br />
SHX is capable of processing up to 64 rounds, that is thirty-two rounds more than the standard 32 rounds used in an implementation of Serpent. <br />
Valid rounds assignments can be found in the <a class="el" href="class_s_h_x.html#a69cfb0400aab1523c0299d1c8663bada" title="Read Only: Available transformation round assignments ">LegalRounds</a> property.</p>
<p>Implementation Notes: </p><ul>
<li>
An input key of up to 64 bytes in length will use a standard key schedule for internal key expansion; greater than 64 bytes implements the HKDF key schedule. </li>
<li>
The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake2, Keccak, SHA-2 or Skein. </li>
<li>
The HKDF Digest engine is definable through the <a class="el" href="#a0b570e0c33a4e517106936f2782f34f4a845f4e55e4b1e40154a7251f294acbdd">Constructor</a> type enumeration parameter: Digest. </li>
<li>
Minimum HKDF key size is the Digests Hash output size, recommended is 2* the minimum, or increments of (n * hash-size) in bytes. </li>
<li>
The recommended size for maximum security is 2* the digests block size; this calls HKDF Extract using full blocks of key and salt. </li>
<li>
Valid key sizes can be determined at run time using the <a class="el" href="class_s_h_x.html#a5c7006f75c0b2e55ea722f55f2b2942d" title="Read Only: Available Encryption Key Sizes in bytes ">LegalKeySizes</a> property. </li>
<li>
The internal block size is 16 bytes wide. </li>
<li>
Diffusion rounds assignments are 32, 40, 48, 56, and 64 rounds, default is 32 (128-256 bit key), a 512 bit key is automatically assigned 40 rounds. </li>
<li>
Valid rounds assignments can be found in the LegalRounds property. </li>
</ul>
<p>Guiding Publications: </p><ol>
<li>
Serpent: <a href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</a>. </li>
<li>
HMAC <a href="http://tools.ietf.org/html/rfc2104">RFC 2104</a>. </li>
<li>
Fips <a href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</a>. </li>
<li>
HKDF <a href="http://tools.ietf.org/html/rfc5869">RFC 5869</a>. </li>
<li>
NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>. </li>
<li>
SHA3 <a href="https://131002.net/blake/blake.pdf">The Blake digest</a>. </li>
<li>
SHA3 <a href="http://keccak.noekeon.org/Keccak-submission-3.pdf">The Keccak digest</a>. </li>
<li>
SHA3 <a href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">The Skein digest</a>. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a947459e40103c2a6914dd40975a8241e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SHX::SHX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_h_x.html">SHX</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: copy is restricted, this function has been deleted </p>

</div>
</div>
<a class="anchor" id="ac5ad63b6940c8b5002ecab75fe55606e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SHX::SHX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumeration.html#gab52dd4d279d842e68f46a2a0499c10c3">Digests</a>&#160;</td>
          <td class="paramname"><em>DigestType</em> = <code>Digests::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Rounds</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiate the class with optional transformation rounds, and KDF engine type settings </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DigestType</td><td>The Key Schedule KDF digest engine; can be any one of the Digest implementations. The default engine is None, which invokes the standard key schedule mechanism.</td></tr>
    <tr><td class="paramname">Rounds</td><td>Number of transformation rounds. The <a class="el" href="class_s_h_x.html#a69cfb0400aab1523c0299d1c8663bada" title="Read Only: Available transformation round assignments ">LegalRounds</a> property contains available sizes. Default is 32 rounds with a 128-256 bit key, 40 rounds with a 512 bit key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception::CryptoSymmetricCipherException</td><td>Thrown if an invalid rounds count is chosen</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6365f6f7ae249876e33debc86e51f7d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SHX::SHX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_digest.html">IDigest</a> *&#160;</td>
          <td class="paramname"><em>Digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Rounds</em> = <code>40</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiate the class with a Digest instance (HKDF mode), and with optional transformation rounds settings </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Digest</td><td>The Key Schedule HKDF digest engine instance; can be any one of the message Digest implementations.</td></tr>
    <tr><td class="paramname">Rounds</td><td>Number of transformation rounds. The <a class="el" href="class_s_h_x.html#a69cfb0400aab1523c0299d1c8663bada" title="Read Only: Available transformation round assignments ">LegalRounds</a> property contains available sizes. Default is 40 rounds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception::CryptoSymmetricCipherException</td><td>Thrown if an invalid rounds count is chosen</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac729986516e62fbb21cc0812d82f77d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SHX::~SHX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor: finalize this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a55d73865bee9745ae15d76b07aee91a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t SHX::BlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Unit block size of internal cipher in bytes. </p>
<p>Block size must be 16 or 32 bytes wide. Value set in class constructor.</p>

<p>Implements <a class="el" href="class_i_block_cipher.html#aa707b80fdc28494d5d036d921181d17b">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="ac192252a9b19b528474cad6704baf772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::DecryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt a single block of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called with the Encryption flag set to <code>false</code> before this method can be used. Input and Output arrays must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes. ">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>Encrypted bytes</td></tr>
    <tr><td class="paramname">Output</td><td>Decrypted bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_block_cipher.html#a5978f9cc97448d92315fe12d85ccb840">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a0e5ba9f06e186169823a401f6ecebcb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::DecryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt a block of bytes with offset parameters. </p>
<p>Initialize(bool, ISymmetricKey) must be called with the Encryption flag set to <code>false</code> before this method can be used. Input and Output arrays with Offsets must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes. ">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>Encrypted bytes</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset within the input array</td></tr>
    <tr><td class="paramname">Output</td><td>Decrypted bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset within the output array</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_block_cipher.html#a3370f02c8d53f5c2d9d70d46260bd832">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a433739e562fa270770d5f123a693e959"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; byte &gt; &amp; SHX::DistributionCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read/Write: Reads or Sets the Info (personalization string) value in the HKDF initialization parameters. </p>
<p>Changing this code will create a unique distribution of the cipher. Code can be sized as either a zero byte array, or any length up to the DistributionCodeMax size. For best security, the distribution code should be random, secret, and equal in length to the DistributionCodeMax size. Note: If the Info parameter of an ISymmetricKey is non-zero, it will overwrite the distribution code.</p>

<p>Implements <a class="el" href="class_i_block_cipher.html#adc9422a89fa5a4c5c8bc103485d6b5a5">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="aaea6e92b9321ad8acc1398a3f5cecb89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t SHX::DistributionCodeMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The maximum size of the distribution code in bytes. </p>
<p>The distribution code can be used as a secondary source of entropy (secret) in the HKDF key expansion phase. For best security, the distribution code should be random, secret, and equal in size to this value.</p>

<p>Implements <a class="el" href="class_i_block_cipher.html#af3d0e675040f543a4e80eb05cb69ac54">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="ae55de346752869ad04bea165a1766e1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::EncryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt a block of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called with the Encryption flag set to <code>true</code> before this method can be used. Input and Output array lengths must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes. ">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_block_cipher.html#a5afbd45c0dc15bfcc8d2caa8446d78b3">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a13cbc84fd64a7dc5d9937ffebaabb470"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::EncryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt a block of bytes with offset parameters. </p>
<p>Initialize(bool, ISymmetricKey) must be called with the Encryption flag set to <code>true</code> before this method can be used. Input and Output arrays with Offsets must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes. ">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset within the input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset within the output array</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_block_cipher.html#a1c1a582ff888fd9d6ab2acaab52016b7">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="af434ded19889286371bcf7861196f215"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a> SHX::Enumeral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The block ciphers type name </p>

<p>Implements <a class="el" href="class_i_block_cipher.html#a12c496427a3455d2507e23f8df972032">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="ace967cd9459e1f501b8cf32b9906fc69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Initialize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Encryption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;&#160;</td>
          <td class="paramname"><em>KeyParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the cipher </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Encryption</td><td>Using Encryption or Decryption mode</td></tr>
    <tr><td class="paramname">KeyParams</td><td>Cipher key container. </td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="class_s_h_x.html#a5c7006f75c0b2e55ea722f55f2b2942d" title="Read Only: Available Encryption Key Sizes in bytes ">LegalKeySizes</a> property contains valid sizes.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception::CryptoSymmetricCipherException</td><td>Thrown if a null or invalid key is used</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_block_cipher.html#a291ee6dc9febd2c60252ae40874647ee">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb576085c0558aecb5d0299344c2c1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool SHX::IsEncryption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Initialized for encryption, false for decryption. </p>
<p>Value set in Initialize(bool, ISymmetricKey).</p>

<p>Implements <a class="el" href="class_i_block_cipher.html#a4954469eeff9859033f2a04c85b039f2">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="ac4ea567917110bd918296b618851ba9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool SHX::IsInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Cipher is ready to transform data </p>

<p>Implements <a class="el" href="class_i_block_cipher.html#a5119952207cba4278018ef18f124dede">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a512d2284eb6705001f4923b34491cff4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___enumeration.html#gab52dd4d279d842e68f46a2a0499c10c3">Digests</a> SHX::KdfEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The extended ciphers HKDF digest type </p>

<p>Implements <a class="el" href="class_i_block_cipher.html#a3a69673f9b34f7a1314cb9c6d6277414">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a5c7006f75c0b2e55ea722f55f2b2942d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp; SHX::LegalKeySizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Available Encryption Key Sizes in bytes </p>

<p>Implements <a class="el" href="class_i_block_cipher.html#adc95238bcc57bbe8aba3172ca7e08500">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a69cfb0400aab1523c0299d1c8663bada"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; size_t &gt; &amp; SHX::LegalRounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Available transformation round assignments </p>

<p>Implements <a class="el" href="class_i_block_cipher.html#a1a53de47d181089e850e6b6076fdd5e7">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="ae9fad5c65ff282d1064cdbdf71e414f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SHX::Name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The block ciphers class name </p>

<p>Implements <a class="el" href="class_i_block_cipher.html#a56fd25fd94bf58bfcdefa40250949879">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="ab7cb46bd84672148ca65465cadccde0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_h_x.html">SHX</a>&amp; SHX::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_h_x.html">SHX</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator: copy is restricted, this function has been deleted </p>

</div>
</div>
<a class="anchor" id="a5610f0429f24030730a3072a0390d431"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t SHX::Rounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The number of transformation rounds processed by the transform </p>

<p>Implements <a class="el" href="class_i_block_cipher.html#a9c3885fbc9415e2c73de3129cee57878">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="ac2810f584c4cb58792b07c36df64acf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t SHX::StateCacheSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The sum size in bytes (plus some allowance for externals) of the classes persistant state. </p>
<p>Used in the parallel block size calculations, to reduce the occurence of L1 cache eviction of hot tables and class variables. This is a timing and performance optimization, see the ParallelOptions class for more details.</p>

<p>Implements <a class="el" href="class_i_block_cipher.html#a0aa770c83a60b635d25178010cb15594">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a6c3a38afd6bfba3da04e7f0d7aa4bdb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Transform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a block of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called before this method can be used. Input and Output array lengths must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes. ">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform or Decrypt</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_block_cipher.html#aa9a9542b0be429aeaa5e9795ba505e26">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a0d46323c3a0c7f5b0d92cf20e8efac7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Transform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a block of bytes with offset parameters. </p>
<p>Initialize(bool, ISymmetricKey) must be called before this method can be used. Input and Output arrays with Offsets must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes. ">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset in the Input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset in the output array</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_block_cipher.html#a76f5fbd6d28ecdf33ff47ec49ba15515">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="adb00192f15984eadd77b5cc2ba91298d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Transform1024 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform 8 blocks of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called before this method can be used. Input and Output array lengths must be at least 8 * <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes. ">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset in the Input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset in the output array</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_block_cipher.html#aa50e4afbd949b71f4dbe8b0d15d6c6ee">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a17dc1b611c104db2c21e5672b9086be4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Transform2048 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform 16 blocks of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called before this method can be used. Input and Output array lengths must be at least 16 * <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes. ">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset in the Input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset in the output array</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_block_cipher.html#a3c87c4315d106923e4a7726e9ed491c8">IBlockCipher</a>.</p>

</div>
</div>
<a class="anchor" id="a5bf52d2a29c15cab5ab3bfe672f9befc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Transform512 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform 4 blocks of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called before this method can be used. Input and Output array lengths must be at least 4 * <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes. ">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset in the Input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset in the output array</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_block_cipher.html#a1294f494382cb548d9a79bd6f8c7958a">IBlockCipher</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>CEX/<a class="el" href="_documentation_8h_source.html">Documentation.h</a></li>
<li>CEX/<a class="el" href="_s_h_x_8h_source.html">SHX.h</a></li>
<li>CEX/SHX.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
