<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CEX++: SHX Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CEX++
   &#160;<span id="projectnumber">1.0.0.8f</span>
   </div>
   <div id="projectbrief">The CEX Cryptographic Library in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_s_h_x-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SHX Class Reference<div class="ingroups"><a class="el" href="group___c_e_x.html">CEX</a> &raquo; <a class="el" href="group___cipher.html">Cipher</a> &raquo; <a class="el" href="group___block.html">Block</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A Serpent cipher using either standard modes, or extended modes of operation using a HKDF(SHA2) or cSHAKE key schedule, and increased transformation rounds.  
 <a href="class_s_h_x.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_h_x_8h_source.html">SHX.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a947459e40103c2a6914dd40975a8241e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a947459e40103c2a6914dd40975a8241e">SHX</a> (const <a class="el" href="class_s_h_x.html">SHX</a> &amp;)=delete</td></tr>
<tr class="memdesc:a947459e40103c2a6914dd40975a8241e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="class_s_h_x.html#a947459e40103c2a6914dd40975a8241e">More...</a><br /></td></tr>
<tr class="separator:a947459e40103c2a6914dd40975a8241e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cb46bd84672148ca65465cadccde0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_h_x.html">SHX</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ab7cb46bd84672148ca65465cadccde0c">operator=</a> (const <a class="el" href="class_s_h_x.html">SHX</a> &amp;)=delete</td></tr>
<tr class="memdesc:ab7cb46bd84672148ca65465cadccde0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="class_s_h_x.html#ab7cb46bd84672148ca65465cadccde0c">More...</a><br /></td></tr>
<tr class="separator:ab7cb46bd84672148ca65465cadccde0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae490b0b43d32e37f3ae7c5a6ff4c9854"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ae490b0b43d32e37f3ae7c5a6ff4c9854">SHX</a> (BlockCipherExtensions CipherExtensionType=BlockCipherExtensions::None)</td></tr>
<tr class="memdesc:ae490b0b43d32e37f3ae7c5a6ff4c9854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate the class with an optional block-cipher extension type.  <a href="class_s_h_x.html#ae490b0b43d32e37f3ae7c5a6ff4c9854">More...</a><br /></td></tr>
<tr class="separator:ae490b0b43d32e37f3ae7c5a6ff4c9854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77df595f2fad82317b911f06a2bfaec8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a77df595f2fad82317b911f06a2bfaec8">SHX</a> (<a class="el" href="class_i_kdf.html">IKdf</a> *Kdf)</td></tr>
<tr class="memdesc:a77df595f2fad82317b911f06a2bfaec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate the class with a Key Derivation Function instance.  <a href="class_s_h_x.html#a77df595f2fad82317b911f06a2bfaec8">More...</a><br /></td></tr>
<tr class="separator:a77df595f2fad82317b911f06a2bfaec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac729986516e62fbb21cc0812d82f77d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ac729986516e62fbb21cc0812d82f77d5">~SHX</a> () override</td></tr>
<tr class="memdesc:ac729986516e62fbb21cc0812d82f77d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="class_s_h_x.html#ac729986516e62fbb21cc0812d82f77d5">More...</a><br /></td></tr>
<tr class="separator:ac729986516e62fbb21cc0812d82f77d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d73865bee9745ae15d76b07aee91a3"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3">BlockSize</a> () override</td></tr>
<tr class="memdesc:a55d73865bee9745ae15d76b07aee91a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Unit block size of internal cipher in bytes.  <a href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3">More...</a><br /></td></tr>
<tr class="separator:a55d73865bee9745ae15d76b07aee91a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af434ded19889286371bcf7861196f215"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#af434ded19889286371bcf7861196f215">Enumeral</a> () override</td></tr>
<tr class="memdesc:af434ded19889286371bcf7861196f215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The block ciphers enumeration type name  <a href="class_s_h_x.html#af434ded19889286371bcf7861196f215">More...</a><br /></td></tr>
<tr class="separator:af434ded19889286371bcf7861196f215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb576085c0558aecb5d0299344c2c1c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a8fb576085c0558aecb5d0299344c2c1c">IsEncryption</a> () override</td></tr>
<tr class="memdesc:a8fb576085c0558aecb5d0299344c2c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Initialized for encryption, false for decryption.  <a href="class_s_h_x.html#a8fb576085c0558aecb5d0299344c2c1c">More...</a><br /></td></tr>
<tr class="separator:a8fb576085c0558aecb5d0299344c2c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ea567917110bd918296b618851ba9f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ac4ea567917110bd918296b618851ba9f">IsInitialized</a> () override</td></tr>
<tr class="memdesc:ac4ea567917110bd918296b618851ba9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Cipher is ready to transform data  <a href="class_s_h_x.html#ac4ea567917110bd918296b618851ba9f">More...</a><br /></td></tr>
<tr class="separator:ac4ea567917110bd918296b618851ba9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7006f75c0b2e55ea722f55f2b2942d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a5c7006f75c0b2e55ea722f55f2b2942d">LegalKeySizes</a> () override</td></tr>
<tr class="memdesc:a5c7006f75c0b2e55ea722f55f2b2942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: A list of SymmetricKeySize structures containing valid key-sizes  <a href="class_s_h_x.html#a5c7006f75c0b2e55ea722f55f2b2942d">More...</a><br /></td></tr>
<tr class="separator:a5c7006f75c0b2e55ea722f55f2b2942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fad5c65ff282d1064cdbdf71e414f2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ae9fad5c65ff282d1064cdbdf71e414f2">Name</a> () override</td></tr>
<tr class="memdesc:ae9fad5c65ff282d1064cdbdf71e414f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The block ciphers formal class name  <a href="class_s_h_x.html#ae9fad5c65ff282d1064cdbdf71e414f2">More...</a><br /></td></tr>
<tr class="separator:ae9fad5c65ff282d1064cdbdf71e414f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5610f0429f24030730a3072a0390d431"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a5610f0429f24030730a3072a0390d431">Rounds</a> () override</td></tr>
<tr class="memdesc:a5610f0429f24030730a3072a0390d431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The number of transformation rounds processed by the rounds function  <a href="class_s_h_x.html#a5610f0429f24030730a3072a0390d431">More...</a><br /></td></tr>
<tr class="separator:a5610f0429f24030730a3072a0390d431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2810f584c4cb58792b07c36df64acf4"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ac2810f584c4cb58792b07c36df64acf4">StateCacheSize</a> () override</td></tr>
<tr class="memdesc:ac2810f584c4cb58792b07c36df64acf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The sum size in bytes (plus some allowance for externals) of the classes persistant state.  <a href="class_s_h_x.html#ac2810f584c4cb58792b07c36df64acf4">More...</a><br /></td></tr>
<tr class="separator:ac2810f584c4cb58792b07c36df64acf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac192252a9b19b528474cad6704baf772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ac192252a9b19b528474cad6704baf772">DecryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:ac192252a9b19b528474cad6704baf772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a single block of bytes.  <a href="class_s_h_x.html#ac192252a9b19b528474cad6704baf772">More...</a><br /></td></tr>
<tr class="separator:ac192252a9b19b528474cad6704baf772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5588e989fc7dd114a5b9dd4b2b7f964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#aa5588e989fc7dd114a5b9dd4b2b7f964">DecryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, size_t InOffset, std::vector&lt; byte &gt; &amp;Output, size_t OutOffset) override</td></tr>
<tr class="memdesc:aa5588e989fc7dd114a5b9dd4b2b7f964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a block of bytes with offset parameters.  <a href="class_s_h_x.html#aa5588e989fc7dd114a5b9dd4b2b7f964">More...</a><br /></td></tr>
<tr class="separator:aa5588e989fc7dd114a5b9dd4b2b7f964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55de346752869ad04bea165a1766e1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ae55de346752869ad04bea165a1766e1c">EncryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:ae55de346752869ad04bea165a1766e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a block of bytes.  <a href="class_s_h_x.html#ae55de346752869ad04bea165a1766e1c">More...</a><br /></td></tr>
<tr class="separator:ae55de346752869ad04bea165a1766e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47ecae45336414ae0cd06247c4aa431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ac47ecae45336414ae0cd06247c4aa431">EncryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, size_t InOffset, std::vector&lt; byte &gt; &amp;Output, size_t OutOffset) override</td></tr>
<tr class="memdesc:ac47ecae45336414ae0cd06247c4aa431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a block of bytes with offset parameters.  <a href="class_s_h_x.html#ac47ecae45336414ae0cd06247c4aa431">More...</a><br /></td></tr>
<tr class="separator:ac47ecae45336414ae0cd06247c4aa431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebed156807720a5585cfe52ccbe5d4e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#aebed156807720a5585cfe52ccbe5d4e3">Initialize</a> (bool Encryption, <a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;Parameters) override</td></tr>
<tr class="memdesc:aebed156807720a5585cfe52ccbe5d4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the cipher with a populated SymmetricKey or SymmetricSecureKey container  <a href="class_s_h_x.html#aebed156807720a5585cfe52ccbe5d4e3">More...</a><br /></td></tr>
<tr class="separator:aebed156807720a5585cfe52ccbe5d4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3a38afd6bfba3da04e7f0d7aa4bdb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a6c3a38afd6bfba3da04e7f0d7aa4bdb9">Transform</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:a6c3a38afd6bfba3da04e7f0d7aa4bdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a block of bytes.  <a href="class_s_h_x.html#a6c3a38afd6bfba3da04e7f0d7aa4bdb9">More...</a><br /></td></tr>
<tr class="separator:a6c3a38afd6bfba3da04e7f0d7aa4bdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556c809f434cb97807e5c4c147d0d4d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a556c809f434cb97807e5c4c147d0d4d7">Transform</a> (const std::vector&lt; byte &gt; &amp;Input, size_t InOffset, std::vector&lt; byte &gt; &amp;Output, size_t OutOffset) override</td></tr>
<tr class="memdesc:a556c809f434cb97807e5c4c147d0d4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a block of bytes with offset parameters.  <a href="class_s_h_x.html#a556c809f434cb97807e5c4c147d0d4d7">More...</a><br /></td></tr>
<tr class="separator:a556c809f434cb97807e5c4c147d0d4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d671dde863449b25851325ba8c967a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ae2d671dde863449b25851325ba8c967a">Transform512</a> (const std::vector&lt; byte &gt; &amp;Input, size_t InOffset, std::vector&lt; byte &gt; &amp;Output, size_t OutOffset) override</td></tr>
<tr class="memdesc:ae2d671dde863449b25851325ba8c967a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform 4 blocks of bytes.  <a href="class_s_h_x.html#ae2d671dde863449b25851325ba8c967a">More...</a><br /></td></tr>
<tr class="separator:ae2d671dde863449b25851325ba8c967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092a1084a2e24063579a42c2f0c74b21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#a092a1084a2e24063579a42c2f0c74b21">Transform1024</a> (const std::vector&lt; byte &gt; &amp;Input, size_t InOffset, std::vector&lt; byte &gt; &amp;Output, size_t OutOffset) override</td></tr>
<tr class="memdesc:a092a1084a2e24063579a42c2f0c74b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform 8 blocks of bytes.  <a href="class_s_h_x.html#a092a1084a2e24063579a42c2f0c74b21">More...</a><br /></td></tr>
<tr class="separator:a092a1084a2e24063579a42c2f0c74b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e91c3202dbfd577a5bf92fde230525"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_h_x.html#ab3e91c3202dbfd577a5bf92fde230525">Transform2048</a> (const std::vector&lt; byte &gt; &amp;Input, size_t InOffset, std::vector&lt; byte &gt; &amp;Output, size_t OutOffset) override</td></tr>
<tr class="memdesc:ab3e91c3202dbfd577a5bf92fde230525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform 16 blocks of bytes.  <a href="class_s_h_x.html#ab3e91c3202dbfd577a5bf92fde230525">More...</a><br /></td></tr>
<tr class="separator:ab3e91c3202dbfd577a5bf92fde230525"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Serpent cipher using either standard modes, or extended modes of operation using a HKDF(SHA2) or cSHAKE key schedule, and increased transformation rounds. </p>
<p>This cipher should not be used directly but through a cipher mode, or as part of a larger construction.</p>
<p>Example of encrypting a block: </p><div class="fragment"><div class="line"><a class="code" href="class_c_t_r.html">CTR</a> cipher(Enumeration::BlockCiphers::SHX);</div>
<div class="line"><span class="comment">// initialize for encryption</span></div>
<div class="line">cipher.Initialize(<span class="keyword">true</span>, <a class="code" href="class_symmetric_key.html">SymmetricKey</a>(<a class="code" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>, <a class="code" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">Nonce</a>));</div>
<div class="line"><span class="comment">// encrypt a block</span></div>
<div class="line">cipher.Transform(Input, 0, Output, 0);</div>
</div><!-- fragment --> <p>Description: </p>
<p>SHX is a Serpent implementation that can use either a standard configuration with key sizes of up to 32 bytes (256 bits), or an extended mode using key sizes of 32, 64, and 128 bytes, (256, 512, and 1024 bits). <br  />
In extended mode, the number of transformation rounds are set to 40, 48 and 64 rounds corresponding to the 256, 512, and 1024 input cipher key sizes. <br  />
Increasing the number of transformation rounds processed by the ciphers rounds function creates a more diffused output, making the resulting cipher-text more resistant to some forms of cryptanalysis. <br  />
SHX is capable of processing up to 64 rounds, that is twice the number of rounds used in a standard implementation of Serpent. </p>
<p>Implementation Notes: </p>
<p>The key schedule in SHX, and the number of transformation rounds processed are the difference between the extended mode operations, and a standard version of Serpent. The standard Serpent Key Schedule processes 128, 192, and 256 bit keys, and is fixed at 32 transformation rounds, the extended version of the cipher processes 256, 512, and 1024-bit keys and up to 64 rounds. <br  />
SHX extended mode can use an HMAC based Key Derivation Function; HKDF(HMAC(SHA2)) or the Keccak XOF function cSHAKE, to expand the cipher key to create the internal round-key integer array. <br  />
This provides better security, and allows for an implemetation to safely use an increased number of transformation rounds. <br  />
The cipher can also use a user-definable cipher tweak through the Info parameter of the symmetric key container, this can be used to create a unique cipher-text output. <br  />
This tweak array is set as either the information string for HKDF, or as the cSHAKE name string.</p>
<p>When using the extended mode of the cipher, the minimum key size is 32 bytes (256 bits), and valid key sizes are 256, 512, and 1024 bits long. <br  />
SHX is capable of processing up to 64 rounds, that is twice the number of mixing rounds set in a standard implementation of Serpent; in extended mode a 256-bit key uses 40 rounds, a 512-bit key 48 rounds, and a 1024-bit key is set to 64 rounds.</p>
<ul>
<li>
This cipher should only be used in conjunction with an AEAD or standard cipher mode, or as an component in another construction, ex. CMAC. </li>
<li>
Valid key sizes can be determined at run-time using the <a class="el" href="class_s_h_x.html#a5c7006f75c0b2e55ea722f55f2b2942d" title="Read Only: A list of SymmetricKeySize structures containing valid key-sizes">LegalKeySizes</a> property. collection. </li>
<li>
The internal block-size is fixed at 16 bytes (128 bits) wide. </li>
<li>
The cipher can process 128, 192, and 256-bit keys in standard mode, and 256, 512, and 1024-bit keys in extended mode. </li>
<li>
Transformation rounds assignments are 32 in standard modes, and 40, 48, and 64 rounds (256, 512, and 1024-bit keys). </li>
<li>
The Info parameter in a symmetric key container is a user-definable cipher tweak, this can be used to create a unique cipher-text output with a secondary secret. </li>
<li>
Extended mode is set through the constructors BlockCipherExtensions parameter to either None for standard mode, or HKDF(SHA2-256), HKDF(SHA2-512), cSHAKE256, cSHAKE512, or cSHAKE1024 for extended mode operation. </li>
<li>
It is recommended that in extended mode, the key expansion functions security match the key size used; ex. with a 256-bit key use SHAKE-256, or HKDF(SHA2-512) for a 512-bit key. </li>
</ul>
<p>Guiding Publications: </p><ol>
<li>
Serpent: <a href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</a>. </li>
<li>
HMAC <a href="http://tools.ietf.org/html/rfc2104">RFC 2104</a>. </li>
<li>
Fips <a href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</a>. </li>
<li>
HKDF <a href="http://tools.ietf.org/html/rfc5869">RFC 5869</a>. </li>
<li>
NIST <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</a>. </li>
<li>
SHA3 <a href="http://keccak.noekeon.org/Keccak-submission-3.pdf">The Keccak digest</a>. </li>
<li>
FIPS 202: <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">Permutation Based Hash</a> and Extendable Output Functions </li>
<li>
NIST <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf">SP800-185</a> SHA-3 Derived Functions. </li>
<li>
Team Keccak <a href="https://keccak.team/index.html">Homepage</a>. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a947459e40103c2a6914dd40975a8241e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947459e40103c2a6914dd40975a8241e">&#9670;&nbsp;</a></span>SHX() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SHX::SHX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_h_x.html">SHX</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: copy is restricted, this function has been deleted </p>

</div>
</div>
<a id="ae490b0b43d32e37f3ae7c5a6ff4c9854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae490b0b43d32e37f3ae7c5a6ff4c9854">&#9670;&nbsp;</a></span>SHX() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SHX::SHX </td>
          <td>(</td>
          <td class="paramtype">BlockCipherExtensions&#160;</td>
          <td class="paramname"><em>CipherExtensionType</em> = <code>BlockCipherExtensions::None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiate the class with an optional block-cipher extension type. </p>
<p>It is recommended that in extended mode operation, the key expansion functions security match the key size used; ex. with a 256-bit key use SHAKE-256, or, HKDF(SHA2-512) for a 512-bit key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CipherExtensionType</td><td>Sets the optional Key Schedule key-expansion function; valid options are cSHAKE, HKDF, or None for standard mode. </td></tr>
  </table>
  </dd>
</dl>
<p>The default engine is None, which invokes the standard key schedule mechanism.</p>

</div>
</div>
<a id="a77df595f2fad82317b911f06a2bfaec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77df595f2fad82317b911f06a2bfaec8">&#9670;&nbsp;</a></span>SHX() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SHX::SHX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_kdf.html">IKdf</a> *&#160;</td>
          <td class="paramname"><em>Kdf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiate the class with a Key Derivation Function instance. </p>
<p>It is recommended that in extended mode operation, the key expansion functions security match the key size used; ex. with a 256-bit key use SHAKE-256, or, HKDF(SHA2-512) for a 512-bit key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kdf</td><td>The Key Schedule KDF engine instance; can be null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac729986516e62fbb21cc0812d82f77d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac729986516e62fbb21cc0812d82f77d5">&#9670;&nbsp;</a></span>~SHX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SHX::~SHX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor: finalize this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a55d73865bee9745ae15d76b07aee91a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d73865bee9745ae15d76b07aee91a3">&#9670;&nbsp;</a></span>BlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t SHX::BlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Unit block size of internal cipher in bytes. </p>

</div>
</div>
<a id="aa5588e989fc7dd114a5b9dd4b2b7f964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5588e989fc7dd114a5b9dd4b2b7f964">&#9670;&nbsp;</a></span>DecryptBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::DecryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt a block of bytes with offset parameters. </p>
<p>Initialize(bool, ISymmetricKey) must be called with the Encryption flag set to <code>false</code> before this method can be used. Input and Output arrays with Offsets must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes.">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>Encrypted bytes</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset within the input array</td></tr>
    <tr><td class="paramname">Output</td><td>Decrypted bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset within the output array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac192252a9b19b528474cad6704baf772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac192252a9b19b528474cad6704baf772">&#9670;&nbsp;</a></span>DecryptBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::DecryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt a single block of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called with the Encryption flag set to <code>false</code> before this method can be used. Input and Output arrays must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes.">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>Encrypted bytes</td></tr>
    <tr><td class="paramname">Output</td><td>Decrypted bytes</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac47ecae45336414ae0cd06247c4aa431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47ecae45336414ae0cd06247c4aa431">&#9670;&nbsp;</a></span>EncryptBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::EncryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt a block of bytes with offset parameters. </p>
<p>Initialize(bool, ISymmetricKey) must be called with the Encryption flag set to <code>true</code> before this method can be used. Input and Output arrays with Offsets must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes.">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset within the input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset within the output array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae55de346752869ad04bea165a1766e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55de346752869ad04bea165a1766e1c">&#9670;&nbsp;</a></span>EncryptBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::EncryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt a block of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called with the Encryption flag set to <code>true</code> before this method can be used. Input and Output array lengths must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes.">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af434ded19889286371bcf7861196f215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af434ded19889286371bcf7861196f215">&#9670;&nbsp;</a></span>Enumeral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a> SHX::Enumeral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The block ciphers enumeration type name </p>

</div>
</div>
<a id="aebed156807720a5585cfe52ccbe5d4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebed156807720a5585cfe52ccbe5d4e3">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Initialize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Encryption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;&#160;</td>
          <td class="paramname"><em>Parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the cipher with a populated SymmetricKey or SymmetricSecureKey container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Encryption</td><td>Using Encryption or Decryption mode</td></tr>
    <tr><td class="paramname">Parameters</td><td>Cipher key container. </td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="class_s_h_x.html#a5c7006f75c0b2e55ea722f55f2b2942d" title="Read Only: A list of SymmetricKeySize structures containing valid key-sizes">LegalKeySizes</a> property contains valid sizes.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoSymmetricException</td><td>Thrown if a null or invalid key is used</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fb576085c0558aecb5d0299344c2c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb576085c0558aecb5d0299344c2c1c">&#9670;&nbsp;</a></span>IsEncryption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool SHX::IsEncryption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Initialized for encryption, false for decryption. </p>
<p>Value set in Initialize(bool, ISymmetricKey).</p>

</div>
</div>
<a id="ac4ea567917110bd918296b618851ba9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ea567917110bd918296b618851ba9f">&#9670;&nbsp;</a></span>IsInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool SHX::IsInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Cipher is ready to transform data </p>

</div>
</div>
<a id="a5c7006f75c0b2e55ea722f55f2b2942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7006f75c0b2e55ea722f55f2b2942d">&#9670;&nbsp;</a></span>LegalKeySizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp; SHX::LegalKeySizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: A list of SymmetricKeySize structures containing valid key-sizes </p>

</div>
</div>
<a id="ae9fad5c65ff282d1064cdbdf71e414f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fad5c65ff282d1064cdbdf71e414f2">&#9670;&nbsp;</a></span>Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SHX::Name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The block ciphers formal class name </p>

</div>
</div>
<a id="ab7cb46bd84672148ca65465cadccde0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cb46bd84672148ca65465cadccde0c">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_h_x.html">SHX</a>&amp; SHX::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_h_x.html">SHX</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator: copy is restricted, this function has been deleted </p>

</div>
</div>
<a id="a5610f0429f24030730a3072a0390d431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5610f0429f24030730a3072a0390d431">&#9670;&nbsp;</a></span>Rounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t SHX::Rounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The number of transformation rounds processed by the rounds function </p>

</div>
</div>
<a id="ac2810f584c4cb58792b07c36df64acf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2810f584c4cb58792b07c36df64acf4">&#9670;&nbsp;</a></span>StateCacheSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t SHX::StateCacheSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The sum size in bytes (plus some allowance for externals) of the classes persistant state. </p>
<p>Used in the parallel block size calculations, to reduce the occurence of L1 cache eviction of hot tables and class variables. This is a timing and performance optimization, see the ParallelOptions class for more details.</p>

</div>
</div>
<a id="a556c809f434cb97807e5c4c147d0d4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556c809f434cb97807e5c4c147d0d4d7">&#9670;&nbsp;</a></span>Transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Transform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a block of bytes with offset parameters. </p>
<p>Initialize(bool, ISymmetricKey) must be called before this method can be used. Input and Output arrays with Offsets must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes.">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset in the Input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset in the output array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c3a38afd6bfba3da04e7f0d7aa4bdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3a38afd6bfba3da04e7f0d7aa4bdb9">&#9670;&nbsp;</a></span>Transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Transform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a block of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called before this method can be used. Input and Output array lengths must be at least <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes.">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform or Decrypt</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a092a1084a2e24063579a42c2f0c74b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092a1084a2e24063579a42c2f0c74b21">&#9670;&nbsp;</a></span>Transform1024()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Transform1024 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform 8 blocks of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called before this method can be used. Input and Output array lengths must be at least 8 * <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes.">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset in the Input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset in the output array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3e91c3202dbfd577a5bf92fde230525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e91c3202dbfd577a5bf92fde230525">&#9670;&nbsp;</a></span>Transform2048()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Transform2048 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform 16 blocks of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called before this method can be used. Input and Output array lengths must be at least 16 * <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes.">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset in the Input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset in the output array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2d671dde863449b25851325ba8c967a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d671dde863449b25851325ba8c967a">&#9670;&nbsp;</a></span>Transform512()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SHX::Transform512 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform 4 blocks of bytes. </p>
<p>Initialize(bool, ISymmetricKey) must be called before this method can be used. Input and Output array lengths must be at least 4 * <a class="el" href="class_s_h_x.html#a55d73865bee9745ae15d76b07aee91a3" title="Read Only: Unit block size of internal cipher in bytes.">BlockSize</a> in length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input array of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset in the Input array</td></tr>
    <tr><td class="paramname">Output</td><td>The output array of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset in the output array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/stepp/Documents/Develop/Github/CEX++/CEX/<a class="el" href="_documentation_8h_source.html">Documentation.h</a></li>
<li>C:/Users/stepp/Documents/Develop/Github/CEX++/CEX/<a class="el" href="_s_h_x_8h_source.html">SHX.h</a></li>
<li>C:/Users/stepp/Documents/Develop/Github/CEX++/CEX/SHX.cpp</li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclass_symmetric_key_html"><div class="ttname"><a href="class_symmetric_key.html">SymmetricKey</a></div><div class="ttdoc">A symmetric key container class.</div><div class="ttdef"><b>Definition:</b> Documentation.h:248</div></div>
<div class="ttc" id="agroup___enumeration_html_gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba"><div class="ttname"><a href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">SkeinUbiType::Key</a></div><div class="ttdeci">@ Key</div><div class="ttdoc">A key that turns Skein into a MAC or KDF function.</div></div>
<div class="ttc" id="aclass_c_t_r_html"><div class="ttname"><a href="class_c_t_r.html">CTR</a></div><div class="ttdoc">CTR: An implementation of a Big-Endian integer Counter Mode</div><div class="ttdef"><b>Definition:</b> CTR.h:104</div></div>
<div class="ttc" id="agroup___enumeration_html_gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956"><div class="ttname"><a href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">SkeinUbiType::Nonce</a></div><div class="ttdeci">@ Nonce</div><div class="ttdoc">Nonce value for use in stream cipher mode and randomized hashing.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
