<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CEX++: OFB Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CEX++
   &#160;<span id="projectnumber">1.0.0.7</span>
   </div>
   <div id="projectbrief">The CEX Cryptographic Library in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_o_f_b-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OFB Class Reference<div class="ingroups"><a class="el" href="group___c_e_x.html">CEX</a> &raquo; <a class="el" href="group___cipher.html">Cipher</a> &raquo; <a class="el" href="group___block.html">Block</a> &raquo; <a class="el" href="group___mode.html">Mode</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>OFB: An implementation of a Output FeedBack Mode  
 <a href="class_o_f_b.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_o_f_b_8h_source.html">OFB.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OFB:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_f_b.png" usemap="#OFB_map" alt=""/>
  <map id="OFB_map" name="OFB_map">
<area href="class_i_cipher_mode.html" title="Block-cipher standard mode virtual interface class. " alt="ICipherMode" shape="rect" coords="0,0,85,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a32e92d5f71863fc611a880535b46da17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a32e92d5f71863fc611a880535b46da17">OFB</a> (const <a class="el" href="class_o_f_b.html">OFB</a> &amp;)=delete</td></tr>
<tr class="memdesc:a32e92d5f71863fc611a880535b46da17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="#a32e92d5f71863fc611a880535b46da17">More...</a><br /></td></tr>
<tr class="separator:a32e92d5f71863fc611a880535b46da17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2857c330670f933813315a5ec5e03a01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_f_b.html">OFB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a2857c330670f933813315a5ec5e03a01">operator=</a> (const <a class="el" href="class_o_f_b.html">OFB</a> &amp;)=delete</td></tr>
<tr class="memdesc:a2857c330670f933813315a5ec5e03a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="#a2857c330670f933813315a5ec5e03a01">More...</a><br /></td></tr>
<tr class="separator:a2857c330670f933813315a5ec5e03a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8422f702d1802d55524b30b20ac4ee4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#aa8422f702d1802d55524b30b20ac4ee4">OFB</a> ()=delete</td></tr>
<tr class="memdesc:aa8422f702d1802d55524b30b20ac4ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor: default is restricted, this function has been deleted  <a href="#aa8422f702d1802d55524b30b20ac4ee4">More...</a><br /></td></tr>
<tr class="separator:aa8422f702d1802d55524b30b20ac4ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b3ad961c67431ec427dd3b65c3d94e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a47b3ad961c67431ec427dd3b65c3d94e">OFB</a> (<a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a> <a class="el" href="class_o_f_b.html#a145e723ece45fd4c753864f42a6df67a">CipherType</a>)</td></tr>
<tr class="memdesc:a47b3ad961c67431ec427dd3b65c3d94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Cipher Mode using a block-cipher enumeration name  <a href="#a47b3ad961c67431ec427dd3b65c3d94e">More...</a><br /></td></tr>
<tr class="separator:a47b3ad961c67431ec427dd3b65c3d94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7f665c1a5f73e5e6fc09178fae4b38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a9f7f665c1a5f73e5e6fc09178fae4b38">OFB</a> (<a class="el" href="class_i_block_cipher.html">IBlockCipher</a> *Cipher)</td></tr>
<tr class="memdesc:a9f7f665c1a5f73e5e6fc09178fae4b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Cipher Mode using a block-cipher instance pointer  <a href="#a9f7f665c1a5f73e5e6fc09178fae4b38">More...</a><br /></td></tr>
<tr class="separator:a9f7f665c1a5f73e5e6fc09178fae4b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf2d5f24f673ea449cc269e477998a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#aadf2d5f24f673ea449cc269e477998a8">~OFB</a> () override</td></tr>
<tr class="memdesc:aadf2d5f24f673ea449cc269e477998a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="#aadf2d5f24f673ea449cc269e477998a8">More...</a><br /></td></tr>
<tr class="separator:aadf2d5f24f673ea449cc269e477998a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ee534934e13467ccc30c3c327a4de3"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a53ee534934e13467ccc30c3c327a4de3">BlockSize</a> () override</td></tr>
<tr class="memdesc:a53ee534934e13467ccc30c3c327a4de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The ciphers internal block-size in bytes  <a href="#a53ee534934e13467ccc30c3c327a4de3">More...</a><br /></td></tr>
<tr class="separator:a53ee534934e13467ccc30c3c327a4de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145e723ece45fd4c753864f42a6df67a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a145e723ece45fd4c753864f42a6df67a">CipherType</a> () override</td></tr>
<tr class="memdesc:a145e723ece45fd4c753864f42a6df67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The block ciphers enumeration type name  <a href="#a145e723ece45fd4c753864f42a6df67a">More...</a><br /></td></tr>
<tr class="separator:a145e723ece45fd4c753864f42a6df67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b577b146e217f82998a7d2f8935665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_block_cipher.html">IBlockCipher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a47b577b146e217f82998a7d2f8935665">Engine</a> () override</td></tr>
<tr class="memdesc:a47b577b146e217f82998a7d2f8935665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: A pointer to the underlying block-cipher instance  <a href="#a47b577b146e217f82998a7d2f8935665">More...</a><br /></td></tr>
<tr class="separator:a47b577b146e217f82998a7d2f8935665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139493759d72085683e79291ffb34325"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___enumeration.html#ga1d4ccc36db403dcb914cd7c4bac557a1">CipherModes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a139493759d72085683e79291ffb34325">Enumeral</a> () override</td></tr>
<tr class="memdesc:a139493759d72085683e79291ffb34325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The cipher modes enumeration type name  <a href="#a139493759d72085683e79291ffb34325">More...</a><br /></td></tr>
<tr class="separator:a139493759d72085683e79291ffb34325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5ed25ccbe10b7dde0e61a305b4369a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a6e5ed25ccbe10b7dde0e61a305b4369a">IsEncryption</a> () override</td></tr>
<tr class="memdesc:a6e5ed25ccbe10b7dde0e61a305b4369a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The operation mode, returns true if initialized for encryption, false for decryption  <a href="#a6e5ed25ccbe10b7dde0e61a305b4369a">More...</a><br /></td></tr>
<tr class="separator:a6e5ed25ccbe10b7dde0e61a305b4369a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a251feb550c172aa058250169ab922c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a5a251feb550c172aa058250169ab922c">IsInitialized</a> () override</td></tr>
<tr class="memdesc:a5a251feb550c172aa058250169ab922c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The block-cipher mode has been keyed and is ready to transform data  <a href="#a5a251feb550c172aa058250169ab922c">More...</a><br /></td></tr>
<tr class="separator:a5a251feb550c172aa058250169ab922c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b26c86db2fb020a2dc4b29f203e327"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a49b26c86db2fb020a2dc4b29f203e327">IsParallel</a> () override</td></tr>
<tr class="memdesc:a49b26c86db2fb020a2dc4b29f203e327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Processor parallelization availability.  <a href="#a49b26c86db2fb020a2dc4b29f203e327">More...</a><br /></td></tr>
<tr class="separator:a49b26c86db2fb020a2dc4b29f203e327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eac533e077a6a0d149d85dd333115d4"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a0eac533e077a6a0d149d85dd333115d4">LegalKeySizes</a> () override</td></tr>
<tr class="memdesc:a0eac533e077a6a0d149d85dd333115d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: A vector of allowed cipher-mode input key byte-sizes  <a href="#a0eac533e077a6a0d149d85dd333115d4">More...</a><br /></td></tr>
<tr class="separator:a0eac533e077a6a0d149d85dd333115d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5a2a2b15fdc046c30ae85e86440e3c"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#aea5a2a2b15fdc046c30ae85e86440e3c">Name</a> () override</td></tr>
<tr class="memdesc:aea5a2a2b15fdc046c30ae85e86440e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The cipher-modes formal class name  <a href="#aea5a2a2b15fdc046c30ae85e86440e3c">More...</a><br /></td></tr>
<tr class="separator:aea5a2a2b15fdc046c30ae85e86440e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6577d17bdd088be81aae58a118e649"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a1e6577d17bdd088be81aae58a118e649">ParallelBlockSize</a> () override</td></tr>
<tr class="memdesc:a1e6577d17bdd088be81aae58a118e649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Parallel block size; the byte-size of the input/output data arrays passed to a transform that trigger parallel processing.  <a href="#a1e6577d17bdd088be81aae58a118e649">More...</a><br /></td></tr>
<tr class="separator:a1e6577d17bdd088be81aae58a118e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832ff7e24daf8b96f3d90fe0cdda00f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parallel_options.html">ParallelOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a832ff7e24daf8b96f3d90fe0cdda00f3">ParallelProfile</a> () override</td></tr>
<tr class="memdesc:a832ff7e24daf8b96f3d90fe0cdda00f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/Write: Parallel and SIMD capability flags and sizes (Not supported in this mode)  <a href="#a832ff7e24daf8b96f3d90fe0cdda00f3">More...</a><br /></td></tr>
<tr class="separator:a832ff7e24daf8b96f3d90fe0cdda00f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5d041b81de570ef13c578730106bbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a0a5d041b81de570ef13c578730106bbd">DecryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:a0a5d041b81de570ef13c578730106bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a single block of bytes.  <a href="#a0a5d041b81de570ef13c578730106bbd">More...</a><br /></td></tr>
<tr class="separator:a0a5d041b81de570ef13c578730106bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2a47b085c6deb7e7b7d09a33878235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a0a2a47b085c6deb7e7b7d09a33878235">DecryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:a0a2a47b085c6deb7e7b7d09a33878235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a block of bytes with offset parameters.  <a href="#a0a2a47b085c6deb7e7b7d09a33878235">More...</a><br /></td></tr>
<tr class="separator:a0a2a47b085c6deb7e7b7d09a33878235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5cbc9012605df7df293d573eb9f339"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a2e5cbc9012605df7df293d573eb9f339">EncryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:a2e5cbc9012605df7df293d573eb9f339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a single block of bytes.  <a href="#a2e5cbc9012605df7df293d573eb9f339">More...</a><br /></td></tr>
<tr class="separator:a2e5cbc9012605df7df293d573eb9f339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930e86d1af91462f30fbe3e2f711ed18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a930e86d1af91462f30fbe3e2f711ed18">EncryptBlock</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:a930e86d1af91462f30fbe3e2f711ed18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a block of bytes using offset parameters.  <a href="#a930e86d1af91462f30fbe3e2f711ed18">More...</a><br /></td></tr>
<tr class="separator:a930e86d1af91462f30fbe3e2f711ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f8ee44cbef0f7d41f0a02be6641989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a82f8ee44cbef0f7d41f0a02be6641989">Initialize</a> (bool Encryption, <a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;Parameters) override</td></tr>
<tr class="memdesc:a82f8ee44cbef0f7d41f0a02be6641989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the cipher-mode instance  <a href="#a82f8ee44cbef0f7d41f0a02be6641989">More...</a><br /></td></tr>
<tr class="separator:a82f8ee44cbef0f7d41f0a02be6641989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fac679458833beeb1b3da67f5a63d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a37fac679458833beeb1b3da67f5a63d4">ParallelMaxDegree</a> (size_t Degree) override</td></tr>
<tr class="memdesc:a37fac679458833beeb1b3da67f5a63d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of threads allocated when using multi-threaded processing.  <a href="#a37fac679458833beeb1b3da67f5a63d4">More...</a><br /></td></tr>
<tr class="separator:a37fac679458833beeb1b3da67f5a63d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c56128649a805a148e8b99b3f03de97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_f_b.html#a9c56128649a805a148e8b99b3f03de97">Transform</a> (const std::vector&lt; byte &gt; &amp;Input, const size_t InOffset, std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset, const size_t Length) override</td></tr>
<tr class="memdesc:a9c56128649a805a148e8b99b3f03de97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a length of bytes with offset parameters.  <a href="#a9c56128649a805a148e8b99b3f03de97">More...</a><br /></td></tr>
<tr class="separator:a9c56128649a805a148e8b99b3f03de97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_cipher_mode"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_cipher_mode')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_cipher_mode.html">ICipherMode</a></td></tr>
<tr class="memitem:a947413f3a4cdd09c69c72bdd75c91c06 inherit pub_methods_class_i_cipher_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cipher_mode.html#a947413f3a4cdd09c69c72bdd75c91c06">ICipherMode</a> (const <a class="el" href="class_i_cipher_mode.html">ICipherMode</a> &amp;)=delete</td></tr>
<tr class="memdesc:a947413f3a4cdd09c69c72bdd75c91c06 inherit pub_methods_class_i_cipher_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="class_i_cipher_mode.html#a947413f3a4cdd09c69c72bdd75c91c06">More...</a><br /></td></tr>
<tr class="separator:a947413f3a4cdd09c69c72bdd75c91c06 inherit pub_methods_class_i_cipher_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6860aaea83eaa2fa194247d03971ba73 inherit pub_methods_class_i_cipher_mode"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_cipher_mode.html">ICipherMode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cipher_mode.html#a6860aaea83eaa2fa194247d03971ba73">operator=</a> (const <a class="el" href="class_i_cipher_mode.html">ICipherMode</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6860aaea83eaa2fa194247d03971ba73 inherit pub_methods_class_i_cipher_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="class_i_cipher_mode.html#a6860aaea83eaa2fa194247d03971ba73">More...</a><br /></td></tr>
<tr class="separator:a6860aaea83eaa2fa194247d03971ba73 inherit pub_methods_class_i_cipher_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283a39fde808aedfd73820c6ae0feda inherit pub_methods_class_i_cipher_mode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cipher_mode.html#aa283a39fde808aedfd73820c6ae0feda">ICipherMode</a> ()</td></tr>
<tr class="memdesc:aa283a39fde808aedfd73820c6ae0feda inherit pub_methods_class_i_cipher_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the ICipherMode virtual interface class  <a href="class_i_cipher_mode.html#aa283a39fde808aedfd73820c6ae0feda">More...</a><br /></td></tr>
<tr class="separator:aa283a39fde808aedfd73820c6ae0feda inherit pub_methods_class_i_cipher_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3ec68d89511d48a38aff60937f9e67 inherit pub_methods_class_i_cipher_mode"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cipher_mode.html#a3a3ec68d89511d48a38aff60937f9e67">~ICipherMode</a> () noexcept</td></tr>
<tr class="memdesc:a3a3ec68d89511d48a38aff60937f9e67 inherit pub_methods_class_i_cipher_mode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="class_i_cipher_mode.html#a3a3ec68d89511d48a38aff60937f9e67">More...</a><br /></td></tr>
<tr class="separator:a3a3ec68d89511d48a38aff60937f9e67 inherit pub_methods_class_i_cipher_mode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>OFB: An implementation of a Output FeedBack Mode </p>
<p>Encrypting a single block of bytes: </p><div class="fragment"><div class="line"><a class="code" href="class_o_f_b.html">OFB</a> cipher(BlockCiphers::AES);</div><div class="line"><span class="comment">// initialize for encryption</span></div><div class="line">cipher.Initialize(<span class="keyword">true</span>, <a class="code" href="class_symmetric_key.html">SymmetricKey</a>(<a class="code" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea897356954c2cd3d41b221e3f24f99bba">Key</a>, <a class="code" href="group___enumeration.html#gga0275357fcdd6da6fb73a7cb04b0d8f8ea3a90ac83535fb1f3d071e8beb25aa956">Nonce</a>));</div><div class="line"><span class="comment">// encrypt one block</span></div><div class="line">cipher.Transform(Input, 0, Output, 0);</div></div><!-- fragment --> <p><b>Overview:</b> </p>
<p>Output Feedback Mode (OFB) is a similar construction to the CFB mode, and allows encryption of various block sizes. <br />
It differs in that the output of the encryption block function, (rather than the ciphertext), serves as the feedback register. <br />
The cipher is initialized by copying the initialization vector to an internal register, prepended by zeroes. <br />
During a transformation, this register is encrypted by the underlying cipher into a buffer, the buffer is then XOR'd with the input message block to produce the ciphertext. <br />
The vector block is then rotated so that the latter half of the vector is shifted to the start of the array, and the buffer is moved to the end of the array.</p>
<p><b>Description:</b> </p>
<p><em>Legend:</em> <br />
 C=ciphertext, P=plaintext, K=key, E=encrypt, ^=XOR <br />
<em>Encryption</em> <br />
I1 ← IV. For 1 ≤ j ≤ u, given plaintext block Pj: <br />
(a) Oj ← EK(Ij). -Compute the block-cipher output. <br />
(b) Tj ← the r leftmost bits of Oj. -Assume the leftmost is identified as bit 1. <br />
(c) Cj ← Pj ^ Tj. -Transmit the r-bit ciphertext block Cj. <br />
(d) Ij+1 ← 2r · Ij + Tj mod 2n. -Update the block-cipher input for the next block. <br />
<em>Decryption</em> <br />
I1 ← IV . For 1 ≤ j ≤ u, upon receiving Cj: <br />
Pj ← Cj ^ Tj, where Tj, Oj, and Ij are computed as an encryption cycle; K(C).</p>
<p><b>Implementation Notes:</b> </p><ul>
<li>
</li>
<li>
A cipher mode constructor can either be initialized with a block-cipher instance, or using the block-ciphers enumeration name. </li>
<li>
A block-cipher instance created using the enumeration constructor, is automatically deleted when the class is destroyed. </li>
<li>
The class public functions are virtual, and can be accessed from an ICipherMode instance. </li>
<li>
The transformation methods can not be called until the Initialize(bool, ISymmetricKey) function has been called. </li>
<li>
Due to block chain depenencies in OFB mode, neither the encryption or decryption functions can be processed in parallel. </li>
</ul>
<p>Guiding Publications: </p><ol>
<li>
NIST <a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</a>. </li>
<li>
FIPS <a href="http://csrc.nist.gov/publications/fips/fips81/fips81.htm">PUB81</a>. </li>
<li>
Handbook of Applied Cryptography <a href="http://cacr.uwaterloo.ca/hac/about/chap7.pdf">Chapter 7: Block Ciphers</a>. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a32e92d5f71863fc611a880535b46da17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e92d5f71863fc611a880535b46da17">&#9670;&nbsp;</a></span>OFB() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFB::OFB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_f_b.html">OFB</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: copy is restricted, this function has been deleted </p>

</div>
</div>
<a id="aa8422f702d1802d55524b30b20ac4ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8422f702d1802d55524b30b20ac4ee4">&#9670;&nbsp;</a></span>OFB() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFB::OFB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor: default is restricted, this function has been deleted </p>

</div>
</div>
<a id="a47b3ad961c67431ec427dd3b65c3d94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b3ad961c67431ec427dd3b65c3d94e">&#9670;&nbsp;</a></span>OFB() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFB::OFB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a>&#160;</td>
          <td class="paramname"><em>CipherType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the Cipher Mode using a block-cipher enumeration name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CipherType</td><td>The enumeration type name of a block-cipher</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if an undefined block-cipher type name is used, or the specified register size is invalid</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f7f665c1a5f73e5e6fc09178fae4b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7f665c1a5f73e5e6fc09178fae4b38">&#9670;&nbsp;</a></span>OFB() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFB::OFB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_block_cipher.html">IBlockCipher</a> *&#160;</td>
          <td class="paramname"><em>Cipher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the Cipher Mode using a block-cipher instance pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cipher</td><td>The uninitialized block-cipher instance; can not be null</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if a null block-cipher is used, or the specified register size is invalid</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadf2d5f24f673ea449cc269e477998a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf2d5f24f673ea449cc269e477998a8">&#9670;&nbsp;</a></span>~OFB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OFB::~OFB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor: finalize this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a53ee534934e13467ccc30c3c327a4de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ee534934e13467ccc30c3c327a4de3">&#9670;&nbsp;</a></span>BlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t OFB::BlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The ciphers internal block-size in bytes </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a84a1320fbd9b6a9b077072acf66715ae">ICipherMode</a>.</p>

</div>
</div>
<a id="a145e723ece45fd4c753864f42a6df67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145e723ece45fd4c753864f42a6df67a">&#9670;&nbsp;</a></span>CipherType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___enumeration.html#gaa7f8226ec43fe26b57b18e6821c90ffd">BlockCiphers</a> OFB::CipherType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The block ciphers enumeration type name </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#af20a1f1a85bcc13ca03670b3cf94491a">ICipherMode</a>.</p>

</div>
</div>
<a id="a0a5d041b81de570ef13c578730106bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5d041b81de570ef13c578730106bbd">&#9670;&nbsp;</a></span>DecryptBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFB::DecryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt a single block of bytes. </p>
<p>Decrypts one block of bytes beginning at a zero index. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input vector of cipher-text bytes</td></tr>
    <tr><td class="paramname">Output</td><td>The output vector of plain-text bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a3f0210d1097cf69bce107824d4dfa6da">ICipherMode</a>.</p>

</div>
</div>
<a id="a0a2a47b085c6deb7e7b7d09a33878235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2a47b085c6deb7e7b7d09a33878235">&#9670;&nbsp;</a></span>DecryptBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFB::DecryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypt a block of bytes with offset parameters. </p>
<p>Decrypts one block of bytes at the designated offsets. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input vector of cipher-text bytes</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset within the input vector</td></tr>
    <tr><td class="paramname">Output</td><td>The output vector of plain-text bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset within the output vector</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a567520f345d7cbc99f356d357ac8086c">ICipherMode</a>.</p>

</div>
</div>
<a id="a2e5cbc9012605df7df293d573eb9f339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5cbc9012605df7df293d573eb9f339">&#9670;&nbsp;</a></span>EncryptBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFB::EncryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt a single block of bytes. </p>
<p>Encrypts one block of bytes beginning at a zero index. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input vector of plain-text bytes</td></tr>
    <tr><td class="paramname">Output</td><td>The output vector of cipher-text bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a2662c08e4ca778ca45496506e954af4a">ICipherMode</a>.</p>

</div>
</div>
<a id="a930e86d1af91462f30fbe3e2f711ed18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930e86d1af91462f30fbe3e2f711ed18">&#9670;&nbsp;</a></span>EncryptBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFB::EncryptBlock </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypt a block of bytes using offset parameters. </p>
<p>Encrypts one block of bytes at the designated offsets. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input vector of plain-text bytes</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset within the input vector</td></tr>
    <tr><td class="paramname">Output</td><td>The output vector of cipher-text bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset within the output vector</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a94d24281759928169f725b4943c02527">ICipherMode</a>.</p>

</div>
</div>
<a id="a47b577b146e217f82998a7d2f8935665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b577b146e217f82998a7d2f8935665">&#9670;&nbsp;</a></span>Engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_block_cipher.html">IBlockCipher</a> * OFB::Engine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: A pointer to the underlying block-cipher instance </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a11c630e63903b83044397876f6276ce9">ICipherMode</a>.</p>

</div>
</div>
<a id="a139493759d72085683e79291ffb34325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139493759d72085683e79291ffb34325">&#9670;&nbsp;</a></span>Enumeral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___enumeration.html#ga1d4ccc36db403dcb914cd7c4bac557a1">CipherModes</a> OFB::Enumeral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The cipher modes enumeration type name </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a94f085c15d16a8f37192f302773e5bb2">ICipherMode</a>.</p>

</div>
</div>
<a id="a82f8ee44cbef0f7d41f0a02be6641989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f8ee44cbef0f7d41f0a02be6641989">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFB::Initialize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Encryption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;&#160;</td>
          <td class="paramname"><em>Parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the cipher-mode instance </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Encryption</td><td>Operation mode, true if cipher is used for encryption, false to decrypt</td></tr>
    <tr><td class="paramname">Parameters</td><td>SymmetricKey containing the encryption Key and Initialization Vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if an invalid key or nonce is used</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a805bbcccd6f31a8a5250ca7766518a4a">ICipherMode</a>.</p>

</div>
</div>
<a id="a6e5ed25ccbe10b7dde0e61a305b4369a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5ed25ccbe10b7dde0e61a305b4369a">&#9670;&nbsp;</a></span>IsEncryption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool OFB::IsEncryption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The operation mode, returns true if initialized for encryption, false for decryption </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a6b9e5e05b83c6e84e6082d0b6334d470">ICipherMode</a>.</p>

</div>
</div>
<a id="a5a251feb550c172aa058250169ab922c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a251feb550c172aa058250169ab922c">&#9670;&nbsp;</a></span>IsInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool OFB::IsInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The block-cipher mode has been keyed and is ready to transform data </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a1b57c47c070538abb55e96e09e7ce5a2">ICipherMode</a>.</p>

</div>
</div>
<a id="a49b26c86db2fb020a2dc4b29f203e327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b26c86db2fb020a2dc4b29f203e327">&#9670;&nbsp;</a></span>IsParallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool OFB::IsParallel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Processor parallelization availability. </p>
<p>Parallel processing is not supported with OFB mode</p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a7851dee20f03d50db63ea951c0ad697d">ICipherMode</a>.</p>

</div>
</div>
<a id="a0eac533e077a6a0d149d85dd333115d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eac533e077a6a0d149d85dd333115d4">&#9670;&nbsp;</a></span>LegalKeySizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_symmetric_key_size.html">SymmetricKeySize</a> &gt; &amp; OFB::LegalKeySizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: A vector of allowed cipher-mode input key byte-sizes </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a530595c8040b12a19a21d14f840547ab">ICipherMode</a>.</p>

</div>
</div>
<a id="aea5a2a2b15fdc046c30ae85e86440e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5a2a2b15fdc046c30ae85e86440e3c">&#9670;&nbsp;</a></span>Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string OFB::Name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The cipher-modes formal class name </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#af060eb48e27685b266b7526be3e5db9e">ICipherMode</a>.</p>

</div>
</div>
<a id="a2857c330670f933813315a5ec5e03a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2857c330670f933813315a5ec5e03a01">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_f_b.html">OFB</a>&amp; OFB::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_f_b.html">OFB</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator: copy is restricted, this function has been deleted </p>

</div>
</div>
<a id="a1e6577d17bdd088be81aae58a118e649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6577d17bdd088be81aae58a118e649">&#9670;&nbsp;</a></span>ParallelBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t OFB::ParallelBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Parallel block size; the byte-size of the input/output data arrays passed to a transform that trigger parallel processing. </p>
<p>This value can be changed through the ParallelProfile class.</p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#ae39d8aaa19ad006669bfbc593b904c15">ICipherMode</a>.</p>

</div>
</div>
<a id="a37fac679458833beeb1b3da67f5a63d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fac679458833beeb1b3da67f5a63d4">&#9670;&nbsp;</a></span>ParallelMaxDegree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFB::ParallelMaxDegree </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of threads allocated when using multi-threaded processing. </p>
<p>OFB does not support multi-threaded operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Degree</td><td>The desired number of threads</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a9985b6851274ada2137ea7496a91671d">ICipherMode</a>.</p>

</div>
</div>
<a id="a832ff7e24daf8b96f3d90fe0cdda00f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832ff7e24daf8b96f3d90fe0cdda00f3">&#9670;&nbsp;</a></span>ParallelProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parallel_options.html">ParallelOptions</a> &amp; OFB::ParallelProfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read/Write: Parallel and SIMD capability flags and sizes (Not supported in this mode) </p>

<p>Implements <a class="el" href="class_i_cipher_mode.html#ae0c45109dd147c8d8db02fb02561379f">ICipherMode</a>.</p>

</div>
</div>
<a id="a9c56128649a805a148e8b99b3f03de97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c56128649a805a148e8b99b3f03de97">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OFB::Transform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a length of bytes with offset parameters. </p>
<p>This method processes a specified length of bytes, utilizing offsets incremented by the caller. Initialize(bool, ISymmetricKey) must be called before this method can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input vector of bytes to transform</td></tr>
    <tr><td class="paramname">InOffset</td><td>Starting offset within the input vector</td></tr>
    <tr><td class="paramname">Output</td><td>The output vector of transformed bytes</td></tr>
    <tr><td class="paramname">OutOffset</td><td>Starting offset within the output vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to transform</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_cipher_mode.html#a26e54aafa8eb9259ed291eb22009874d">ICipherMode</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/<a class="el" href="_documentation_8h_source.html">Documentation.h</a></li>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/<a class="el" href="_o_f_b_8h_source.html">OFB.h</a></li>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/OFB.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
