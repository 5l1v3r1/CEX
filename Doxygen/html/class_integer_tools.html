<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CEX++: IntegerTools Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CEX++
   &#160;<span id="projectnumber">1.0.0.7</span>
   </div>
   <div id="projectbrief">The CEX Cryptographic Library in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_integer_tools-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IntegerTools Class Reference<div class="ingroups"><a class="el" href="group___c_e_x.html">CEX</a> &raquo; <a class="el" href="group___utility.html">Utility</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An integer utility functions class  
 <a href="class_integer_tools.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_integer_tools_8h_source.html">IntegerTools.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aca4bba2097eb4cd9fe7511b274283d51"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:aca4bba2097eb4cd9fe7511b274283d51"><td class="memTemplItemLeft" align="right" valign="top">static CEX_OPTIMIZE_IGNORE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aca4bba2097eb4cd9fe7511b274283d51">Clear</a> (Array &amp;Input)</td></tr>
<tr class="memdesc:aca4bba2097eb4cd9fe7511b274283d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">cond PRIVATE  <a href="#aca4bba2097eb4cd9fe7511b274283d51">More...</a><br /></td></tr>
<tr class="separator:aca4bba2097eb4cd9fe7511b274283d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530bf3deb1dd650123e24027de07b9c5"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Dimensions, size_t Length&gt; </td></tr>
<tr class="memitem:a530bf3deb1dd650123e24027de07b9c5"><td class="memTemplItemLeft" align="right" valign="top">CEX_OPTIMIZE_RESUME static CEX_OPTIMIZE_IGNORE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a530bf3deb1dd650123e24027de07b9c5">ClearArray</a> (std::array&lt; std::array&lt; T, Length &gt;, Dimensions &gt; &amp;Input)</td></tr>
<tr class="memdesc:a530bf3deb1dd650123e24027de07b9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">cond PRIVATE  <a href="#a530bf3deb1dd650123e24027de07b9c5">More...</a><br /></td></tr>
<tr class="separator:a530bf3deb1dd650123e24027de07b9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd27c5be4f958f210898c4a9ca1bc55"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename Random &gt; </td></tr>
<tr class="memitem:adfd27c5be4f958f210898c4a9ca1bc55"><td class="memTemplItemLeft" align="right" valign="top">static CEX_OPTIMIZE_RESUME void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#adfd27c5be4f958f210898c4a9ca1bc55">Fill</a> (Array &amp;Output, size_t Offset, size_t Elements, Random &amp;Rng)</td></tr>
<tr class="memdesc:adfd27c5be4f958f210898c4a9ca1bc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">cond PRIVATE  <a href="#adfd27c5be4f958f210898c4a9ca1bc55">More...</a><br /></td></tr>
<tr class="separator:adfd27c5be4f958f210898c4a9ca1bc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b93198cf823c1919aa0a12bf8667f9"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename Random &gt; </td></tr>
<tr class="memitem:a70b93198cf823c1919aa0a12bf8667f9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a70b93198cf823c1919aa0a12bf8667f9">Fill</a> (Array &amp;Output, size_t Offset, size_t Elements, Random *Rng)</td></tr>
<tr class="memdesc:a70b93198cf823c1919aa0a12bf8667f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a vector of any type with random elements.  <a href="#a70b93198cf823c1919aa0a12bf8667f9">More...</a><br /></td></tr>
<tr class="separator:a70b93198cf823c1919aa0a12bf8667f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab7a2f2a9e663113ab65a50b14771e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ab7a2f2a9e663113ab65a50b14771e3"><td class="memTemplItemLeft" align="right" valign="top">static byte&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a6ab7a2f2a9e663113ab65a50b14771e3">GetByte</a> (T Value, size_t Index)</td></tr>
<tr class="memdesc:a6ab7a2f2a9e663113ab65a50b14771e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an 8-bit integer from a larger integer  <a href="#a6ab7a2f2a9e663113ab65a50b14771e3">More...</a><br /></td></tr>
<tr class="separator:a6ab7a2f2a9e663113ab65a50b14771e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0c5ada557282025b041b43eef809da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e0c5ada557282025b041b43eef809da"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a7e0c5ada557282025b041b43eef809da">Abs</a> (T A, T B)</td></tr>
<tr class="memdesc:a7e0c5ada557282025b041b43eef809da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value difference between two integers  <a href="#a7e0c5ada557282025b041b43eef809da">More...</a><br /></td></tr>
<tr class="separator:a7e0c5ada557282025b041b43eef809da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07ccc2161dc68fda786aede2d5a1b8b"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ae07ccc2161dc68fda786aede2d5a1b8b">Crop</a> (ulong Value, size_t Length)</td></tr>
<tr class="memdesc:ae07ccc2161dc68fda786aede2d5a1b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop a 64-bit integer value  <a href="#ae07ccc2161dc68fda786aede2d5a1b8b">More...</a><br /></td></tr>
<tr class="separator:ae07ccc2161dc68fda786aede2d5a1b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f49d61b5437bf6da96706c972032a7e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a6f49d61b5437bf6da96706c972032a7e">FromString</a> (std::string &amp;Input)</td></tr>
<tr class="memdesc:a6f49d61b5437bf6da96706c972032a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a string to a byte vector.  <a href="#a6f49d61b5437bf6da96706c972032a7e">More...</a><br /></td></tr>
<tr class="separator:a6f49d61b5437bf6da96706c972032a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd695fd29b3178aad288fc5b868f28e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a9cd695fd29b3178aad288fc5b868f28e">FromHex</a> (std::string &amp;Input, size_t Length)</td></tr>
<tr class="memdesc:a9cd695fd29b3178aad288fc5b868f28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a hex formatted string to a vector of bytes  <a href="#a9cd695fd29b3178aad288fc5b868f28e">More...</a><br /></td></tr>
<tr class="separator:a9cd695fd29b3178aad288fc5b868f28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6e4b99d9e1a3859d05892e213d16f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb6e4b99d9e1a3859d05892e213d16f3"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#adb6e4b99d9e1a3859d05892e213d16f3">IsPowerOf2</a> (T Value)</td></tr>
<tr class="memdesc:adb6e4b99d9e1a3859d05892e213d16f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for power of 2  <a href="#adb6e4b99d9e1a3859d05892e213d16f3">More...</a><br /></td></tr>
<tr class="separator:adb6e4b99d9e1a3859d05892e213d16f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad85dc811b47fefd717a5ac114cbeb1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7ad85dc811b47fefd717a5ac114cbeb1"><td class="memTemplItemLeft" align="right" valign="top">static T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a7ad85dc811b47fefd717a5ac114cbeb1">ModPowerOf2</a> (T1 A, T2 B)</td></tr>
<tr class="memdesc:a7ad85dc811b47fefd717a5ac114cbeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mod a power of two integer  <a href="#a7ad85dc811b47fefd717a5ac114cbeb1">More...</a><br /></td></tr>
<tr class="separator:a7ad85dc811b47fefd717a5ac114cbeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013fe0c0864812529ffc86bdff3dc783"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a013fe0c0864812529ffc86bdff3dc783"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a013fe0c0864812529ffc86bdff3dc783">Max</a> (T A, T B)</td></tr>
<tr class="memdesc:a013fe0c0864812529ffc86bdff3dc783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the larger of two integer values  <a href="#a013fe0c0864812529ffc86bdff3dc783">More...</a><br /></td></tr>
<tr class="separator:a013fe0c0864812529ffc86bdff3dc783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a79e766e59a1e700534afa3939648a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8a79e766e59a1e700534afa3939648a"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aa8a79e766e59a1e700534afa3939648a">Min</a> (T A, T B)</td></tr>
<tr class="memdesc:aa8a79e766e59a1e700534afa3939648a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smaller of two integer values  <a href="#aa8a79e766e59a1e700534afa3939648a">More...</a><br /></td></tr>
<tr class="separator:aa8a79e766e59a1e700534afa3939648a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e530bddce7cc292fc6d76c1c67b4c9b"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a0e530bddce7cc292fc6d76c1c67b4c9b">Parity</a> (ulong Value)</td></tr>
<tr class="memdesc:a0e530bddce7cc292fc6d76c1c67b4c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parity bit from a 64-bit integer  <a href="#a0e530bddce7cc292fc6d76c1c67b4c9b">More...</a><br /></td></tr>
<tr class="separator:a0e530bddce7cc292fc6d76c1c67b4c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92878912738bf8f0594f18015bd7ebc1"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a92878912738bf8f0594f18015bd7ebc1"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a92878912738bf8f0594f18015bd7ebc1">ToHex</a> (Array &amp;Input, size_t Offset, size_t Length)</td></tr>
<tr class="memdesc:a92878912738bf8f0594f18015bd7ebc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an array or vector of T to a hexadecimal string  <a href="#a92878912738bf8f0594f18015bd7ebc1">More...</a><br /></td></tr>
<tr class="separator:a92878912738bf8f0594f18015bd7ebc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce1c6a0203d13eff293bbf84cb87da5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afce1c6a0203d13eff293bbf84cb87da5"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#afce1c6a0203d13eff293bbf84cb87da5">ToHex</a> (T Value)</td></tr>
<tr class="memdesc:afce1c6a0203d13eff293bbf84cb87da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a value of T to a hexadecimal string  <a href="#afce1c6a0203d13eff293bbf84cb87da5">More...</a><br /></td></tr>
<tr class="separator:afce1c6a0203d13eff293bbf84cb87da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa716fc3ff06e4ab5947d614e1a149dc8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa716fc3ff06e4ab5947d614e1a149dc8"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aa716fc3ff06e4ab5947d614e1a149dc8">ToString</a> (T Value)</td></tr>
<tr class="memdesc:aa716fc3ff06e4ab5947d614e1a149dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer to a string  <a href="#aa716fc3ff06e4ab5947d614e1a149dc8">More...</a><br /></td></tr>
<tr class="separator:aa716fc3ff06e4ab5947d614e1a149dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab89f47d97d20f2fd77a59d535bdf338"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:aab89f47d97d20f2fd77a59d535bdf338"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aab89f47d97d20f2fd77a59d535bdf338">ToString</a> (Array &amp;Input, size_t Offset, size_t Length)</td></tr>
<tr class="memdesc:aab89f47d97d20f2fd77a59d535bdf338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector or vector of T to a string  <a href="#aab89f47d97d20f2fd77a59d535bdf338">More...</a><br /></td></tr>
<tr class="separator:aab89f47d97d20f2fd77a59d535bdf338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc80f4b733d574f145ec621ff71abeb1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#acc80f4b733d574f145ec621ff71abeb1">IsBigEndian</a> ()</td></tr>
<tr class="memdesc:acc80f4b733d574f145ec621ff71abeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run time check for Little Endian byte order  <a href="#acc80f4b733d574f145ec621ff71abeb1">More...</a><br /></td></tr>
<tr class="separator:acc80f4b733d574f145ec621ff71abeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa559bfe3ea294f05ba1cac1078f0cd00"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:aa559bfe3ea294f05ba1cac1078f0cd00"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aa559bfe3ea294f05ba1cac1078f0cd00">BlockToBe</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset, size_t Length)</td></tr>
<tr class="memdesc:aa559bfe3ea294f05ba1cac1078f0cd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 8-bit byte vector to a Big Endian integer vector  <a href="#aa559bfe3ea294f05ba1cac1078f0cd00">More...</a><br /></td></tr>
<tr class="separator:aa559bfe3ea294f05ba1cac1078f0cd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00ef7dd392cc5d8a7de5309957b70e6"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:ad00ef7dd392cc5d8a7de5309957b70e6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ad00ef7dd392cc5d8a7de5309957b70e6">BeToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset, size_t Length)</td></tr>
<tr class="memdesc:ad00ef7dd392cc5d8a7de5309957b70e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian integer vector to a byte vector.  <a href="#ad00ef7dd392cc5d8a7de5309957b70e6">More...</a><br /></td></tr>
<tr class="separator:ad00ef7dd392cc5d8a7de5309957b70e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65706b6faf98a3a5489293ae1be6801a"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a65706b6faf98a3a5489293ae1be6801a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a65706b6faf98a3a5489293ae1be6801a">Be16ToBytes</a> (ushort Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a65706b6faf98a3a5489293ae1be6801a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 16-bit word to bytes  <a href="#a65706b6faf98a3a5489293ae1be6801a">More...</a><br /></td></tr>
<tr class="separator:a65706b6faf98a3a5489293ae1be6801a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb08055b27fa8d5a7dfd054be16f6fb"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a1fb08055b27fa8d5a7dfd054be16f6fb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a1fb08055b27fa8d5a7dfd054be16f6fb">Be32ToBytes</a> (uint Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a1fb08055b27fa8d5a7dfd054be16f6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 32-bit word to bytes  <a href="#a1fb08055b27fa8d5a7dfd054be16f6fb">More...</a><br /></td></tr>
<tr class="separator:a1fb08055b27fa8d5a7dfd054be16f6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d57c369d19689c197672547167507e2"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a4d57c369d19689c197672547167507e2"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a4d57c369d19689c197672547167507e2">Be64ToBytes</a> (ulong Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a4d57c369d19689c197672547167507e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 64-bit dword to bytes  <a href="#a4d57c369d19689c197672547167507e2">More...</a><br /></td></tr>
<tr class="separator:a4d57c369d19689c197672547167507e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4629f1b7d1b6669b3534cd8276b31e8"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:ac4629f1b7d1b6669b3534cd8276b31e8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ac4629f1b7d1b6669b3534cd8276b31e8">BeUL256ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:ac4629f1b7d1b6669b3534cd8276b31e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 8 * 32bit word vector to a byte vector  <a href="#ac4629f1b7d1b6669b3534cd8276b31e8">More...</a><br /></td></tr>
<tr class="separator:ac4629f1b7d1b6669b3534cd8276b31e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b9de1fc0e5b757c6cfdcbd614c08c3"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a62b9de1fc0e5b757c6cfdcbd614c08c3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a62b9de1fc0e5b757c6cfdcbd614c08c3">BeULL512ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a62b9de1fc0e5b757c6cfdcbd614c08c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 8 * 64bit word vector to a byte vector  <a href="#a62b9de1fc0e5b757c6cfdcbd614c08c3">More...</a><br /></td></tr>
<tr class="separator:a62b9de1fc0e5b757c6cfdcbd614c08c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613da552be2bd9b17c13487c5616d791"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a613da552be2bd9b17c13487c5616d791"><td class="memTemplItemLeft" align="right" valign="top">static ushort&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a613da552be2bd9b17c13487c5616d791">BeBytesTo16</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:a613da552be2bd9b17c13487c5616d791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Big Endian 16-bit word  <a href="#a613da552be2bd9b17c13487c5616d791">More...</a><br /></td></tr>
<tr class="separator:a613da552be2bd9b17c13487c5616d791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c7afed2650b21f6fae6b2345242430"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a40c7afed2650b21f6fae6b2345242430"><td class="memTemplItemLeft" align="right" valign="top">static Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a40c7afed2650b21f6fae6b2345242430">Be16ToBytes</a> (ushort Value)</td></tr>
<tr class="memdesc:a40c7afed2650b21f6fae6b2345242430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 16-bit word to byte vector  <a href="#a40c7afed2650b21f6fae6b2345242430">More...</a><br /></td></tr>
<tr class="separator:a40c7afed2650b21f6fae6b2345242430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda1bed4737c5faab3d9c94a817a4286"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:acda1bed4737c5faab3d9c94a817a4286"><td class="memTemplItemLeft" align="right" valign="top">static uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#acda1bed4737c5faab3d9c94a817a4286">BeBytesTo32</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:acda1bed4737c5faab3d9c94a817a4286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Big Endian 32-bit word  <a href="#acda1bed4737c5faab3d9c94a817a4286">More...</a><br /></td></tr>
<tr class="separator:acda1bed4737c5faab3d9c94a817a4286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d50672147e3bfd797df3c3219c3d00c"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a7d50672147e3bfd797df3c3219c3d00c"><td class="memTemplItemLeft" align="right" valign="top">static Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a7d50672147e3bfd797df3c3219c3d00c">Be32ToBytes</a> (uint Value)</td></tr>
<tr class="memdesc:a7d50672147e3bfd797df3c3219c3d00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 32-bit word to byte vector  <a href="#a7d50672147e3bfd797df3c3219c3d00c">More...</a><br /></td></tr>
<tr class="separator:a7d50672147e3bfd797df3c3219c3d00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6204183fb59d09a53a3cb3ad5eaf16"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:aef6204183fb59d09a53a3cb3ad5eaf16"><td class="memTemplItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aef6204183fb59d09a53a3cb3ad5eaf16">BeBytesTo64</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:aef6204183fb59d09a53a3cb3ad5eaf16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Big Endian 64-bit dword  <a href="#aef6204183fb59d09a53a3cb3ad5eaf16">More...</a><br /></td></tr>
<tr class="separator:aef6204183fb59d09a53a3cb3ad5eaf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ed69bcccafc1b52d65d8400f5bbb41"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:af3ed69bcccafc1b52d65d8400f5bbb41"><td class="memTemplItemLeft" align="right" valign="top">static Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#af3ed69bcccafc1b52d65d8400f5bbb41">Be64ToBytes</a> (ulong Value)</td></tr>
<tr class="memdesc:af3ed69bcccafc1b52d65d8400f5bbb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 64-bit dword to byte vector  <a href="#af3ed69bcccafc1b52d65d8400f5bbb41">More...</a><br /></td></tr>
<tr class="separator:af3ed69bcccafc1b52d65d8400f5bbb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7752ad9d2567ce347c079bf268d0fe"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a6d7752ad9d2567ce347c079bf268d0fe"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a6d7752ad9d2567ce347c079bf268d0fe">BeIncrement8</a> (Array &amp;Output)</td></tr>
<tr class="memdesc:a6d7752ad9d2567ce347c079bf268d0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats a byte vector as a large Big Endian integer, incrementing the total value by one  <a href="#a6d7752ad9d2567ce347c079bf268d0fe">More...</a><br /></td></tr>
<tr class="separator:a6d7752ad9d2567ce347c079bf268d0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b93ed47a8d1f3ed14bab591d78ef7a1"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a3b93ed47a8d1f3ed14bab591d78ef7a1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a3b93ed47a8d1f3ed14bab591d78ef7a1">BeIncrement8</a> (Array &amp;Output, size_t Offset, size_t Length)</td></tr>
<tr class="memdesc:a3b93ed47a8d1f3ed14bab591d78ef7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats a byte vector as a large Big Endian integer, incrementing the total value by one  <a href="#a3b93ed47a8d1f3ed14bab591d78ef7a1">More...</a><br /></td></tr>
<tr class="separator:a3b93ed47a8d1f3ed14bab591d78ef7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ff476533ce948c5dbabb932839532a"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename T &gt; </td></tr>
<tr class="memitem:aa5ff476533ce948c5dbabb932839532a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aa5ff476533ce948c5dbabb932839532a">BeIncrease8</a> (Array &amp;Output, T Value)</td></tr>
<tr class="memdesc:aa5ff476533ce948c5dbabb932839532a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment an 8-bit integer vector by the value, treating the vector as a segmented large Big Endian integer counter.  <a href="#aa5ff476533ce948c5dbabb932839532a">More...</a><br /></td></tr>
<tr class="separator:aa5ff476533ce948c5dbabb932839532a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64505ff5e56f4a0ce3c275997f32ed57"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB , typename T &gt; </td></tr>
<tr class="memitem:a64505ff5e56f4a0ce3c275997f32ed57"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a64505ff5e56f4a0ce3c275997f32ed57">BeIncrease8</a> (const ArrayA &amp;Input, ArrayB &amp;Output, T Value)</td></tr>
<tr class="memdesc:a64505ff5e56f4a0ce3c275997f32ed57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Big Endian integer counter.  <a href="#a64505ff5e56f4a0ce3c275997f32ed57">More...</a><br /></td></tr>
<tr class="separator:a64505ff5e56f4a0ce3c275997f32ed57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421ca5fc67d34ad66a2cb0c1aaabf3fd"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB , typename T &gt; </td></tr>
<tr class="memitem:a421ca5fc67d34ad66a2cb0c1aaabf3fd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a421ca5fc67d34ad66a2cb0c1aaabf3fd">BeIncrease8</a> (const ArrayA &amp;Input, ArrayB &amp;Output, size_t OutOffset, T Value)</td></tr>
<tr class="memdesc:a421ca5fc67d34ad66a2cb0c1aaabf3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Big Endian integer counter.  <a href="#a421ca5fc67d34ad66a2cb0c1aaabf3fd">More...</a><br /></td></tr>
<tr class="separator:a421ca5fc67d34ad66a2cb0c1aaabf3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5a36ec41ecc6c93cf7206883b6999e"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB , typename T &gt; </td></tr>
<tr class="memitem:a5b5a36ec41ecc6c93cf7206883b6999e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a5b5a36ec41ecc6c93cf7206883b6999e">BeIncrease8</a> (const ArrayA &amp;Input, ArrayB &amp;Output, size_t OutOffset, size_t Length, T Value)</td></tr>
<tr class="memdesc:a5b5a36ec41ecc6c93cf7206883b6999e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Big Endian integer counter.  <a href="#a5b5a36ec41ecc6c93cf7206883b6999e">More...</a><br /></td></tr>
<tr class="separator:a5b5a36ec41ecc6c93cf7206883b6999e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c7d6f9ddf7b92eee4f5490d02d14da"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ac3c7d6f9ddf7b92eee4f5490d02d14da">IsLittleEndian</a> ()</td></tr>
<tr class="memdesc:ac3c7d6f9ddf7b92eee4f5490d02d14da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run time check for Little Endian byte order  <a href="#ac3c7d6f9ddf7b92eee4f5490d02d14da">More...</a><br /></td></tr>
<tr class="separator:ac3c7d6f9ddf7b92eee4f5490d02d14da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f3d8ee47f8a8cf9ba36a5d21b566d4"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a39f3d8ee47f8a8cf9ba36a5d21b566d4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a39f3d8ee47f8a8cf9ba36a5d21b566d4">BlockToLe</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset, size_t Length)</td></tr>
<tr class="memdesc:a39f3d8ee47f8a8cf9ba36a5d21b566d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian N * 8-bit word vector to an unsigned integer vector.  <a href="#a39f3d8ee47f8a8cf9ba36a5d21b566d4">More...</a><br /></td></tr>
<tr class="separator:a39f3d8ee47f8a8cf9ba36a5d21b566d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1881baf8ff7d9c9897e5b8404928f2cd"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a1881baf8ff7d9c9897e5b8404928f2cd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a1881baf8ff7d9c9897e5b8404928f2cd">LeToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset, size_t Length)</td></tr>
<tr class="memdesc:a1881baf8ff7d9c9897e5b8404928f2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian unsigned integer vector to a byte vector.  <a href="#a1881baf8ff7d9c9897e5b8404928f2cd">More...</a><br /></td></tr>
<tr class="separator:a1881baf8ff7d9c9897e5b8404928f2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73285841973fd4bf6339f365562cf1b9"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a73285841973fd4bf6339f365562cf1b9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a73285841973fd4bf6339f365562cf1b9">Le16ToBytes</a> (ushort Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a73285841973fd4bf6339f365562cf1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 16-bit word to bytes  <a href="#a73285841973fd4bf6339f365562cf1b9">More...</a><br /></td></tr>
<tr class="separator:a73285841973fd4bf6339f365562cf1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad382a4dfa4f938f6fa4ff71269d778ab"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:ad382a4dfa4f938f6fa4ff71269d778ab"><td class="memTemplItemLeft" align="right" valign="top">static Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ad382a4dfa4f938f6fa4ff71269d778ab">Le16ToBytes</a> (ushort Value)</td></tr>
<tr class="memdesc:ad382a4dfa4f938f6fa4ff71269d778ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 16-bit word to a byte vector  <a href="#ad382a4dfa4f938f6fa4ff71269d778ab">More...</a><br /></td></tr>
<tr class="separator:ad382a4dfa4f938f6fa4ff71269d778ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b70af7dac8ee1f6016ae2c91a10878"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a63b70af7dac8ee1f6016ae2c91a10878"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a63b70af7dac8ee1f6016ae2c91a10878">Le32ToBytes</a> (uint Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a63b70af7dac8ee1f6016ae2c91a10878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 32-bit word to bytes  <a href="#a63b70af7dac8ee1f6016ae2c91a10878">More...</a><br /></td></tr>
<tr class="separator:a63b70af7dac8ee1f6016ae2c91a10878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343340b883de7897eedd67856656d8ea"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a343340b883de7897eedd67856656d8ea"><td class="memTemplItemLeft" align="right" valign="top">static Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a343340b883de7897eedd67856656d8ea">Le32ToBytes</a> (uint Value)</td></tr>
<tr class="memdesc:a343340b883de7897eedd67856656d8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 32-bit word to a byte vector  <a href="#a343340b883de7897eedd67856656d8ea">More...</a><br /></td></tr>
<tr class="separator:a343340b883de7897eedd67856656d8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbada2d937ea5b71e03e2a4f184aac9"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a8bbada2d937ea5b71e03e2a4f184aac9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a8bbada2d937ea5b71e03e2a4f184aac9">Le64ToBytes</a> (ulong Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a8bbada2d937ea5b71e03e2a4f184aac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 64-bit dword to bytes  <a href="#a8bbada2d937ea5b71e03e2a4f184aac9">More...</a><br /></td></tr>
<tr class="separator:a8bbada2d937ea5b71e03e2a4f184aac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da4d41dce0a2b466dbb8e5b7a8ac1c1"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a2da4d41dce0a2b466dbb8e5b7a8ac1c1"><td class="memTemplItemLeft" align="right" valign="top">static Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a2da4d41dce0a2b466dbb8e5b7a8ac1c1">Le64ToBytes</a> (ulong Value)</td></tr>
<tr class="memdesc:a2da4d41dce0a2b466dbb8e5b7a8ac1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 64-bit dword to byte vector  <a href="#a2da4d41dce0a2b466dbb8e5b7a8ac1c1">More...</a><br /></td></tr>
<tr class="separator:a2da4d41dce0a2b466dbb8e5b7a8ac1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221f6fc04d17f8b156c2dbe7b461d91a"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a221f6fc04d17f8b156c2dbe7b461d91a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a221f6fc04d17f8b156c2dbe7b461d91a">LeUL256ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a221f6fc04d17f8b156c2dbe7b461d91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 8 * 32bit word vector to a byte vector  <a href="#a221f6fc04d17f8b156c2dbe7b461d91a">More...</a><br /></td></tr>
<tr class="separator:a221f6fc04d17f8b156c2dbe7b461d91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861a1ecdf5fa470a124ecc8a18562559"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a861a1ecdf5fa470a124ecc8a18562559"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a861a1ecdf5fa470a124ecc8a18562559">LeULL256ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a861a1ecdf5fa470a124ecc8a18562559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 4 * 64bit word vector to a byte vector  <a href="#a861a1ecdf5fa470a124ecc8a18562559">More...</a><br /></td></tr>
<tr class="separator:a861a1ecdf5fa470a124ecc8a18562559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8fa518adca24586c6787e27bc87411"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a5d8fa518adca24586c6787e27bc87411"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a5d8fa518adca24586c6787e27bc87411">LeULL512ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a5d8fa518adca24586c6787e27bc87411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 8 * 64bit word vector to a byte vector  <a href="#a5d8fa518adca24586c6787e27bc87411">More...</a><br /></td></tr>
<tr class="separator:a5d8fa518adca24586c6787e27bc87411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f485466f17f43a0c45ff3fc4c018f4"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:aa3f485466f17f43a0c45ff3fc4c018f4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aa3f485466f17f43a0c45ff3fc4c018f4">LeULL1024ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:aa3f485466f17f43a0c45ff3fc4c018f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 16 * 64bit word vector to a byte vector  <a href="#aa3f485466f17f43a0c45ff3fc4c018f4">More...</a><br /></td></tr>
<tr class="separator:aa3f485466f17f43a0c45ff3fc4c018f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a4f5d0f0002a154992b9b2acdcf51d"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a14a4f5d0f0002a154992b9b2acdcf51d"><td class="memTemplItemLeft" align="right" valign="top">static ushort&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a14a4f5d0f0002a154992b9b2acdcf51d">LeBytesTo16</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:a14a4f5d0f0002a154992b9b2acdcf51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Little Endian 16-bit word  <a href="#a14a4f5d0f0002a154992b9b2acdcf51d">More...</a><br /></td></tr>
<tr class="separator:a14a4f5d0f0002a154992b9b2acdcf51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335a0491175bd2c51f05e404437bace0"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a335a0491175bd2c51f05e404437bace0"><td class="memTemplItemLeft" align="right" valign="top">static uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a335a0491175bd2c51f05e404437bace0">LeBytesTo32</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:a335a0491175bd2c51f05e404437bace0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Little Endian 32-bit word  <a href="#a335a0491175bd2c51f05e404437bace0">More...</a><br /></td></tr>
<tr class="separator:a335a0491175bd2c51f05e404437bace0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf8696070365eef4fe8bd9c0e509090"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:aeaf8696070365eef4fe8bd9c0e509090"><td class="memTemplItemLeft" align="right" valign="top">static uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aeaf8696070365eef4fe8bd9c0e509090">LeBytesTo32</a> (const Array &amp;Input, size_t InOffset, size_t Length)</td></tr>
<tr class="memdesc:aeaf8696070365eef4fe8bd9c0e509090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Little Endian 32-bit word  <a href="#aeaf8696070365eef4fe8bd9c0e509090">More...</a><br /></td></tr>
<tr class="separator:aeaf8696070365eef4fe8bd9c0e509090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c52f3e9ddc7d925be4d79b0f3e4288d"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a7c52f3e9ddc7d925be4d79b0f3e4288d"><td class="memTemplItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a7c52f3e9ddc7d925be4d79b0f3e4288d">LeBytesTo64</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:a7c52f3e9ddc7d925be4d79b0f3e4288d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Little Endian 64-bit dword  <a href="#a7c52f3e9ddc7d925be4d79b0f3e4288d">More...</a><br /></td></tr>
<tr class="separator:a7c52f3e9ddc7d925be4d79b0f3e4288d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e1e2a33c07ac76441000b449f930ed"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a93e1e2a33c07ac76441000b449f930ed"><td class="memTemplItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a93e1e2a33c07ac76441000b449f930ed">LeBytesTo64</a> (const Array &amp;Input, size_t InOffset, size_t Length)</td></tr>
<tr class="memdesc:a93e1e2a33c07ac76441000b449f930ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Little Endian 64-bit word  <a href="#a93e1e2a33c07ac76441000b449f930ed">More...</a><br /></td></tr>
<tr class="separator:a93e1e2a33c07ac76441000b449f930ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd5d6111fd38c44221cb22217535705"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a0cd5d6111fd38c44221cb22217535705"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a0cd5d6111fd38c44221cb22217535705">LeBytesToUL512</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a0cd5d6111fd38c44221cb22217535705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Little Endian 16 * 32bit word vector  <a href="#a0cd5d6111fd38c44221cb22217535705">More...</a><br /></td></tr>
<tr class="separator:a0cd5d6111fd38c44221cb22217535705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac84d6206a133827c3f1445b61f71028"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:aac84d6206a133827c3f1445b61f71028"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aac84d6206a133827c3f1445b61f71028">LeBytesToULL256</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:aac84d6206a133827c3f1445b61f71028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Little Endian 4 * 64bit word vector  <a href="#aac84d6206a133827c3f1445b61f71028">More...</a><br /></td></tr>
<tr class="separator:aac84d6206a133827c3f1445b61f71028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b17d366f19bfa51dceca8be7e4dc21a"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a3b17d366f19bfa51dceca8be7e4dc21a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a3b17d366f19bfa51dceca8be7e4dc21a">LeBytesToULL512</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a3b17d366f19bfa51dceca8be7e4dc21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Little Endian 8 * 64bit word vector  <a href="#a3b17d366f19bfa51dceca8be7e4dc21a">More...</a><br /></td></tr>
<tr class="separator:a3b17d366f19bfa51dceca8be7e4dc21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd4814f65e1daadae376eedb7e7b43f"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:abcd4814f65e1daadae376eedb7e7b43f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#abcd4814f65e1daadae376eedb7e7b43f">LeBytesToULL1024</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:abcd4814f65e1daadae376eedb7e7b43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte vector to a Little Endian 16 * 64bit word vector  <a href="#abcd4814f65e1daadae376eedb7e7b43f">More...</a><br /></td></tr>
<tr class="separator:abcd4814f65e1daadae376eedb7e7b43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae137281c8e572d72639af7ea252766"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a7ae137281c8e572d72639af7ea252766"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a7ae137281c8e572d72639af7ea252766">LeIncrement</a> (Array &amp;Output)</td></tr>
<tr class="memdesc:a7ae137281c8e572d72639af7ea252766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats a vector as a segmented Little Endian integer, incrementing the total value by one  <a href="#a7ae137281c8e572d72639af7ea252766">More...</a><br /></td></tr>
<tr class="separator:a7ae137281c8e572d72639af7ea252766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441b742964162bb7247c694fb0855d1f"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a441b742964162bb7247c694fb0855d1f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a441b742964162bb7247c694fb0855d1f">LeIncrement</a> (Array &amp;Output, size_t Length)</td></tr>
<tr class="memdesc:a441b742964162bb7247c694fb0855d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats a byte vector as a segmented Little Endian integer, incrementing the total value by one  <a href="#a441b742964162bb7247c694fb0855d1f">More...</a><br /></td></tr>
<tr class="separator:a441b742964162bb7247c694fb0855d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161dedb36471beb1b68bb8ac5d074800"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename T &gt; </td></tr>
<tr class="memitem:a161dedb36471beb1b68bb8ac5d074800"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a161dedb36471beb1b68bb8ac5d074800">LeIncrease8</a> (Array &amp;Output, T Value)</td></tr>
<tr class="memdesc:a161dedb36471beb1b68bb8ac5d074800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment an 8-bit integer vector by the value, treating the vector as a segmented large Little Endian integer counter.  <a href="#a161dedb36471beb1b68bb8ac5d074800">More...</a><br /></td></tr>
<tr class="separator:a161dedb36471beb1b68bb8ac5d074800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9446798853dae9373fb46ed424b7b84a"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB , typename T &gt; </td></tr>
<tr class="memitem:a9446798853dae9373fb46ed424b7b84a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a9446798853dae9373fb46ed424b7b84a">LeIncrease8</a> (const ArrayA &amp;Input, ArrayB &amp;Output, T Value)</td></tr>
<tr class="memdesc:a9446798853dae9373fb46ed424b7b84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Little Endian integer counter.  <a href="#a9446798853dae9373fb46ed424b7b84a">More...</a><br /></td></tr>
<tr class="separator:a9446798853dae9373fb46ed424b7b84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebbecac07da87caaefc45ddec4f958a"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB , typename T &gt; </td></tr>
<tr class="memitem:a8ebbecac07da87caaefc45ddec4f958a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a8ebbecac07da87caaefc45ddec4f958a">LeIncrease8</a> (const ArrayA &amp;Input, ArrayB &amp;Output, size_t OutOffset, T Value)</td></tr>
<tr class="memdesc:a8ebbecac07da87caaefc45ddec4f958a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Little Endian integer counter.  <a href="#a8ebbecac07da87caaefc45ddec4f958a">More...</a><br /></td></tr>
<tr class="separator:a8ebbecac07da87caaefc45ddec4f958a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9350ea1c8032f494e559cca8c45fdd1b"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB , typename T &gt; </td></tr>
<tr class="memitem:a9350ea1c8032f494e559cca8c45fdd1b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a9350ea1c8032f494e559cca8c45fdd1b">LeIncrease8</a> (const ArrayA &amp;Input, ArrayB &amp;Output, size_t OutOffset, size_t Length, const T Value)</td></tr>
<tr class="memdesc:a9350ea1c8032f494e559cca8c45fdd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Little Endian integer counter.  <a href="#a9350ea1c8032f494e559cca8c45fdd1b">More...</a><br /></td></tr>
<tr class="separator:a9350ea1c8032f494e559cca8c45fdd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845fc608cfdf99003cdccb56b97a5bda"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a845fc608cfdf99003cdccb56b97a5bda"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a845fc608cfdf99003cdccb56b97a5bda">LeIncrementW</a> (Array &amp;Output)</td></tr>
<tr class="memdesc:a845fc608cfdf99003cdccb56b97a5bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats an integer vector as a large Little Endian integer, incrementing the total value by one.  <a href="#a845fc608cfdf99003cdccb56b97a5bda">More...</a><br /></td></tr>
<tr class="separator:a845fc608cfdf99003cdccb56b97a5bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ed0214a2b6657fc7821cab9390e48d"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:ab8ed0214a2b6657fc7821cab9390e48d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ab8ed0214a2b6657fc7821cab9390e48d">LeIncreaseW</a> (Array &amp;Output, size_t Length)</td></tr>
<tr class="memdesc:ab8ed0214a2b6657fc7821cab9390e48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats an integer vector as a large Little Endian integer, increasing the total value by a defined length.  <a href="#ab8ed0214a2b6657fc7821cab9390e48d">More...</a><br /></td></tr>
<tr class="separator:ab8ed0214a2b6657fc7821cab9390e48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74362df7ef85e6e826699b2a16ee3a34"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a74362df7ef85e6e826699b2a16ee3a34"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a74362df7ef85e6e826699b2a16ee3a34">LeIncreaseW</a> (const Array &amp;Input, Array &amp;Output, size_t Length)</td></tr>
<tr class="memdesc:a74362df7ef85e6e826699b2a16ee3a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats an integer vector as a large Little Endian integer, increasing the total value by a defined length.  <a href="#a74362df7ef85e6e826699b2a16ee3a34">More...</a><br /></td></tr>
<tr class="separator:a74362df7ef85e6e826699b2a16ee3a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7a23490fe053fd353007ddac02f84c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab7a23490fe053fd353007ddac02f84c"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aab7a23490fe053fd353007ddac02f84c">CMax</a> (T A, T B)</td></tr>
<tr class="memdesc:aab7a23490fe053fd353007ddac02f84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: return the larger value of the two integers  <a href="#aab7a23490fe053fd353007ddac02f84c">More...</a><br /></td></tr>
<tr class="separator:aab7a23490fe053fd353007ddac02f84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e229be8ad7ab89c65daf1a847569ad8"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a1e229be8ad7ab89c65daf1a847569ad8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a1e229be8ad7ab89c65daf1a847569ad8">CMov</a> (const Array &amp;Input, size_t InOffset, Array &amp;Output, size_t OutOffset, size_t Length, byte Condition)</td></tr>
<tr class="memdesc:a1e229be8ad7ab89c65daf1a847569ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: conditional move  <a href="#a1e229be8ad7ab89c65daf1a847569ad8">More...</a><br /></td></tr>
<tr class="separator:a1e229be8ad7ab89c65daf1a847569ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405601101d450f6482ac828bcdb3cfcb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a405601101d450f6482ac828bcdb3cfcb"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a405601101d450f6482ac828bcdb3cfcb">CMin</a> (T A, T B)</td></tr>
<tr class="memdesc:a405601101d450f6482ac828bcdb3cfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: return the lesser value of the two integers  <a href="#a405601101d450f6482ac828bcdb3cfcb">More...</a><br /></td></tr>
<tr class="separator:a405601101d450f6482ac828bcdb3cfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8205d08b76335d60df3d9081ff9f00c2"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a8205d08b76335d60df3d9081ff9f00c2"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a8205d08b76335d60df3d9081ff9f00c2">Compare</a> (const ArrayA &amp;A, size_t AOffset, const ArrayB &amp;B, size_t BOffset, size_t Length)</td></tr>
<tr class="memdesc:a8205d08b76335d60df3d9081ff9f00c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: value comparison between two arrays with offset and length parameters.  <a href="#a8205d08b76335d60df3d9081ff9f00c2">More...</a><br /></td></tr>
<tr class="separator:a8205d08b76335d60df3d9081ff9f00c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfebf6e565d2c1fa4a5196e8fd930e13"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfebf6e565d2c1fa4a5196e8fd930e13"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#abfebf6e565d2c1fa4a5196e8fd930e13">ConditionalCopy</a> (T Value, T *To, const T *From0, const T *From1, size_t Length)</td></tr>
<tr class="memdesc:abfebf6e565d2c1fa4a5196e8fd930e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: conditional bit copy  <a href="#abfebf6e565d2c1fa4a5196e8fd930e13">More...</a><br /></td></tr>
<tr class="separator:abfebf6e565d2c1fa4a5196e8fd930e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3095a77895e2c5dd774295a1934b30f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3095a77895e2c5dd774295a1934b30f3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a3095a77895e2c5dd774295a1934b30f3">ConditionalZeroMem</a> (T Condition, T *Array, size_t Length)</td></tr>
<tr class="memdesc:a3095a77895e2c5dd774295a1934b30f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: conditional bit erase  <a href="#a3095a77895e2c5dd774295a1934b30f3">More...</a><br /></td></tr>
<tr class="separator:a3095a77895e2c5dd774295a1934b30f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81be3713bb02c897b6330f9d9d1ae13e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81be3713bb02c897b6330f9d9d1ae13e"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a81be3713bb02c897b6330f9d9d1ae13e">ExpandMask</a> (T X)</td></tr>
<tr class="memdesc:a81be3713bb02c897b6330f9d9d1ae13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: expand an integer mask in constant time  <a href="#a81be3713bb02c897b6330f9d9d1ae13e">More...</a><br /></td></tr>
<tr class="separator:a81be3713bb02c897b6330f9d9d1ae13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bc339bee93ad0ff59b0d8d16387d9b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6bc339bee93ad0ff59b0d8d16387d9b"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ad6bc339bee93ad0ff59b0d8d16387d9b">ExpandTopBit</a> (T A)</td></tr>
<tr class="memdesc:ad6bc339bee93ad0ff59b0d8d16387d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: last bit expansion  <a href="#ad6bc339bee93ad0ff59b0d8d16387d9b">More...</a><br /></td></tr>
<tr class="separator:ad6bc339bee93ad0ff59b0d8d16387d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd002f623f6b8c06dcf968caa9a2c95"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aacd002f623f6b8c06dcf968caa9a2c95"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#aacd002f623f6b8c06dcf968caa9a2c95">IsEqual</a> (T X, T Y)</td></tr>
<tr class="memdesc:aacd002f623f6b8c06dcf968caa9a2c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: comparison of two integers for equality  <a href="#aacd002f623f6b8c06dcf968caa9a2c95">More...</a><br /></td></tr>
<tr class="separator:aacd002f623f6b8c06dcf968caa9a2c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e0fdf6abd2ed7a0ae056071ee969a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a13e0fdf6abd2ed7a0ae056071ee969a5"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a13e0fdf6abd2ed7a0ae056071ee969a5">IsLess</a> (T X, T Y)</td></tr>
<tr class="memdesc:a13e0fdf6abd2ed7a0ae056071ee969a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: test if X is less than Y  <a href="#a13e0fdf6abd2ed7a0ae056071ee969a5">More...</a><br /></td></tr>
<tr class="separator:a13e0fdf6abd2ed7a0ae056071ee969a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57a9d1a5203bba2b39de65c36ff0f10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab57a9d1a5203bba2b39de65c36ff0f10"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ab57a9d1a5203bba2b39de65c36ff0f10">IsLte</a> (T X, T Y)</td></tr>
<tr class="memdesc:ab57a9d1a5203bba2b39de65c36ff0f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: test if X is less or equal to Y  <a href="#ab57a9d1a5203bba2b39de65c36ff0f10">More...</a><br /></td></tr>
<tr class="separator:ab57a9d1a5203bba2b39de65c36ff0f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b51fbc891bd9d4cc066f47ce3767ed1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b51fbc891bd9d4cc066f47ce3767ed1"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a3b51fbc891bd9d4cc066f47ce3767ed1">IsZero</a> (T X)</td></tr>
<tr class="memdesc:a3b51fbc891bd9d4cc066f47ce3767ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: zero value check  <a href="#a3b51fbc891bd9d4cc066f47ce3767ed1">More...</a><br /></td></tr>
<tr class="separator:a3b51fbc891bd9d4cc066f47ce3767ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15396021180071b66983584e11c5d12"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac15396021180071b66983584e11c5d12"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ac15396021180071b66983584e11c5d12">Select</a> (T Mask, T A, T B)</td></tr>
<tr class="memdesc:ac15396021180071b66983584e11c5d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: combine the bits from two integers filtered by a mask value  <a href="#ac15396021180071b66983584e11c5d12">More...</a><br /></td></tr>
<tr class="separator:ac15396021180071b66983584e11c5d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d1b26171cdf47cba36db292394f12f"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:ac7d1b26171cdf47cba36db292394f12f"><td class="memTemplItemLeft" align="right" valign="top">static uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ac7d1b26171cdf47cba36db292394f12f">ShiftLeft</a> (const Array &amp;Input, Array &amp;Output)</td></tr>
<tr class="memdesc:ac7d1b26171cdf47cba36db292394f12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: left shift a vector of integers  <a href="#ac7d1b26171cdf47cba36db292394f12f">More...</a><br /></td></tr>
<tr class="separator:ac7d1b26171cdf47cba36db292394f12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34550b9b5ce09076c7e7e8707a93dc2f"><td class="memTemplParams" colspan="2">template&lt;typename P , typename V &gt; </td></tr>
<tr class="memitem:a34550b9b5ce09076c7e7e8707a93dc2f"><td class="memTemplItemLeft" align="right" valign="top">static V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a34550b9b5ce09076c7e7e8707a93dc2f">ValueOrZero</a> (P Pred, V Value)</td></tr>
<tr class="memdesc:a34550b9b5ce09076c7e7e8707a93dc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: select an integer based on a mask  <a href="#a34550b9b5ce09076c7e7e8707a93dc2f">More...</a><br /></td></tr>
<tr class="separator:a34550b9b5ce09076c7e7e8707a93dc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fbd0113c85e5dcc77179b1211a25de"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a21fbd0113c85e5dcc77179b1211a25de"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a21fbd0113c85e5dcc77179b1211a25de">Verify</a> (const ArrayA &amp;A, const ArrayB &amp;B, size_t Length)</td></tr>
<tr class="memdesc:a21fbd0113c85e5dcc77179b1211a25de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time: value comparison between two arrays with offset and length parameters.  <a href="#a21fbd0113c85e5dcc77179b1211a25de">More...</a><br /></td></tr>
<tr class="separator:a21fbd0113c85e5dcc77179b1211a25de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc3ef438f9020a9211533fca7007e08"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a5fc3ef438f9020a9211533fca7007e08">RotFL32</a> (uint Value, uint Shift)</td></tr>
<tr class="memdesc:a5fc3ef438f9020a9211533fca7007e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 32-bit integer to the left by a positive fixed non-zero increment  <a href="#a5fc3ef438f9020a9211533fca7007e08">More...</a><br /></td></tr>
<tr class="separator:a5fc3ef438f9020a9211533fca7007e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d83cbe635d13a9e16d4a6c4fc7d631"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a46d83cbe635d13a9e16d4a6c4fc7d631">RotFL64</a> (ulong Value, uint Shift)</td></tr>
<tr class="memdesc:a46d83cbe635d13a9e16d4a6c4fc7d631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 64-bit integer to the left by a positive fixed non-zero increment  <a href="#a46d83cbe635d13a9e16d4a6c4fc7d631">More...</a><br /></td></tr>
<tr class="separator:a46d83cbe635d13a9e16d4a6c4fc7d631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b49b3e42e6915a3706bc9c7101e3efc"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a9b49b3e42e6915a3706bc9c7101e3efc">RotFR32</a> (uint Value, uint Shift)</td></tr>
<tr class="memdesc:a9b49b3e42e6915a3706bc9c7101e3efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 32-bit integer to the right by a positive fixed non-zero increment  <a href="#a9b49b3e42e6915a3706bc9c7101e3efc">More...</a><br /></td></tr>
<tr class="separator:a9b49b3e42e6915a3706bc9c7101e3efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f2902962995270229154389b988338"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a68f2902962995270229154389b988338">RotFR64</a> (ulong Value, uint Shift)</td></tr>
<tr class="memdesc:a68f2902962995270229154389b988338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 64-bit integer to the right by a positive fixed non-zero increment  <a href="#a68f2902962995270229154389b988338">More...</a><br /></td></tr>
<tr class="separator:a68f2902962995270229154389b988338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05395df307d48e5b3eaccb39e2fbb56f"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#a05395df307d48e5b3eaccb39e2fbb56f">RotL32</a> (uint Value, uint Shift)</td></tr>
<tr class="memdesc:a05395df307d48e5b3eaccb39e2fbb56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 32-bit integer to the left  <a href="#a05395df307d48e5b3eaccb39e2fbb56f">More...</a><br /></td></tr>
<tr class="separator:a05395df307d48e5b3eaccb39e2fbb56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad215a8cab0b527fc10084bd301321670"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ad215a8cab0b527fc10084bd301321670">RotL64</a> (ulong Value, uint Shift)</td></tr>
<tr class="memdesc:ad215a8cab0b527fc10084bd301321670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 64-bit integer to the left  <a href="#ad215a8cab0b527fc10084bd301321670">More...</a><br /></td></tr>
<tr class="separator:ad215a8cab0b527fc10084bd301321670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbb5caa9b61f12ebb08e5aafdb954c8"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#affbb5caa9b61f12ebb08e5aafdb954c8">RotR32</a> (uint Value, uint Shift)</td></tr>
<tr class="memdesc:affbb5caa9b61f12ebb08e5aafdb954c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift a 32-bit integer to the right  <a href="#affbb5caa9b61f12ebb08e5aafdb954c8">More...</a><br /></td></tr>
<tr class="separator:affbb5caa9b61f12ebb08e5aafdb954c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39f5d8b8c89bcb3a9db4e8ba076f29c"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_integer_tools.html#ad39f5d8b8c89bcb3a9db4e8ba076f29c">RotR64</a> (ulong Value, uint Shift)</td></tr>
<tr class="memdesc:ad39f5d8b8c89bcb3a9db4e8ba076f29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 64-bit integer to the right  <a href="#ad39f5d8b8c89bcb3a9db4e8ba076f29c">More...</a><br /></td></tr>
<tr class="separator:ad39f5d8b8c89bcb3a9db4e8ba076f29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An integer utility functions class </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7e0c5ada557282025b041b43eef809da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0c5ada557282025b041b43eef809da">&#9670;&nbsp;</a></span>Abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::Abs </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the absolute value difference between two integers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first integer for comparison</td></tr>
    <tr><td class="paramname">B</td><td>The second integer for comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference between integers</dd></dl>

</div>
</div>
<a id="a65706b6faf98a3a5489293ae1be6801a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65706b6faf98a3a5489293ae1be6801a">&#9670;&nbsp;</a></span>Be16ToBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::Be16ToBytes </td>
          <td>(</td>
          <td class="paramtype">ushort&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 16-bit word to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 16-bit integer</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40c7afed2650b21f6fae6b2345242430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c7afed2650b21f6fae6b2345242430">&#9670;&nbsp;</a></span>Be16ToBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Array IntegerTools::Be16ToBytes </td>
          <td>(</td>
          <td class="paramtype">ushort&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 16-bit word to byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 16-bit integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of bytes in Big Endian order</dd></dl>

</div>
</div>
<a id="a1fb08055b27fa8d5a7dfd054be16f6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb08055b27fa8d5a7dfd054be16f6fb">&#9670;&nbsp;</a></span>Be32ToBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::Be32ToBytes </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 32-bit word to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 32-bit integer</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d50672147e3bfd797df3c3219c3d00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d50672147e3bfd797df3c3219c3d00c">&#9670;&nbsp;</a></span>Be32ToBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Array IntegerTools::Be32ToBytes </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 32-bit word to byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 32-bit integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of bytes in Big Endian order</dd></dl>

</div>
</div>
<a id="a4d57c369d19689c197672547167507e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d57c369d19689c197672547167507e2">&#9670;&nbsp;</a></span>Be64ToBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::Be64ToBytes </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 64-bit dword to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 64-bit word</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3ed69bcccafc1b52d65d8400f5bbb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ed69bcccafc1b52d65d8400f5bbb41">&#9670;&nbsp;</a></span>Be64ToBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Array IntegerTools::Be64ToBytes </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 64-bit dword to byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 64-bit integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of bytes in Big Endian order</dd></dl>

</div>
</div>
<a id="a613da552be2bd9b17c13487c5616d791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613da552be2bd9b17c13487c5616d791">&#9670;&nbsp;</a></span>BeBytesTo16()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ushort IntegerTools::BeBytesTo16 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Big Endian 16-bit word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit integer in Big Endian format</dd></dl>

</div>
</div>
<a id="acda1bed4737c5faab3d9c94a817a4286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda1bed4737c5faab3d9c94a817a4286">&#9670;&nbsp;</a></span>BeBytesTo32()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntegerTools::BeBytesTo32 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Big Endian 32-bit word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit integer in Big Endian format</dd></dl>

</div>
</div>
<a id="aef6204183fb59d09a53a3cb3ad5eaf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6204183fb59d09a53a3cb3ad5eaf16">&#9670;&nbsp;</a></span>BeBytesTo64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntegerTools::BeBytesTo64 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Big Endian 64-bit dword </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit integer in Big Endian format</dd></dl>

</div>
</div>
<a id="aa5ff476533ce948c5dbabb932839532a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ff476533ce948c5dbabb932839532a">&#9670;&nbsp;</a></span>BeIncrease8() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BeIncrease8 </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment an 8-bit integer vector by the value, treating the vector as a segmented large Big Endian integer counter. </p>
<p>The value type can be a 16, 32, or 64-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The target output byte vector</td></tr>
    <tr><td class="paramname">Value</td><td>The T value number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64505ff5e56f4a0ce3c275997f32ed57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64505ff5e56f4a0ce3c275997f32ed57">&#9670;&nbsp;</a></span>BeIncrease8() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BeIncrease8 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Big Endian integer counter. </p>
<p>The value type can be a 16, 32, or 64-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input byte vector to copy</td></tr>
    <tr><td class="paramname">Output</td><td>The target output byte vector</td></tr>
    <tr><td class="paramname">Value</td><td>The T value number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a421ca5fc67d34ad66a2cb0c1aaabf3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421ca5fc67d34ad66a2cb0c1aaabf3fd">&#9670;&nbsp;</a></span>BeIncrease8() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BeIncrease8 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Big Endian integer counter. </p>
<p>The value type can be a 16, 32, or 64-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input byte vector to copy</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output byte vector</td></tr>
    <tr><td class="paramname">Output</td><td>The target output byte vector</td></tr>
    <tr><td class="paramname">Value</td><td>The T value number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b5a36ec41ecc6c93cf7206883b6999e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5a36ec41ecc6c93cf7206883b6999e">&#9670;&nbsp;</a></span>BeIncrease8() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BeIncrease8 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Big Endian integer counter. </p>
<p>The value type can be a 16, 32, or 64-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input byte vector to copy</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output byte vector</td></tr>
    <tr><td class="paramname">Output</td><td>The target output byte vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes within the vector to treat as a segmented counter</td></tr>
    <tr><td class="paramname">Value</td><td>The T value number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d7752ad9d2567ce347c079bf268d0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7752ad9d2567ce347c079bf268d0fe">&#9670;&nbsp;</a></span>BeIncrement8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BeIncrement8 </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats a byte vector as a large Big Endian integer, incrementing the total value by one </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The counter byte vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b93ed47a8d1f3ed14bab591d78ef7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b93ed47a8d1f3ed14bab591d78ef7a1">&#9670;&nbsp;</a></span>BeIncrement8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BeIncrement8 </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats a byte vector as a large Big Endian integer, incrementing the total value by one </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The counter byte vector</td></tr>
    <tr><td class="paramname">Offset</td><td>The starting offset withing the vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of byte vector elements to process</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad00ef7dd392cc5d8a7de5309957b70e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00ef7dd392cc5d8a7de5309957b70e6">&#9670;&nbsp;</a></span>BeToBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BeToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian integer vector to a byte vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The integer input vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4629f1b7d1b6669b3534cd8276b31e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4629f1b7d1b6669b3534cd8276b31e8">&#9670;&nbsp;</a></span>BeUL256ToBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BeUL256ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 8 * 32bit word vector to a byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 32bit integer source vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62b9de1fc0e5b757c6cfdcbd614c08c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b9de1fc0e5b757c6cfdcbd614c08c3">&#9670;&nbsp;</a></span>BeULL512ToBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BeULL512ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 8 * 64bit word vector to a byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 64bit integer source vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa559bfe3ea294f05ba1cac1078f0cd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa559bfe3ea294f05ba1cac1078f0cd00">&#9670;&nbsp;</a></span>BlockToBe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BlockToBe </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert 8-bit byte vector to a Big Endian integer vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination integer vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39f3d8ee47f8a8cf9ba36a5d21b566d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f3d8ee47f8a8cf9ba36a5d21b566d4">&#9670;&nbsp;</a></span>BlockToLe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::BlockToLe </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian N * 8-bit word vector to an unsigned integer vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination integer vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to process</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca4bba2097eb4cd9fe7511b274283d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4bba2097eb4cd9fe7511b274283d51">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CEX_OPTIMIZE_IGNORE void IntegerTools::Clear </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cond PRIVATE </p>
<p>endcond </p>
<p>Clear nested vectors of objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>A nested vector integer vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a530bf3deb1dd650123e24027de07b9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530bf3deb1dd650123e24027de07b9c5">&#9670;&nbsp;</a></span>ClearArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Dimensions, size_t Length&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CEX_OPTIMIZE_RESUME static CEX_OPTIMIZE_IGNORE void IntegerTools::ClearArray </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, Length &gt;, Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cond PRIVATE </p>
<p>endcond cond PRIVATE endcond </p>
<p>Clear nested arrays of objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>A nested integer vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab7a23490fe053fd353007ddac02f84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7a23490fe053fd353007ddac02f84c">&#9670;&nbsp;</a></span>CMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::CMax </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: return the larger value of the two integers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first value to compare</td></tr>
    <tr><td class="paramname">B</td><td>The second value to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The larger value</dd></dl>

</div>
</div>
<a id="a405601101d450f6482ac828bcdb3cfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405601101d450f6482ac828bcdb3cfcb">&#9670;&nbsp;</a></span>CMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::CMin </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: return the lesser value of the two integers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first value to compare</td></tr>
    <tr><td class="paramname">B</td><td>The second value to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lesser value</dd></dl>

</div>
</div>
<a id="a1e229be8ad7ab89c65daf1a847569ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e229be8ad7ab89c65daf1a847569ad8">&#9670;&nbsp;</a></span>CMov()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::CMov </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>Condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: conditional move </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting index in the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting index in the destination vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of elements to copy</td></tr>
    <tr><td class="paramname">Condition</td><td>The condition</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8205d08b76335d60df3d9081ff9f00c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8205d08b76335d60df3d9081ff9f00c2">&#9670;&nbsp;</a></span>Compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IntegerTools::Compare </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>AOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayB &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>BOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: value comparison between two arrays with offset and length parameters. </p>
<p>Array container types can vary (standard vector, vector, or SecureVector), but vector elements must be of equal size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first vector to compare</td></tr>
    <tr><td class="paramname">AOffset</td><td>The starting offset within the 'A' vector</td></tr>
    <tr><td class="paramname">B</td><td>The second vector to compare</td></tr>
    <tr><td class="paramname">BOffset</td><td>The starting offset within the 'B' vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of elements to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if arrays are equivalant</dd></dl>

</div>
</div>
<a id="abfebf6e565d2c1fa4a5196e8fd930e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfebf6e565d2c1fa4a5196e8fd930e13">&#9670;&nbsp;</a></span>ConditionalCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::ConditionalCopy </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>To</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>From0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>From1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: conditional bit copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The destination mask</td></tr>
    <tr><td class="paramname">To</td><td>The destination vector</td></tr>
    <tr><td class="paramname">From0</td><td>The first value to copy</td></tr>
    <tr><td class="paramname">From1</td><td>The second value to copy</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bits to copy</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3095a77895e2c5dd774295a1934b30f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3095a77895e2c5dd774295a1934b30f3">&#9670;&nbsp;</a></span>ConditionalZeroMem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::ConditionalZeroMem </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: conditional bit erase </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Condition</td><td>The condition</td></tr>
    <tr><td class="paramname">Array</td><td>The vector to wipe</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bits to copy</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae07ccc2161dc68fda786aede2d5a1b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07ccc2161dc68fda786aede2d5a1b8b">&#9670;&nbsp;</a></span>Crop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntegerTools::Crop </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crop a 64-bit integer value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The base value</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bits in the new integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cropped integer</dd></dl>

</div>
</div>
<a id="a81be3713bb02c897b6330f9d9d1ae13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81be3713bb02c897b6330f9d9d1ae13e">&#9670;&nbsp;</a></span>ExpandMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::ExpandMask </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: expand an integer mask in constant time </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The N bit word</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A N bit expanded word</dd></dl>

</div>
</div>
<a id="ad6bc339bee93ad0ff59b0d8d16387d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bc339bee93ad0ff59b0d8d16387d9b">&#9670;&nbsp;</a></span>ExpandTopBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::ExpandTopBit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: last bit expansion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The value to expand</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A expanded N bit integer</dd></dl>

</div>
</div>
<a id="adfd27c5be4f958f210898c4a9ca1bc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd27c5be4f958f210898c4a9ca1bc55">&#9670;&nbsp;</a></span>Fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename Random &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CEX_OPTIMIZE_RESUME void IntegerTools::Fill </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Random &amp;&#160;</td>
          <td class="paramname"><em>Rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cond PRIVATE </p>
<p>endcond </p>
<p>Fills a vector of any type with random elements. </p>
<p>The random source can be any of the Prngs, Drbgs, or entropy Providers. The vector must be pre-sized to fit the new pseudo-random output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The output vector receiving random integers</td></tr>
    <tr><td class="paramname">Offset</td><td>The starting position within the output vector</td></tr>
    <tr><td class="paramname">Elements</td><td>The number of elements to generate</td></tr>
    <tr><td class="paramname">Rng</td><td>The random provider source</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70b93198cf823c1919aa0a12bf8667f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b93198cf823c1919aa0a12bf8667f9">&#9670;&nbsp;</a></span>Fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename Random &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::Fill </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Random *&#160;</td>
          <td class="paramname"><em>Rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a vector of any type with random elements. </p>
<p>The random source can be any of the Prngs, Drbgs, or entropy Providers. The vector must be pre-sized to fit the new pseudo-random output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The output vector receiving random integers</td></tr>
    <tr><td class="paramname">Offset</td><td>The starting position within the output vector</td></tr>
    <tr><td class="paramname">Elements</td><td>The number of elements to generate</td></tr>
    <tr><td class="paramname">Rng</td><td>A pointer to the random provider source</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cd695fd29b3178aad288fc5b868f28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd695fd29b3178aad288fc5b868f28e">&#9670;&nbsp;</a></span>FromHex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;byte&gt; IntegerTools::FromHex </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a hex formatted string to a vector of bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The string to convert</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hex string copied to a vector of bytes</dd></dl>

</div>
</div>
<a id="a6f49d61b5437bf6da96706c972032a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f49d61b5437bf6da96706c972032a7e">&#9670;&nbsp;</a></span>FromString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;byte&gt; IntegerTools::FromString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>Input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a string to a byte vector. </p>
<p>The output from this function is endian dependant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The string to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte vector containing the string values</dd></dl>

</div>
</div>
<a id="a6ab7a2f2a9e663113ab65a50b14771e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab7a2f2a9e663113ab65a50b14771e3">&#9670;&nbsp;</a></span>GetByte()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static byte IntegerTools::GetByte </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract an 8-bit integer from a larger integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The integer value to extract from</td></tr>
    <tr><td class="paramname">Index</td><td>The index position within the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted byte</dd></dl>

</div>
</div>
<a id="acc80f4b733d574f145ec621ff71abeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc80f4b733d574f145ec621ff71abeb1">&#9670;&nbsp;</a></span>IsBigEndian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IntegerTools::IsBigEndian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run time check for Little Endian byte order </p>

</div>
</div>
<a id="aacd002f623f6b8c06dcf968caa9a2c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd002f623f6b8c06dcf968caa9a2c95">&#9670;&nbsp;</a></span>IsEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::IsEqual </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: comparison of two integers for equality </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The first value to test</td></tr>
    <tr><td class="paramname">Y</td><td>The second value to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer if equal</dd></dl>

</div>
</div>
<a id="a13e0fdf6abd2ed7a0ae056071ee969a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e0fdf6abd2ed7a0ae056071ee969a5">&#9670;&nbsp;</a></span>IsLess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::IsLess </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: test if X is less than Y </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The first value to test</td></tr>
    <tr><td class="paramname">Y</td><td>The second value to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer if less</dd></dl>

</div>
</div>
<a id="ac3c7d6f9ddf7b92eee4f5490d02d14da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c7d6f9ddf7b92eee4f5490d02d14da">&#9670;&nbsp;</a></span>IsLittleEndian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IntegerTools::IsLittleEndian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run time check for Little Endian byte order </p>

</div>
</div>
<a id="ab57a9d1a5203bba2b39de65c36ff0f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57a9d1a5203bba2b39de65c36ff0f10">&#9670;&nbsp;</a></span>IsLte()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::IsLte </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: test if X is less or equal to Y </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The first value to test</td></tr>
    <tr><td class="paramname">Y</td><td>The second value to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer if less</dd></dl>

</div>
</div>
<a id="adb6e4b99d9e1a3859d05892e213d16f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6e4b99d9e1a3859d05892e213d16f3">&#9670;&nbsp;</a></span>IsPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IntegerTools::IsPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for power of 2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The base value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the value is a power of 2</dd></dl>

</div>
</div>
<a id="a3b51fbc891bd9d4cc066f47ce3767ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b51fbc891bd9d4cc066f47ce3767ed1">&#9670;&nbsp;</a></span>IsZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::IsZero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: zero value check </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The value to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer if non-zero</dd></dl>

</div>
</div>
<a id="a73285841973fd4bf6339f365562cf1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73285841973fd4bf6339f365562cf1b9">&#9670;&nbsp;</a></span>Le16ToBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::Le16ToBytes </td>
          <td>(</td>
          <td class="paramtype">ushort&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 16-bit word to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 16bit integer</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad382a4dfa4f938f6fa4ff71269d778ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad382a4dfa4f938f6fa4ff71269d778ab">&#9670;&nbsp;</a></span>Le16ToBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Array IntegerTools::Le16ToBytes </td>
          <td>(</td>
          <td class="paramtype">ushort&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 16-bit word to a byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 16-bit integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of bytes in Little Endian order</dd></dl>

</div>
</div>
<a id="a63b70af7dac8ee1f6016ae2c91a10878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b70af7dac8ee1f6016ae2c91a10878">&#9670;&nbsp;</a></span>Le32ToBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::Le32ToBytes </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 32-bit word to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 32-bit integer</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a343340b883de7897eedd67856656d8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343340b883de7897eedd67856656d8ea">&#9670;&nbsp;</a></span>Le32ToBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Array IntegerTools::Le32ToBytes </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 32-bit word to a byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 32-bit integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of bytes in Little Endian order</dd></dl>

</div>
</div>
<a id="a8bbada2d937ea5b71e03e2a4f184aac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbada2d937ea5b71e03e2a4f184aac9">&#9670;&nbsp;</a></span>Le64ToBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::Le64ToBytes </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 64-bit dword to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 64-bit integer</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2da4d41dce0a2b466dbb8e5b7a8ac1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da4d41dce0a2b466dbb8e5b7a8ac1c1">&#9670;&nbsp;</a></span>Le64ToBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Array IntegerTools::Le64ToBytes </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 64-bit dword to byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 64-bit integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of bytes in Little Endian order</dd></dl>

</div>
</div>
<a id="a14a4f5d0f0002a154992b9b2acdcf51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a4f5d0f0002a154992b9b2acdcf51d">&#9670;&nbsp;</a></span>LeBytesTo16()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ushort IntegerTools::LeBytesTo16 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Little Endian 16-bit word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit integer in Little Endian format</dd></dl>

</div>
</div>
<a id="a335a0491175bd2c51f05e404437bace0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335a0491175bd2c51f05e404437bace0">&#9670;&nbsp;</a></span>LeBytesTo32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntegerTools::LeBytesTo32 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Little Endian 32-bit word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit word in Little Endian format</dd></dl>

</div>
</div>
<a id="aeaf8696070365eef4fe8bd9c0e509090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf8696070365eef4fe8bd9c0e509090">&#9670;&nbsp;</a></span>LeBytesTo32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntegerTools::LeBytesTo32 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Little Endian 32-bit word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of input bytes to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit word in Little Endian format</dd></dl>

</div>
</div>
<a id="a7c52f3e9ddc7d925be4d79b0f3e4288d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c52f3e9ddc7d925be4d79b0f3e4288d">&#9670;&nbsp;</a></span>LeBytesTo64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntegerTools::LeBytesTo64 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Little Endian 64-bit dword </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit word in Little Endian format</dd></dl>

</div>
</div>
<a id="a93e1e2a33c07ac76441000b449f930ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e1e2a33c07ac76441000b449f930ed">&#9670;&nbsp;</a></span>LeBytesTo64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntegerTools::LeBytesTo64 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Little Endian 64-bit word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of input bytes to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit word in Little Endian format</dd></dl>

</div>
</div>
<a id="a0cd5d6111fd38c44221cb22217535705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd5d6111fd38c44221cb22217535705">&#9670;&nbsp;</a></span>LeBytesToUL512()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeBytesToUL512 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Little Endian 16 * 32bit word vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination 32bit integer vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcd4814f65e1daadae376eedb7e7b43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd4814f65e1daadae376eedb7e7b43f">&#9670;&nbsp;</a></span>LeBytesToULL1024()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeBytesToULL1024 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Little Endian 16 * 64bit word vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination 64bit integer vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac84d6206a133827c3f1445b61f71028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac84d6206a133827c3f1445b61f71028">&#9670;&nbsp;</a></span>LeBytesToULL256()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeBytesToULL256 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Little Endian 4 * 64bit word vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination 64bit integer vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b17d366f19bfa51dceca8be7e4dc21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b17d366f19bfa51dceca8be7e4dc21a">&#9670;&nbsp;</a></span>LeBytesToULL512()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeBytesToULL512 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte vector to a Little Endian 8 * 64bit word vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination 64bit integer vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a161dedb36471beb1b68bb8ac5d074800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161dedb36471beb1b68bb8ac5d074800">&#9670;&nbsp;</a></span>LeIncrease8() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeIncrease8 </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment an 8-bit integer vector by the value, treating the vector as a segmented large Little Endian integer counter. </p>
<p>The value type can be a 16, 32, or 64-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The target output byte vector</td></tr>
    <tr><td class="paramname">Value</td><td>The T value number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9446798853dae9373fb46ed424b7b84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9446798853dae9373fb46ed424b7b84a">&#9670;&nbsp;</a></span>LeIncrease8() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeIncrease8 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Little Endian integer counter. </p>
<p>The value type can be a 16, 32, or 64-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input byte vector to copy</td></tr>
    <tr><td class="paramname">Output</td><td>The target output byte vector</td></tr>
    <tr><td class="paramname">Value</td><td>The T value number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ebbecac07da87caaefc45ddec4f958a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebbecac07da87caaefc45ddec4f958a">&#9670;&nbsp;</a></span>LeIncrease8() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeIncrease8 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Little Endian integer counter. </p>
<p>The value type can be a 16, 32, or 64-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input byte vector to copy</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output byte vector</td></tr>
    <tr><td class="paramname">Output</td><td>The target output byte vector</td></tr>
    <tr><td class="paramname">Value</td><td>The T value number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9350ea1c8032f494e559cca8c45fdd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9350ea1c8032f494e559cca8c45fdd1b">&#9670;&nbsp;</a></span>LeIncrease8() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeIncrease8 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an 8-bit integer vector, and then increment it by the value, treating the vector as a segmented large Little Endian integer counter. </p>
<p>The value type can be a 16, 32, or 64-bit integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The input byte vector to copy</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output byte vector</td></tr>
    <tr><td class="paramname">Output</td><td>The target output byte vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes within the vector to treat as a segmented counter</td></tr>
    <tr><td class="paramname">Value</td><td>The T value number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8ed0214a2b6657fc7821cab9390e48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ed0214a2b6657fc7821cab9390e48d">&#9670;&nbsp;</a></span>LeIncreaseW() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeIncreaseW </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats an integer vector as a large Little Endian integer, increasing the total value by a defined length. </p>
<p>Uses only unsigned integer types; signed types are UB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The counter vector to increment</td></tr>
    <tr><td class="paramname">Length</td><td>The number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74362df7ef85e6e826699b2a16ee3a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74362df7ef85e6e826699b2a16ee3a34">&#9670;&nbsp;</a></span>LeIncreaseW() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeIncreaseW </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats an integer vector as a large Little Endian integer, increasing the total value by a defined length. </p>
<p>Uses only unsigned integer types; signed types are UB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The initial vector to clone</td></tr>
    <tr><td class="paramname">Output</td><td>The incremented output vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ae137281c8e572d72639af7ea252766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae137281c8e572d72639af7ea252766">&#9670;&nbsp;</a></span>LeIncrement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeIncrement </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats a vector as a segmented Little Endian integer, incrementing the total value by one </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The counter vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a441b742964162bb7247c694fb0855d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441b742964162bb7247c694fb0855d1f">&#9670;&nbsp;</a></span>LeIncrement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeIncrement </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats a byte vector as a segmented Little Endian integer, incrementing the total value by one </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The counter byte vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to treat as a counter</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a845fc608cfdf99003cdccb56b97a5bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845fc608cfdf99003cdccb56b97a5bda">&#9670;&nbsp;</a></span>LeIncrementW()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeIncrementW </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats an integer vector as a large Little Endian integer, incrementing the total value by one. </p>
<p>Uses only the first two elements of the Output vector; used by 32 or 64-bit integer types. Uses only unsigned integer types; signed types are UB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The counter vector to increment</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1881baf8ff7d9c9897e5b8404928f2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1881baf8ff7d9c9897e5b8404928f2cd">&#9670;&nbsp;</a></span>LeToBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian unsigned integer vector to a byte vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source integer vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a221f6fc04d17f8b156c2dbe7b461d91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221f6fc04d17f8b156c2dbe7b461d91a">&#9670;&nbsp;</a></span>LeUL256ToBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeUL256ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 8 * 32bit word vector to a byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 32bit integer vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3f485466f17f43a0c45ff3fc4c018f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f485466f17f43a0c45ff3fc4c018f4">&#9670;&nbsp;</a></span>LeULL1024ToBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeULL1024ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 16 * 64bit word vector to a byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 64bit integer vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a861a1ecdf5fa470a124ecc8a18562559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861a1ecdf5fa470a124ecc8a18562559">&#9670;&nbsp;</a></span>LeULL256ToBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeULL256ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 4 * 64bit word vector to a byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 64bit integer vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d8fa518adca24586c6787e27bc87411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8fa518adca24586c6787e27bc87411">&#9670;&nbsp;</a></span>LeULL512ToBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntegerTools::LeULL512ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 8 * 64bit word vector to a byte vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 64bit integer vector</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source vector</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte vector</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination vector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a013fe0c0864812529ffc86bdff3dc783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013fe0c0864812529ffc86bdff3dc783">&#9670;&nbsp;</a></span>Max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::Max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the larger of two integer values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first comparison value</td></tr>
    <tr><td class="paramname">B</td><td>The second comparison value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The larger value</dd></dl>

</div>
</div>
<a id="aa8a79e766e59a1e700534afa3939648a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a79e766e59a1e700534afa3939648a">&#9670;&nbsp;</a></span>Min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::Min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smaller of two integer values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first comparison value</td></tr>
    <tr><td class="paramname">B</td><td>The second comparison value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smaller value</dd></dl>

</div>
</div>
<a id="a7ad85dc811b47fefd717a5ac114cbeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad85dc811b47fefd717a5ac114cbeb1">&#9670;&nbsp;</a></span>ModPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T2 IntegerTools::ModPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mod a power of two integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The base value</td></tr>
    <tr><td class="paramname">B</td><td>The modulus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value</dd></dl>

</div>
</div>
<a id="a0e530bddce7cc292fc6d76c1c67b4c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e530bddce7cc292fc6d76c1c67b4c9b">&#9670;&nbsp;</a></span>Parity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntegerTools::Parity </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parity bit from a 64-bit integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parity 32-bit value</dd></dl>

</div>
</div>
<a id="a5fc3ef438f9020a9211533fca7007e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc3ef438f9020a9211533fca7007e08">&#9670;&nbsp;</a></span>RotFL32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntegerTools::RotFL32 </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 32-bit integer to the left by a positive fixed non-zero increment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift, shift can not be zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The left shifted integer</dd></dl>

</div>
</div>
<a id="a46d83cbe635d13a9e16d4a6c4fc7d631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d83cbe635d13a9e16d4a6c4fc7d631">&#9670;&nbsp;</a></span>RotFL64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntegerTools::RotFL64 </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 64-bit integer to the left by a positive fixed non-zero increment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift, shift can not be zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The left shifted integer</dd></dl>

</div>
</div>
<a id="a9b49b3e42e6915a3706bc9c7101e3efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b49b3e42e6915a3706bc9c7101e3efc">&#9670;&nbsp;</a></span>RotFR32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntegerTools::RotFR32 </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 32-bit integer to the right by a positive fixed non-zero increment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift, shift can not be zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The right shifted integer</dd></dl>

</div>
</div>
<a id="a68f2902962995270229154389b988338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f2902962995270229154389b988338">&#9670;&nbsp;</a></span>RotFR64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntegerTools::RotFR64 </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 64-bit integer to the right by a positive fixed non-zero increment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift, shift can not be zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The right shifted 64-bit integer</dd></dl>

</div>
</div>
<a id="a05395df307d48e5b3eaccb39e2fbb56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05395df307d48e5b3eaccb39e2fbb56f">&#9670;&nbsp;</a></span>RotL32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntegerTools::RotL32 </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 32-bit integer to the left </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The left shifted integer</dd></dl>

</div>
</div>
<a id="ad215a8cab0b527fc10084bd301321670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad215a8cab0b527fc10084bd301321670">&#9670;&nbsp;</a></span>RotL64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntegerTools::RotL64 </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 64-bit integer to the left </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The left shifted integer</dd></dl>

</div>
</div>
<a id="affbb5caa9b61f12ebb08e5aafdb954c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbb5caa9b61f12ebb08e5aafdb954c8">&#9670;&nbsp;</a></span>RotR32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntegerTools::RotR32 </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift a 32-bit integer to the right </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The right shifted integer</dd></dl>

</div>
</div>
<a id="ad39f5d8b8c89bcb3a9db4e8ba076f29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39f5d8b8c89bcb3a9db4e8ba076f29c">&#9670;&nbsp;</a></span>RotR64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntegerTools::RotR64 </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 64-bit integer to the right </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The right shifted integer</dd></dl>

</div>
</div>
<a id="ac15396021180071b66983584e11c5d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15396021180071b66983584e11c5d12">&#9670;&nbsp;</a></span>Select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntegerTools::Select </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: combine the bits from two integers filtered by a mask value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mask</td><td>The mask value</td></tr>
    <tr><td class="paramname">A</td><td>The first value</td></tr>
    <tr><td class="paramname">B</td><td>The second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A combined N bit integer</dd></dl>

</div>
</div>
<a id="ac7d1b26171cdf47cba36db292394f12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d1b26171cdf47cba36db292394f12f">&#9670;&nbsp;</a></span>ShiftLeft()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntegerTools::ShiftLeft </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: left shift a vector of integers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The value vector to shift</td></tr>
    <tr><td class="paramname">Output</td><td>The output integer vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit count</dd></dl>

</div>
</div>
<a id="a92878912738bf8f0594f18015bd7ebc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92878912738bf8f0594f18015bd7ebc1">&#9670;&nbsp;</a></span>ToHex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string IntegerTools::ToHex </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an array or vector of T to a hexadecimal string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The array of T to convert</td></tr>
    <tr><td class="paramname">Offset</td><td>The initial input offset</td></tr>
    <tr><td class="paramname">Length</td><td>The number of T values to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hex string representation</dd></dl>

</div>
</div>
<a id="afce1c6a0203d13eff293bbf84cb87da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce1c6a0203d13eff293bbf84cb87da5">&#9670;&nbsp;</a></span>ToHex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string IntegerTools::ToHex </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a value of T to a hexadecimal string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The value of T to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hex string representation</dd></dl>

</div>
</div>
<a id="aa716fc3ff06e4ab5947d614e1a149dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa716fc3ff06e4ab5947d614e1a149dc8">&#9670;&nbsp;</a></span>ToString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string IntegerTools::ToString </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an integer to a string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The integer to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation</dd></dl>

</div>
</div>
<a id="aab89f47d97d20f2fd77a59d535bdf338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab89f47d97d20f2fd77a59d535bdf338">&#9670;&nbsp;</a></span>ToString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string IntegerTools::ToString </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a vector or vector of T to a string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The integer vector to convert</td></tr>
    <tr><td class="paramname">Offset</td><td>The initial input offset</td></tr>
    <tr><td class="paramname">Length</td><td>The number of T values to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation</dd></dl>

</div>
</div>
<a id="a34550b9b5ce09076c7e7e8707a93dc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34550b9b5ce09076c7e7e8707a93dc2f">&#9670;&nbsp;</a></span>ValueOrZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static V IntegerTools::ValueOrZero </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: select an integer based on a mask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pred</td><td>The mask value</td></tr>
    <tr><td class="paramname">Value</td><td>The value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A masked N bit integer</dd></dl>

</div>
</div>
<a id="a21fbd0113c85e5dcc77179b1211a25de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fbd0113c85e5dcc77179b1211a25de">&#9670;&nbsp;</a></span>Verify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t IntegerTools::Verify </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrayB &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time: value comparison between two arrays with offset and length parameters. </p>
<p>Array container types can vary (standard vector, vector, or SecureVector), but vector elements must be of equal size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first vector to compare</td></tr>
    <tr><td class="paramname">B</td><td>The second vector to compare</td></tr>
    <tr><td class="paramname">Length</td><td>The number of elements to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer for each different value, or zero if the arrays are identical</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/<a class="el" href="_documentation_8h_source.html">Documentation.h</a></li>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/<a class="el" href="_integer_tools_8h_source.html">IntegerTools.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
