<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CEX++: Blake256 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CEX++
   &#160;<span id="projectnumber">1.0.0.7</span>
   </div>
   <div id="projectbrief">The CEX Cryptographic Library in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_blake256-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Blake256 Class Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group___c_e_x.html">CEX</a> &raquo; <a class="el" href="group___digest.html">Digest</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An implementation of the Blake2S and Blake2SP digests with a 256 bit digest output size  
 <a href="class_blake256.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_blake256_8h_source.html">Blake256.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Blake256:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_blake256.png" usemap="#Blake256_map" alt=""/>
  <map id="Blake256_map" name="Blake256_map">
<area href="class_i_digest.html" title="Hash Digest Interface " alt="IDigest" shape="rect" coords="0,0,64,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f1c66aaec4cfe793067e06bab365c70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a6f1c66aaec4cfe793067e06bab365c70">Blake256</a> (const <a class="el" href="class_blake256.html">Blake256</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6f1c66aaec4cfe793067e06bab365c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="#a6f1c66aaec4cfe793067e06bab365c70">More...</a><br /></td></tr>
<tr class="separator:a6f1c66aaec4cfe793067e06bab365c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c20fd42b5cfb37d79d4dcd1dd383d6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_blake256.html">Blake256</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a7c20fd42b5cfb37d79d4dcd1dd383d6e">operator=</a> (const <a class="el" href="class_blake256.html">Blake256</a> &amp;)=delete</td></tr>
<tr class="memdesc:a7c20fd42b5cfb37d79d4dcd1dd383d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="#a7c20fd42b5cfb37d79d4dcd1dd383d6e">More...</a><br /></td></tr>
<tr class="separator:a7c20fd42b5cfb37d79d4dcd1dd383d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246ed3ef6d6d33a7376964eb3889a39d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a246ed3ef6d6d33a7376964eb3889a39d">Blake256</a> (bool Parallel=false)</td></tr>
<tr class="memdesc:a246ed3ef6d6d33a7376964eb3889a39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the class as either the 2S or 2SP.  <a href="#a246ed3ef6d6d33a7376964eb3889a39d">More...</a><br /></td></tr>
<tr class="separator:a246ed3ef6d6d33a7376964eb3889a39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41bdb13833cab45f4860184573039e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#af41bdb13833cab45f4860184573039e3">Blake256</a> (<a class="el" href="struct_blake_params.html">BlakeParams</a> &amp;Params)</td></tr>
<tr class="memdesc:af41bdb13833cab45f4860184573039e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the class with a BlakeParams structure.  <a href="#af41bdb13833cab45f4860184573039e3">More...</a><br /></td></tr>
<tr class="separator:af41bdb13833cab45f4860184573039e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1afbae3da5348f3090d86f889d7dbb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#af1afbae3da5348f3090d86f889d7dbb3">~Blake256</a> () override</td></tr>
<tr class="memdesc:af1afbae3da5348f3090d86f889d7dbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="#af1afbae3da5348f3090d86f889d7dbb3">More...</a><br /></td></tr>
<tr class="separator:af1afbae3da5348f3090d86f889d7dbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97d70df144de5f3541fa7542e5f4a28"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#ae97d70df144de5f3541fa7542e5f4a28">BlockSize</a> () override</td></tr>
<tr class="memdesc:ae97d70df144de5f3541fa7542e5f4a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The Digests internal blocksize in bytes  <a href="#ae97d70df144de5f3541fa7542e5f4a28">More...</a><br /></td></tr>
<tr class="separator:ae97d70df144de5f3541fa7542e5f4a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcd9d1ca0371fce1b26d47afe093e14"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a4dcd9d1ca0371fce1b26d47afe093e14">DigestSize</a> () override</td></tr>
<tr class="memdesc:a4dcd9d1ca0371fce1b26d47afe093e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Size of returned digest in bytes  <a href="#a4dcd9d1ca0371fce1b26d47afe093e14">More...</a><br /></td></tr>
<tr class="separator:a4dcd9d1ca0371fce1b26d47afe093e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4755475b3aa835b4fe6aa57d7aed819b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___enumeration.html#gab52dd4d279d842e68f46a2a0499c10c3">Digests</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a4755475b3aa835b4fe6aa57d7aed819b">Enumeral</a> () override</td></tr>
<tr class="memdesc:a4755475b3aa835b4fe6aa57d7aed819b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The digests type name  <a href="#a4755475b3aa835b4fe6aa57d7aed819b">More...</a><br /></td></tr>
<tr class="separator:a4755475b3aa835b4fe6aa57d7aed819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df84749e8111332b9170e34a3d1bd4a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a7df84749e8111332b9170e34a3d1bd4a">IsParallel</a> () override</td></tr>
<tr class="memdesc:a7df84749e8111332b9170e34a3d1bd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Processor parallelization availability.  <a href="#a7df84749e8111332b9170e34a3d1bd4a">More...</a><br /></td></tr>
<tr class="separator:a7df84749e8111332b9170e34a3d1bd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7813f41667f50aebb42dc72a04f75d"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a7d7813f41667f50aebb42dc72a04f75d">Name</a> () override</td></tr>
<tr class="memdesc:a7d7813f41667f50aebb42dc72a04f75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: The digests class name  <a href="#a7d7813f41667f50aebb42dc72a04f75d">More...</a><br /></td></tr>
<tr class="separator:a7d7813f41667f50aebb42dc72a04f75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833009639b43ec3d667d8cd5890e2fe8"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a833009639b43ec3d667d8cd5890e2fe8">ParallelBlockSize</a> () override</td></tr>
<tr class="memdesc:a833009639b43ec3d667d8cd5890e2fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Only: Parallel block size; the byte-size of the input data array passed to the Update function that triggers parallel processing.  <a href="#a833009639b43ec3d667d8cd5890e2fe8">More...</a><br /></td></tr>
<tr class="separator:a833009639b43ec3d667d8cd5890e2fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32743a0d3f437a1cafdcfd1272299f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_parallel_options.html">ParallelOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a32743a0d3f437a1cafdcfd1272299f56">ParallelProfile</a> () override</td></tr>
<tr class="memdesc:a32743a0d3f437a1cafdcfd1272299f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read/Write: Contains parallel settings and SIMD capability flags in a ParallelOptions structure.  <a href="#a32743a0d3f437a1cafdcfd1272299f56">More...</a><br /></td></tr>
<tr class="separator:a32743a0d3f437a1cafdcfd1272299f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2464773ba54a40deab1bf2629192d7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#ae2464773ba54a40deab1bf2629192d7b">Compute</a> (const std::vector&lt; byte &gt; &amp;Input, std::vector&lt; byte &gt; &amp;Output) override</td></tr>
<tr class="memdesc:ae2464773ba54a40deab1bf2629192d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the message data and return the Hash value  <a href="#ae2464773ba54a40deab1bf2629192d7b">More...</a><br /></td></tr>
<tr class="separator:ae2464773ba54a40deab1bf2629192d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac52f2084657eba9381c7affc5db1e9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a9ac52f2084657eba9381c7affc5db1e9">Finalize</a> (std::vector&lt; byte &gt; &amp;Output, const size_t OutOffset) override</td></tr>
<tr class="memdesc:a9ac52f2084657eba9381c7affc5db1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform final processing and return the hash value  <a href="#a9ac52f2084657eba9381c7affc5db1e9">More...</a><br /></td></tr>
<tr class="separator:a9ac52f2084657eba9381c7affc5db1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc9d7dbc31200b09735bba9377577c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#aefc9d7dbc31200b09735bba9377577c9">Initialize</a> (<a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;MacKey)</td></tr>
<tr class="memdesc:aefc9d7dbc31200b09735bba9377577c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the digest as a MAC code generator  <a href="#aefc9d7dbc31200b09735bba9377577c9">More...</a><br /></td></tr>
<tr class="separator:aefc9d7dbc31200b09735bba9377577c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d720c1a77767c4e46282472192c48d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a7d720c1a77767c4e46282472192c48d6">ParallelMaxDegree</a> (size_t Degree) override</td></tr>
<tr class="memdesc:a7d720c1a77767c4e46282472192c48d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads allocated when using multi-threaded tree hashing processing.  <a href="#a7d720c1a77767c4e46282472192c48d6">More...</a><br /></td></tr>
<tr class="separator:a7d720c1a77767c4e46282472192c48d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e33c56e5831a3bbddc9b80eaf6fa646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a8e33c56e5831a3bbddc9b80eaf6fa646">Reset</a> () override</td></tr>
<tr class="memdesc:a8e33c56e5831a3bbddc9b80eaf6fa646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal state to sequential defaults  <a href="#a8e33c56e5831a3bbddc9b80eaf6fa646">More...</a><br /></td></tr>
<tr class="separator:a8e33c56e5831a3bbddc9b80eaf6fa646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae893f1cb552f5906f054b8b02b0003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#aeae893f1cb552f5906f054b8b02b0003">Update</a> (byte Input) override</td></tr>
<tr class="memdesc:aeae893f1cb552f5906f054b8b02b0003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the message digest with a single byte  <a href="#aeae893f1cb552f5906f054b8b02b0003">More...</a><br /></td></tr>
<tr class="separator:aeae893f1cb552f5906f054b8b02b0003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5428dac06692981c038d1cf787735f1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_blake256.html#a5428dac06692981c038d1cf787735f1b">Update</a> (const std::vector&lt; byte &gt; &amp;Input, size_t InOffset, size_t Length) override</td></tr>
<tr class="memdesc:a5428dac06692981c038d1cf787735f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the message buffer  <a href="#a5428dac06692981c038d1cf787735f1b">More...</a><br /></td></tr>
<tr class="separator:a5428dac06692981c038d1cf787735f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_digest"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_digest')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_digest.html">IDigest</a></td></tr>
<tr class="memitem:a3efc443269eb9737fac182ec2c6998b6 inherit pub_methods_class_i_digest"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_digest.html#a3efc443269eb9737fac182ec2c6998b6">IDigest</a> (const <a class="el" href="class_i_digest.html">IDigest</a> &amp;)=delete</td></tr>
<tr class="memdesc:a3efc443269eb9737fac182ec2c6998b6 inherit pub_methods_class_i_digest"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: copy is restricted, this function has been deleted  <a href="class_i_digest.html#a3efc443269eb9737fac182ec2c6998b6">More...</a><br /></td></tr>
<tr class="separator:a3efc443269eb9737fac182ec2c6998b6 inherit pub_methods_class_i_digest"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778974f9530c8d44d65b2535f3771fc9 inherit pub_methods_class_i_digest"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_digest.html">IDigest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_digest.html#a778974f9530c8d44d65b2535f3771fc9">operator=</a> (const <a class="el" href="class_i_digest.html">IDigest</a> &amp;)=delete</td></tr>
<tr class="memdesc:a778974f9530c8d44d65b2535f3771fc9 inherit pub_methods_class_i_digest"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator: copy is restricted, this function has been deleted  <a href="class_i_digest.html#a778974f9530c8d44d65b2535f3771fc9">More...</a><br /></td></tr>
<tr class="separator:a778974f9530c8d44d65b2535f3771fc9 inherit pub_methods_class_i_digest"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4889250e58892e117697934fa70cbd5c inherit pub_methods_class_i_digest"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_digest.html#a4889250e58892e117697934fa70cbd5c">IDigest</a> ()</td></tr>
<tr class="memdesc:a4889250e58892e117697934fa70cbd5c inherit pub_methods_class_i_digest"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: Instantiate this class  <a href="class_i_digest.html#a4889250e58892e117697934fa70cbd5c">More...</a><br /></td></tr>
<tr class="separator:a4889250e58892e117697934fa70cbd5c inherit pub_methods_class_i_digest"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8e518f2f788f6a755548e95d0985e0 inherit pub_methods_class_i_digest"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_digest.html#a6b8e518f2f788f6a755548e95d0985e0">~IDigest</a> () noexcept</td></tr>
<tr class="memdesc:a6b8e518f2f788f6a755548e95d0985e0 inherit pub_methods_class_i_digest"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: finalize this class  <a href="class_i_digest.html#a6b8e518f2f788f6a755548e95d0985e0">More...</a><br /></td></tr>
<tr class="separator:a6b8e518f2f788f6a755548e95d0985e0 inherit pub_methods_class_i_digest"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of the Blake2S and Blake2SP digests with a 256 bit digest output size </p>
<p>Example using the Compute method: </p>
<p>Use the Compute method for small to medium data sizes.</p>
<div class="fragment"><div class="line"><a class="code" href="class_blake256.html">Blake256</a> dgt;</div><div class="line">std::vector&lt;byte&gt; hash(dgt.<a class="code" href="class_blake256.html#a4dcd9d1ca0371fce1b26d47afe093e14">DigestSize</a>(), 0);</div><div class="line"><span class="comment">// compute a hash</span></div><div class="line">dgt.<a class="code" href="class_blake256.html#ae2464773ba54a40deab1bf2629192d7b">Compute</a>(input, hash);</div></div><!-- fragment --> <p>Use the Update method for large data sizes: </p><div class="fragment"><div class="line"><a class="code" href="class_blake256.html">Blake256</a> dgt;</div><div class="line">std::vector&lt;byte&gt; hash(dgt.<a class="code" href="class_blake256.html#a4dcd9d1ca0371fce1b26d47afe093e14">DigestSize</a>(), 0);</div><div class="line">int64_t len = (int64_t)input.size();</div><div class="line"></div><div class="line"><span class="comment">// update blocks</span></div><div class="line"><span class="keywordflow">while</span> (len &gt; dgt.<a class="code" href="class_blake256.html#a4dcd9d1ca0371fce1b26d47afe093e14">DigestSize</a>())</div><div class="line">{</div><div class="line">    dgt.<a class="code" href="class_blake256.html#aeae893f1cb552f5906f054b8b02b0003">Update</a>(input, offset, len);</div><div class="line">    offset += dgt.<a class="code" href="class_blake256.html#a4dcd9d1ca0371fce1b26d47afe093e14">DigestSize</a>();</div><div class="line">    len -= dgt.<a class="code" href="class_blake256.html#a4dcd9d1ca0371fce1b26d47afe093e14">DigestSize</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (len &gt; 0)</div><div class="line">    dgt.<a class="code" href="class_blake256.html#aeae893f1cb552f5906f054b8b02b0003">Update</a>(input, offset, len);</div><div class="line"></div><div class="line">dgt.<a class="code" href="class_blake256.html#a9ac52f2084657eba9381c7affc5db1e9">Finalize</a>(hash, 0);</div></div><!-- fragment --> <p>Implementation Notes: </p><ul>
<li>
Algorithm is selected through the constructor (2S or 2SP), parallel version is selected through either the Parallel flag, or via the BlakeParams ThreadCount() configuration parameter. </li>
<li>
Parallel and sequential algorithms (Blake2S or Blake2SP) produce different digest outputs, this is expected. </li>
<li>
Sequential Block size is 64 bytes, (512 bits), but smaller or larger blocks can be processed, for best performance, align message input to a multiple of the internal block size. </li>
<li>
Parallel Block input size to the Update function should be aligned to a multiple of ParallelMinimumSize() for best performance. </li>
<li>
Best performance for parallel mode is to use a large input block size to minimize parallel loop creation cost, block size should be in a range of 32KiB to 25MiB. </li>
<li>
The number of threads used in parallel mode can be user defined through the BlakeParams-&gt;ThreadCount property to any even number of threads; note that hash value will change with threadcount. </li>
<li>
Digest output size is fixed at 32 bytes, (256 bits). </li>
<li>
The Compute(byte[]) method wraps the Update(byte[], size_t, size_t) and Finalize methods/&gt; </li>
<li>
The Finalize(byte[], size_t) method resets the internal state. </li>
<li>
Optional intrinsics are runtime enabled automatically based on cpu support. </li>
<li>
SIMD implementation requires compilation with SSE3 or higher. </li>
</ul>
<p>Guiding Publications: </p><ol>
<li>
Blake2 <a href="https://blake2.net/">Homepage</a>. </li>
<li>
Blake2 on <a href="https://github.com/BLAKE2/BLAKE2">Github</a>. </li>
<li>
Blake2 whitepaper <a href="https://blake2.net/blake2.pdf">BLAKE2: simpler, smaller, fast as MD5</a>. </li>
<li>
NIST <a href="https://131002.net/blake">SHA3 Proposal Blake</a>. </li>
<li>
NIST <a href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">SHA3: Third-Round Report</a> of the SHA-3 Cryptographic Hash Algorithm Competition. </li>
<li>
SHA3 Submission in C: <a href="https://131002.net/blake/blake_ref.c">blake_ref.c</a>. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6f1c66aaec4cfe793067e06bab365c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1c66aaec4cfe793067e06bab365c70">&#9670;&nbsp;</a></span>Blake256() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Blake256::Blake256 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_blake256.html">Blake256</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: copy is restricted, this function has been deleted </p>

</div>
</div>
<a id="a246ed3ef6d6d33a7376964eb3889a39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246ed3ef6d6d33a7376964eb3889a39d">&#9670;&nbsp;</a></span>Blake256() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Blake256::Blake256 </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Parallel</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the class as either the 2S or 2SP. </p>
<p>Initialize as either the parallel version Blake2SP, or sequential Blake2S. Note: this constructor will revert to sequential processing when set to parallel on a system that does not support parallel processing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Parallel</td><td>Setting the Parallel flag to true, instantiates the Blake2SP variant.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af41bdb13833cab45f4860184573039e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41bdb13833cab45f4860184573039e3">&#9670;&nbsp;</a></span>Blake256() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Blake256::Blake256 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_blake_params.html">BlakeParams</a> &amp;&#160;</td>
          <td class="paramname"><em>Params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the class with a BlakeParams structure. </p>
<p>The parameters structure allows for tuning of the internal configuration string, and changing the number of threads used by the parallel mechanism (ThreadCount). If the ThreadCount is greater than 1, parallel mode (Blake2SP) is instantiated. The default thread count is 8, changing from the default will produce a different output hash code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Params</td><td>The BlakeParams structure, containing the tree configuration settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoDigestException</td><td>Thrown if an invalid configuration parameters are used</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1afbae3da5348f3090d86f889d7dbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1afbae3da5348f3090d86f889d7dbb3">&#9670;&nbsp;</a></span>~Blake256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Blake256::~Blake256 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor: finalize this class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae97d70df144de5f3541fa7542e5f4a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97d70df144de5f3541fa7542e5f4a28">&#9670;&nbsp;</a></span>BlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Blake256::BlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The Digests internal blocksize in bytes </p>

<p>Implements <a class="el" href="class_i_digest.html#ab1e4146c28b3623c488214ef37d8530a">IDigest</a>.</p>

</div>
</div>
<a id="ae2464773ba54a40deab1bf2629192d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2464773ba54a40deab1bf2629192d7b">&#9670;&nbsp;</a></span>Compute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Blake256::Compute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the message data and return the Hash value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The message input data</td></tr>
    <tr><td class="paramname">Output</td><td>The hash value output array</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_digest.html#a5d085bbb954b715f4a85aa077c25640f">IDigest</a>.</p>

</div>
</div>
<a id="a4dcd9d1ca0371fce1b26d47afe093e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcd9d1ca0371fce1b26d47afe093e14">&#9670;&nbsp;</a></span>DigestSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Blake256::DigestSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Size of returned digest in bytes </p>

<p>Implements <a class="el" href="class_i_digest.html#ace4a6bf16017c688f77c7ea9b31f189e">IDigest</a>.</p>

</div>
</div>
<a id="a4755475b3aa835b4fe6aa57d7aed819b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4755475b3aa835b4fe6aa57d7aed819b">&#9670;&nbsp;</a></span>Enumeral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___enumeration.html#gab52dd4d279d842e68f46a2a0499c10c3">Digests</a> Blake256::Enumeral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The digests type name </p>

<p>Implements <a class="el" href="class_i_digest.html#a01058025d9343eeacb5935561edf5059">IDigest</a>.</p>

</div>
</div>
<a id="a9ac52f2084657eba9381c7affc5db1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac52f2084657eba9381c7affc5db1e9">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Blake256::Finalize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform final processing and return the hash value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The Hash output value array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the Output array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of Hash value</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoDigestException</td><td>Thrown if the output buffer is too short</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_digest.html#a053f8cf8e3efe23f4203f6bd4f88c86e">IDigest</a>.</p>

</div>
</div>
<a id="aefc9d7dbc31200b09735bba9377577c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc9d7dbc31200b09735bba9377577c9">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Blake256::Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_symmetric_key.html">ISymmetricKey</a> &amp;&#160;</td>
          <td class="paramname"><em>MacKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the digest as a MAC code generator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MacKey</td><td>The input key parameters. </td></tr>
  </table>
  </dd>
</dl>
<p>The input Key must be a maximum size of 32 bytes, and a minimum size of 16 bytes. If either the Salt or Info parameters are used, their size must be 8 bytes. The maximum combined size of Key, Salt, and Info, must be 64 bytes or less.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoDigestException</td><td>Thrown if an invalid key size is used</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7df84749e8111332b9170e34a3d1bd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df84749e8111332b9170e34a3d1bd4a">&#9670;&nbsp;</a></span>IsParallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool Blake256::IsParallel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Processor parallelization availability. </p>
<p>Indicates whether parallel processing is available on this system. If parallel capable, input data array passed to the Update function must be ParallelBlockSize in bytes to trigger parallelization.</p>

<p>Implements <a class="el" href="class_i_digest.html#a6533f6d6dc8028fc71c060bb7e8bb477">IDigest</a>.</p>

</div>
</div>
<a id="a7d7813f41667f50aebb42dc72a04f75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7813f41667f50aebb42dc72a04f75d">&#9670;&nbsp;</a></span>Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string Blake256::Name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: The digests class name </p>

<p>Implements <a class="el" href="class_i_digest.html#a34f2a2b026e092d2c93f71885a3202ea">IDigest</a>.</p>

</div>
</div>
<a id="a7c20fd42b5cfb37d79d4dcd1dd383d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c20fd42b5cfb37d79d4dcd1dd383d6e">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_blake256.html">Blake256</a>&amp; Blake256::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_blake256.html">Blake256</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy operator: copy is restricted, this function has been deleted </p>

</div>
</div>
<a id="a833009639b43ec3d667d8cd5890e2fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833009639b43ec3d667d8cd5890e2fe8">&#9670;&nbsp;</a></span>ParallelBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t Blake256::ParallelBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read Only: Parallel block size; the byte-size of the input data array passed to the Update function that triggers parallel processing. </p>
<p>This value can be changed through the ParallelProfile class.</p>

<p>Implements <a class="el" href="class_i_digest.html#a97482fb7bbf3635af3a5ded0335a45af">IDigest</a>.</p>

</div>
</div>
<a id="a7d720c1a77767c4e46282472192c48d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d720c1a77767c4e46282472192c48d6">&#9670;&nbsp;</a></span>ParallelMaxDegree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Blake256::ParallelMaxDegree </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of threads allocated when using multi-threaded tree hashing processing. </p>
<p>Thread count must be an even number, and not exceed the number of processor cores. Changing this value from the default (8 threads), will change the output hash value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Degree</td><td>The desired number of threads to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CryptoCipherModeException</td><td>Thrown if the degree parameter is invalid</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_digest.html#aa7a2f8afffc106332ccb72c53cd5b505">IDigest</a>.</p>

</div>
</div>
<a id="a32743a0d3f437a1cafdcfd1272299f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32743a0d3f437a1cafdcfd1272299f56">&#9670;&nbsp;</a></span>ParallelProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_parallel_options.html">ParallelOptions</a> &amp; Blake256::ParallelProfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read/Write: Contains parallel settings and SIMD capability flags in a ParallelOptions structure. </p>
<p>The maximum number of threads allocated when using multi-threaded processing can be set with the ParallelMaxDegree(size_t) function. The ParallelBlockSize() property is auto-calculated, but can be changed; the value must be evenly divisible by the profiles ParallelMinimumSize() property. Note: The ParallelMaxDegree property can not be changed through this interface, use the ParallelMaxDegree(size_t) function to change the thread count and reinitialize the state, or initialize the digest using a BlakeParams with the FanOut property set to the desired number of threads.</p>

<p>Implements <a class="el" href="class_i_digest.html#a580bfcd372709b50b0b4cc708bbd6fb7">IDigest</a>.</p>

</div>
</div>
<a id="a8e33c56e5831a3bbddc9b80eaf6fa646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e33c56e5831a3bbddc9b80eaf6fa646">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Blake256::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the internal state to sequential defaults </p>

<p>Implements <a class="el" href="class_i_digest.html#a473c1fba5959334b7c3bc1d694677aa9">IDigest</a>.</p>

</div>
</div>
<a id="aeae893f1cb552f5906f054b8b02b0003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae893f1cb552f5906f054b8b02b0003">&#9670;&nbsp;</a></span>Update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Blake256::Update </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>Input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the message digest with a single byte </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>Input message byte</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_digest.html#aa6006b697a2b862574ec1a59753c9848">IDigest</a>.</p>

</div>
</div>
<a id="a5428dac06692981c038d1cf787735f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5428dac06692981c038d1cf787735f1b">&#9670;&nbsp;</a></span>Update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Blake256::Update </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; byte &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the message buffer </p>
<p>For best performance in parallel mode, use block sizes that are evenly divisible by ParallelMinimumSize() to reduce caching. Block size for parallel mode should be in a range of minimum 32KiB to 25MiB, larger block sizes reduce the impact of parallel loop creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The Input message data</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the Input array</td></tr>
    <tr><td class="paramname">Length</td><td>The amount of data to process in bytes</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_digest.html#a92d5ea2e435e0f9b939f0aa3079d8af0">IDigest</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/<a class="el" href="_blake256_8h_source.html">Blake256.h</a></li>
<li>C:/Users/John/Documents/GitHub/CEX/CEX/Blake256.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
