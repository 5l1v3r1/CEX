<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>CEX++: IntUtils Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cexlogo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CEX++
   &#160;<span id="projectnumber">1.0.0.5</span>
   </div>
   <div id="projectbrief">The CEX Cryptographic Library in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_int_utils-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IntUtils Class Reference<div class="ingroups"><a class="el" href="group___c_e_x.html">CEX</a> &raquo; <a class="el" href="group___utility.html">Utility</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An integer utility functions class  
 <a href="class_int_utils.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_int_utils_8h_source.html">IntUtils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0cacb7ec2edb5bfdbc076d1b07541f6e"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Dimensions, size_t Length&gt; </td></tr>
<tr class="memitem:a0cacb7ec2edb5bfdbc076d1b07541f6e"><td class="memTemplItemLeft" align="right" valign="top">static CEX_OPTIMIZE_IGNORE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a0cacb7ec2edb5bfdbc076d1b07541f6e">ClearArray</a> (std::array&lt; std::array&lt; T, Length &gt;, Dimensions &gt; &amp;Input)</td></tr>
<tr class="memdesc:a0cacb7ec2edb5bfdbc076d1b07541f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">cond PRIVATE  <a href="#a0cacb7ec2edb5bfdbc076d1b07541f6e">More...</a><br /></td></tr>
<tr class="separator:a0cacb7ec2edb5bfdbc076d1b07541f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a24dc9fcd3e76d30b272b06e34c7f8"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Length&gt; </td></tr>
<tr class="memitem:ad8a24dc9fcd3e76d30b272b06e34c7f8"><td class="memTemplItemLeft" align="right" valign="top">CEX_OPTIMIZE_RESUME static CEX_OPTIMIZE_IGNORE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ad8a24dc9fcd3e76d30b272b06e34c7f8">ClearArray</a> (std::array&lt; T, Length &gt; &amp;Input)</td></tr>
<tr class="memdesc:ad8a24dc9fcd3e76d30b272b06e34c7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">cond PRIVATE  <a href="#ad8a24dc9fcd3e76d30b272b06e34c7f8">More...</a><br /></td></tr>
<tr class="separator:ad8a24dc9fcd3e76d30b272b06e34c7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90595342700f9373c7850852df59f55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af90595342700f9373c7850852df59f55"><td class="memTemplItemLeft" align="right" valign="top">CEX_OPTIMIZE_RESUME static CEX_OPTIMIZE_IGNORE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#af90595342700f9373c7850852df59f55">ClearVector</a> (std::vector&lt; std::vector&lt; T &gt;&gt; &amp;Input)</td></tr>
<tr class="memdesc:af90595342700f9373c7850852df59f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">cond PRIVATE  <a href="#af90595342700f9373c7850852df59f55">More...</a><br /></td></tr>
<tr class="separator:af90595342700f9373c7850852df59f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cac45df47e968e5c3b9ac9a0de092d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5cac45df47e968e5c3b9ac9a0de092d"><td class="memTemplItemLeft" align="right" valign="top">CEX_OPTIMIZE_RESUME static CEX_OPTIMIZE_IGNORE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ad5cac45df47e968e5c3b9ac9a0de092d">ClearVector</a> (std::vector&lt; T &gt; &amp;Input)</td></tr>
<tr class="memdesc:ad5cac45df47e968e5c3b9ac9a0de092d"><td class="mdescLeft">&#160;</td><td class="mdescRight">cond PRIVATE  <a href="#ad5cac45df47e968e5c3b9ac9a0de092d">More...</a><br /></td></tr>
<tr class="separator:ad5cac45df47e968e5c3b9ac9a0de092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7fa4c3fc69fb5b7de319c066807111"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d7fa4c3fc69fb5b7de319c066807111"><td class="memTemplItemLeft" align="right" valign="top">static CEX_OPTIMIZE_RESUME byte&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a8d7fa4c3fc69fb5b7de319c066807111">GetByte</a> (T Value, size_t Index)</td></tr>
<tr class="memdesc:a8d7fa4c3fc69fb5b7de319c066807111"><td class="mdescLeft">&#160;</td><td class="mdescRight">cond PRIVATE  <a href="#a8d7fa4c3fc69fb5b7de319c066807111">More...</a><br /></td></tr>
<tr class="separator:a8d7fa4c3fc69fb5b7de319c066807111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3c13948de6e7ddcbb707b9b3931542"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a3c13948de6e7ddcbb707b9b3931542"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a0a3c13948de6e7ddcbb707b9b3931542">Abs</a> (T A, T B)</td></tr>
<tr class="memdesc:a0a3c13948de6e7ddcbb707b9b3931542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute positive value difference between two integers  <a href="#a0a3c13948de6e7ddcbb707b9b3931542">More...</a><br /></td></tr>
<tr class="separator:a0a3c13948de6e7ddcbb707b9b3931542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd084586562543793fbb03f9c7bd8b4"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#adfd084586562543793fbb03f9c7bd8b4">Crop</a> (ulong Value, size_t Length)</td></tr>
<tr class="memdesc:adfd084586562543793fbb03f9c7bd8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop a 64 bit integer value  <a href="#adfd084586562543793fbb03f9c7bd8b4">More...</a><br /></td></tr>
<tr class="separator:adfd084586562543793fbb03f9c7bd8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c87deec393da93722a080f41740a9d"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a16c87deec393da93722a080f41740a9d">FromString</a> (std::string &amp;Input)</td></tr>
<tr class="memdesc:a16c87deec393da93722a080f41740a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a string to a byte array.  <a href="#a16c87deec393da93722a080f41740a9d">More...</a><br /></td></tr>
<tr class="separator:a16c87deec393da93722a080f41740a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc014d9216b79b2822339f774bb0122"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a4bc014d9216b79b2822339f774bb0122">FromHex</a> (std::string &amp;Input, size_t Length)</td></tr>
<tr class="memdesc:a4bc014d9216b79b2822339f774bb0122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a hex formatted string to an array of bytes  <a href="#a4bc014d9216b79b2822339f774bb0122">More...</a><br /></td></tr>
<tr class="separator:a4bc014d9216b79b2822339f774bb0122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b056253ab5a4f271ce0107d1e19ecca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b056253ab5a4f271ce0107d1e19ecca"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a9b056253ab5a4f271ce0107d1e19ecca">IsPowerOf2</a> (T Value)</td></tr>
<tr class="memdesc:a9b056253ab5a4f271ce0107d1e19ecca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for power of 2  <a href="#a9b056253ab5a4f271ce0107d1e19ecca">More...</a><br /></td></tr>
<tr class="separator:a9b056253ab5a4f271ce0107d1e19ecca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5700f83536c7178f0207764e3a050dc5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a5700f83536c7178f0207764e3a050dc5"><td class="memTemplItemLeft" align="right" valign="top">static T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a5700f83536c7178f0207764e3a050dc5">ModPowerOf2</a> (T1 A, T2 B)</td></tr>
<tr class="memdesc:a5700f83536c7178f0207764e3a050dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mod a power of two integer  <a href="#a5700f83536c7178f0207764e3a050dc5">More...</a><br /></td></tr>
<tr class="separator:a5700f83536c7178f0207764e3a050dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7ae4ac54fdd2d889eb86c47fd8038e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb7ae4ac54fdd2d889eb86c47fd8038e"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#acb7ae4ac54fdd2d889eb86c47fd8038e">Max</a> (T A, T B)</td></tr>
<tr class="memdesc:acb7ae4ac54fdd2d889eb86c47fd8038e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the larger of two values  <a href="#acb7ae4ac54fdd2d889eb86c47fd8038e">More...</a><br /></td></tr>
<tr class="separator:acb7ae4ac54fdd2d889eb86c47fd8038e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b8101566ffe7034cc1921e325e9e90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43b8101566ffe7034cc1921e325e9e90"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a43b8101566ffe7034cc1921e325e9e90">Min</a> (T A, T B)</td></tr>
<tr class="memdesc:a43b8101566ffe7034cc1921e325e9e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smaller of two values  <a href="#a43b8101566ffe7034cc1921e325e9e90">More...</a><br /></td></tr>
<tr class="separator:a43b8101566ffe7034cc1921e325e9e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f45e5ad4db91f56db20b2de10a29df"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#aa6f45e5ad4db91f56db20b2de10a29df">Parity</a> (ulong Value)</td></tr>
<tr class="memdesc:aa6f45e5ad4db91f56db20b2de10a29df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parity bit from a 64 bit integer  <a href="#aa6f45e5ad4db91f56db20b2de10a29df">More...</a><br /></td></tr>
<tr class="separator:aa6f45e5ad4db91f56db20b2de10a29df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad7a8dceacb0dc46b7ef4f120df0303"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ad7a8dceacb0dc46b7ef4f120df0303"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a1ad7a8dceacb0dc46b7ef4f120df0303">ToHex</a> (std::vector&lt; T &gt; &amp;Input, size_t Offset, size_t Length)</td></tr>
<tr class="memdesc:a1ad7a8dceacb0dc46b7ef4f120df0303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an array of T to a hexadecimal string  <a href="#a1ad7a8dceacb0dc46b7ef4f120df0303">More...</a><br /></td></tr>
<tr class="separator:a1ad7a8dceacb0dc46b7ef4f120df0303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa016720aa9e3c578c8ed6dd9ffad57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaaa016720aa9e3c578c8ed6dd9ffad57"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#aaaa016720aa9e3c578c8ed6dd9ffad57">ToHex</a> (T Value)</td></tr>
<tr class="memdesc:aaaa016720aa9e3c578c8ed6dd9ffad57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a value of T to a hexadecimal string  <a href="#aaaa016720aa9e3c578c8ed6dd9ffad57">More...</a><br /></td></tr>
<tr class="separator:aaaa016720aa9e3c578c8ed6dd9ffad57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61581b57a1d6a1a3f253668bd3f3e7db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61581b57a1d6a1a3f253668bd3f3e7db"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a61581b57a1d6a1a3f253668bd3f3e7db">ToString</a> (T Value)</td></tr>
<tr class="memdesc:a61581b57a1d6a1a3f253668bd3f3e7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer to a string  <a href="#a61581b57a1d6a1a3f253668bd3f3e7db">More...</a><br /></td></tr>
<tr class="separator:a61581b57a1d6a1a3f253668bd3f3e7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720cf7af352cb02662a7012b4d9e2a94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a720cf7af352cb02662a7012b4d9e2a94"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a720cf7af352cb02662a7012b4d9e2a94">ToString</a> (std::vector&lt; T &gt; &amp;Input, size_t Offset, size_t Length)</td></tr>
<tr class="memdesc:a720cf7af352cb02662a7012b4d9e2a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an array of T to a string  <a href="#a720cf7af352cb02662a7012b4d9e2a94">More...</a><br /></td></tr>
<tr class="separator:a720cf7af352cb02662a7012b4d9e2a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0285419c5831bd4b0e9d3f6f5a27a456"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a0285419c5831bd4b0e9d3f6f5a27a456">IsBigEndian</a> ()</td></tr>
<tr class="memdesc:a0285419c5831bd4b0e9d3f6f5a27a456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run time check for Little Endian byte order  <a href="#a0285419c5831bd4b0e9d3f6f5a27a456">More...</a><br /></td></tr>
<tr class="separator:a0285419c5831bd4b0e9d3f6f5a27a456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac734794b722e5b631aa403e02f4409d8"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:ac734794b722e5b631aa403e02f4409d8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ac734794b722e5b631aa403e02f4409d8">BlockToBe</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset, size_t Length)</td></tr>
<tr class="memdesc:ac734794b722e5b631aa403e02f4409d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 8bit byte array to a Big Endian integer array  <a href="#ac734794b722e5b631aa403e02f4409d8">More...</a><br /></td></tr>
<tr class="separator:ac734794b722e5b631aa403e02f4409d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab585260f57cd4c4a6073f88261d6459"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:aab585260f57cd4c4a6073f88261d6459"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#aab585260f57cd4c4a6073f88261d6459">BeToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset, size_t Length)</td></tr>
<tr class="memdesc:aab585260f57cd4c4a6073f88261d6459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian integer array to a byte array.  <a href="#aab585260f57cd4c4a6073f88261d6459">More...</a><br /></td></tr>
<tr class="separator:aab585260f57cd4c4a6073f88261d6459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efbf3c8860b307a2c225da8099abaa9"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a8efbf3c8860b307a2c225da8099abaa9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a8efbf3c8860b307a2c225da8099abaa9">Be16ToBytes</a> (const ushort Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a8efbf3c8860b307a2c225da8099abaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 16 bit word to bytes  <a href="#a8efbf3c8860b307a2c225da8099abaa9">More...</a><br /></td></tr>
<tr class="separator:a8efbf3c8860b307a2c225da8099abaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d85ddbaac5d3ec8ff395fd1745d43d"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a56d85ddbaac5d3ec8ff395fd1745d43d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a56d85ddbaac5d3ec8ff395fd1745d43d">Be32ToBytes</a> (const uint Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a56d85ddbaac5d3ec8ff395fd1745d43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 32 bit word to bytes  <a href="#a56d85ddbaac5d3ec8ff395fd1745d43d">More...</a><br /></td></tr>
<tr class="separator:a56d85ddbaac5d3ec8ff395fd1745d43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fba4c9c2ee604e118e2bbfe5759fa2b"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a7fba4c9c2ee604e118e2bbfe5759fa2b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a7fba4c9c2ee604e118e2bbfe5759fa2b">Be64ToBytes</a> (const ulong Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a7fba4c9c2ee604e118e2bbfe5759fa2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 64 bit dword to bytes  <a href="#a7fba4c9c2ee604e118e2bbfe5759fa2b">More...</a><br /></td></tr>
<tr class="separator:a7fba4c9c2ee604e118e2bbfe5759fa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2e1775fc3df0d437f57139226ba4fc"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a9b2e1775fc3df0d437f57139226ba4fc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a9b2e1775fc3df0d437f57139226ba4fc">BeUL256ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a9b2e1775fc3df0d437f57139226ba4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 8 * 32bit word array to a byte array  <a href="#a9b2e1775fc3df0d437f57139226ba4fc">More...</a><br /></td></tr>
<tr class="separator:a9b2e1775fc3df0d437f57139226ba4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfe9774c06a5d048d271e70e50068ea"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a4cfe9774c06a5d048d271e70e50068ea"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a4cfe9774c06a5d048d271e70e50068ea">BeULL512ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a4cfe9774c06a5d048d271e70e50068ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Big Endian 8 * 64bit word array to a byte array  <a href="#a4cfe9774c06a5d048d271e70e50068ea">More...</a><br /></td></tr>
<tr class="separator:a4cfe9774c06a5d048d271e70e50068ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff65fa40b9350c69018c892a9886b07"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a2ff65fa40b9350c69018c892a9886b07"><td class="memTemplItemLeft" align="right" valign="top">static ushort&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a2ff65fa40b9350c69018c892a9886b07">BeBytesTo16</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:a2ff65fa40b9350c69018c892a9886b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte array to a Big Endian 16 bit word  <a href="#a2ff65fa40b9350c69018c892a9886b07">More...</a><br /></td></tr>
<tr class="separator:a2ff65fa40b9350c69018c892a9886b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f031677a5f3659f2a26ed95d933505"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:ac4f031677a5f3659f2a26ed95d933505"><td class="memTemplItemLeft" align="right" valign="top">static uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ac4f031677a5f3659f2a26ed95d933505">BeBytesTo32</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:ac4f031677a5f3659f2a26ed95d933505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte array to a Big Endian 32 bit word  <a href="#ac4f031677a5f3659f2a26ed95d933505">More...</a><br /></td></tr>
<tr class="separator:ac4f031677a5f3659f2a26ed95d933505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b68be18c7b1f970bf5d4159328a713"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:ad2b68be18c7b1f970bf5d4159328a713"><td class="memTemplItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ad2b68be18c7b1f970bf5d4159328a713">BeBytesTo64</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:ad2b68be18c7b1f970bf5d4159328a713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte array to a Big Endian 64 bit dword  <a href="#ad2b68be18c7b1f970bf5d4159328a713">More...</a><br /></td></tr>
<tr class="separator:ad2b68be18c7b1f970bf5d4159328a713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d362099f18b2f0391703ba78fe6e0c"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a93d362099f18b2f0391703ba78fe6e0c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a93d362099f18b2f0391703ba78fe6e0c">BeIncrement8</a> (Array &amp;Output)</td></tr>
<tr class="memdesc:a93d362099f18b2f0391703ba78fe6e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats a byte array as a large Big Endian integer, incrementing the total value by one  <a href="#a93d362099f18b2f0391703ba78fe6e0c">More...</a><br /></td></tr>
<tr class="separator:a93d362099f18b2f0391703ba78fe6e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d414fee0f98d10647f1af2cec0581ea"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a2d414fee0f98d10647f1af2cec0581ea"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a2d414fee0f98d10647f1af2cec0581ea">BeIncrease8</a> (const Array &amp;Input, Array &amp;Output, const size_t Length)</td></tr>
<tr class="memdesc:a2d414fee0f98d10647f1af2cec0581ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats an 8bit integer array as a large Big Endian integer, incrementing the total value by the specified length  <a href="#a2d414fee0f98d10647f1af2cec0581ea">More...</a><br /></td></tr>
<tr class="separator:a2d414fee0f98d10647f1af2cec0581ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e46efe94f45588ba9c80a31885a67f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#aa7e46efe94f45588ba9c80a31885a67f">IsLittleEndian</a> ()</td></tr>
<tr class="memdesc:aa7e46efe94f45588ba9c80a31885a67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run time check for Little Endian byte order  <a href="#aa7e46efe94f45588ba9c80a31885a67f">More...</a><br /></td></tr>
<tr class="separator:aa7e46efe94f45588ba9c80a31885a67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76037504836ea5bf29014d53ea70607f"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a76037504836ea5bf29014d53ea70607f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a76037504836ea5bf29014d53ea70607f">BlockToLe</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset, size_t Length)</td></tr>
<tr class="memdesc:a76037504836ea5bf29014d53ea70607f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian N * 8bit word array to an unsigned integer array.  <a href="#a76037504836ea5bf29014d53ea70607f">More...</a><br /></td></tr>
<tr class="separator:a76037504836ea5bf29014d53ea70607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c2728bd777a0b3ba30e6ac6d80ce2e"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a29c2728bd777a0b3ba30e6ac6d80ce2e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a29c2728bd777a0b3ba30e6ac6d80ce2e">LeToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset, size_t Length)</td></tr>
<tr class="memdesc:a29c2728bd777a0b3ba30e6ac6d80ce2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian unsigned integer array to a byte array.  <a href="#a29c2728bd777a0b3ba30e6ac6d80ce2e">More...</a><br /></td></tr>
<tr class="separator:a29c2728bd777a0b3ba30e6ac6d80ce2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6806f85d606a97b9670ec5fda0b6c157"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a6806f85d606a97b9670ec5fda0b6c157"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a6806f85d606a97b9670ec5fda0b6c157">Le16ToBytes</a> (const ushort Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a6806f85d606a97b9670ec5fda0b6c157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 16 bit word to bytes  <a href="#a6806f85d606a97b9670ec5fda0b6c157">More...</a><br /></td></tr>
<tr class="separator:a6806f85d606a97b9670ec5fda0b6c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc1dba1dfd43616b59dcef1fd1692dd"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:aefc1dba1dfd43616b59dcef1fd1692dd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#aefc1dba1dfd43616b59dcef1fd1692dd">Le32ToBytes</a> (const uint Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:aefc1dba1dfd43616b59dcef1fd1692dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 32 bit word to bytes  <a href="#aefc1dba1dfd43616b59dcef1fd1692dd">More...</a><br /></td></tr>
<tr class="separator:aefc1dba1dfd43616b59dcef1fd1692dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d096a3f5618b96c141df530480d5893"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a9d096a3f5618b96c141df530480d5893"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a9d096a3f5618b96c141df530480d5893">Le64ToBytes</a> (const ulong Value, Array &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a9d096a3f5618b96c141df530480d5893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 64 bit dword to bytes  <a href="#a9d096a3f5618b96c141df530480d5893">More...</a><br /></td></tr>
<tr class="separator:a9d096a3f5618b96c141df530480d5893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f9e998ce1bb3e8fcfb8a74b351f5a4"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:ae3f9e998ce1bb3e8fcfb8a74b351f5a4"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ae3f9e998ce1bb3e8fcfb8a74b351f5a4">LeUL256ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:ae3f9e998ce1bb3e8fcfb8a74b351f5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 8 * 32bit word array to a byte array  <a href="#ae3f9e998ce1bb3e8fcfb8a74b351f5a4">More...</a><br /></td></tr>
<tr class="separator:ae3f9e998ce1bb3e8fcfb8a74b351f5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c1dca1ad6e62cc959d57eee75be09e"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a61c1dca1ad6e62cc959d57eee75be09e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a61c1dca1ad6e62cc959d57eee75be09e">LeULL256ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a61c1dca1ad6e62cc959d57eee75be09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 4 * 64bit word array to a byte array  <a href="#a61c1dca1ad6e62cc959d57eee75be09e">More...</a><br /></td></tr>
<tr class="separator:a61c1dca1ad6e62cc959d57eee75be09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1853dbc2cbbc44ff340e378f2a647c97"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a1853dbc2cbbc44ff340e378f2a647c97"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a1853dbc2cbbc44ff340e378f2a647c97">LeULL512ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a1853dbc2cbbc44ff340e378f2a647c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 8 * 64bit word array to a byte array  <a href="#a1853dbc2cbbc44ff340e378f2a647c97">More...</a><br /></td></tr>
<tr class="separator:a1853dbc2cbbc44ff340e378f2a647c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b44e6fca74952587712645635c0299"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:ae4b44e6fca74952587712645635c0299"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ae4b44e6fca74952587712645635c0299">LeULL1024ToBlock</a> (ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:ae4b44e6fca74952587712645635c0299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Little Endian 16 * 64bit word array to a byte array  <a href="#ae4b44e6fca74952587712645635c0299">More...</a><br /></td></tr>
<tr class="separator:ae4b44e6fca74952587712645635c0299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99026f794bd6a9559c2d056a106e6eb8"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a99026f794bd6a9559c2d056a106e6eb8"><td class="memTemplItemLeft" align="right" valign="top">static ushort&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a99026f794bd6a9559c2d056a106e6eb8">LeBytesTo16</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:a99026f794bd6a9559c2d056a106e6eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte array to a Little Endian 16 bit word  <a href="#a99026f794bd6a9559c2d056a106e6eb8">More...</a><br /></td></tr>
<tr class="separator:a99026f794bd6a9559c2d056a106e6eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dfb460fc94a3416922b61fc286464d"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a52dfb460fc94a3416922b61fc286464d"><td class="memTemplItemLeft" align="right" valign="top">static uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a52dfb460fc94a3416922b61fc286464d">LeBytesTo32</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:a52dfb460fc94a3416922b61fc286464d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte array to a Little Endian 32 bit word  <a href="#a52dfb460fc94a3416922b61fc286464d">More...</a><br /></td></tr>
<tr class="separator:a52dfb460fc94a3416922b61fc286464d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5e7cee7c87145a89935238bc766c67"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a6d5e7cee7c87145a89935238bc766c67"><td class="memTemplItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a6d5e7cee7c87145a89935238bc766c67">LeBytesTo64</a> (const Array &amp;Input, size_t InOffset)</td></tr>
<tr class="memdesc:a6d5e7cee7c87145a89935238bc766c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte array to a Little Endian 64 bit dword  <a href="#a6d5e7cee7c87145a89935238bc766c67">More...</a><br /></td></tr>
<tr class="separator:a6d5e7cee7c87145a89935238bc766c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878bc95e59f46c13ddbfdf99404d11e5"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a878bc95e59f46c13ddbfdf99404d11e5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a878bc95e59f46c13ddbfdf99404d11e5">LeBytesToUL512</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a878bc95e59f46c13ddbfdf99404d11e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte array to a Little Endian 16 * 32bit word array  <a href="#a878bc95e59f46c13ddbfdf99404d11e5">More...</a><br /></td></tr>
<tr class="separator:a878bc95e59f46c13ddbfdf99404d11e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ef4bdb5a4dda1e710ef98b1aba4699"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:af5ef4bdb5a4dda1e710ef98b1aba4699"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#af5ef4bdb5a4dda1e710ef98b1aba4699">LeBytesToULL256</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:af5ef4bdb5a4dda1e710ef98b1aba4699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte array to a Little Endian 4 * 64bit word array  <a href="#af5ef4bdb5a4dda1e710ef98b1aba4699">More...</a><br /></td></tr>
<tr class="separator:af5ef4bdb5a4dda1e710ef98b1aba4699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00892f53a7523f929c74a946556c269"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:af00892f53a7523f929c74a946556c269"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#af00892f53a7523f929c74a946556c269">LeBytesToULL512</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:af00892f53a7523f929c74a946556c269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte array to a Little Endian 8 * 64bit word array  <a href="#af00892f53a7523f929c74a946556c269">More...</a><br /></td></tr>
<tr class="separator:af00892f53a7523f929c74a946556c269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2952772f7cff9a01a3eb7b24b06cd9"><td class="memTemplParams" colspan="2">template&lt;typename ArrayA , typename ArrayB &gt; </td></tr>
<tr class="memitem:a6b2952772f7cff9a01a3eb7b24b06cd9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a6b2952772f7cff9a01a3eb7b24b06cd9">LeBytesToULL1024</a> (const ArrayA &amp;Input, size_t InOffset, ArrayB &amp;Output, size_t OutOffset)</td></tr>
<tr class="memdesc:a6b2952772f7cff9a01a3eb7b24b06cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a byte array to a Little Endian 16 * 64bit word array  <a href="#a6b2952772f7cff9a01a3eb7b24b06cd9">More...</a><br /></td></tr>
<tr class="separator:a6b2952772f7cff9a01a3eb7b24b06cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb625302dafeecb21eb755fdc26a6586"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:afb625302dafeecb21eb755fdc26a6586"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#afb625302dafeecb21eb755fdc26a6586">LeIncrement</a> (Array &amp;Output)</td></tr>
<tr class="memdesc:afb625302dafeecb21eb755fdc26a6586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats an array as a large Little Endian integer, incrementing the total value by one  <a href="#afb625302dafeecb21eb755fdc26a6586">More...</a><br /></td></tr>
<tr class="separator:afb625302dafeecb21eb755fdc26a6586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ba4e45c551ccb4888720725cc1b77f"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a63ba4e45c551ccb4888720725cc1b77f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a63ba4e45c551ccb4888720725cc1b77f">LeIncrementW</a> (Array &amp;Output)</td></tr>
<tr class="memdesc:a63ba4e45c551ccb4888720725cc1b77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats an integer array as a large Little Endian integer, incrementing the total value by one.  <a href="#a63ba4e45c551ccb4888720725cc1b77f">More...</a><br /></td></tr>
<tr class="separator:a63ba4e45c551ccb4888720725cc1b77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695fa6e4ab1e3fa0adc5cb7729fc72cc"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a695fa6e4ab1e3fa0adc5cb7729fc72cc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a695fa6e4ab1e3fa0adc5cb7729fc72cc">LeIncreaseW</a> (const Array &amp;Input, Array &amp;Output, const size_t Length)</td></tr>
<tr class="memdesc:a695fa6e4ab1e3fa0adc5cb7729fc72cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats an integer array as a large Little Endian integer, incrementing the total value by a defined length.  <a href="#a695fa6e4ab1e3fa0adc5cb7729fc72cc">More...</a><br /></td></tr>
<tr class="separator:a695fa6e4ab1e3fa0adc5cb7729fc72cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec2f28b06ce0b953dc497c6503c6587"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ec2f28b06ce0b953dc497c6503c6587"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a9ec2f28b06ce0b953dc497c6503c6587">CMax</a> (T A, T B)</td></tr>
<tr class="memdesc:a9ec2f28b06ce0b953dc497c6503c6587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time return the larger value of the two integers  <a href="#a9ec2f28b06ce0b953dc497c6503c6587">More...</a><br /></td></tr>
<tr class="separator:a9ec2f28b06ce0b953dc497c6503c6587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ea95f7d40cb0bb16d089ae570c7261"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1ea95f7d40cb0bb16d089ae570c7261"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ab1ea95f7d40cb0bb16d089ae570c7261">CMin</a> (T A, T B)</td></tr>
<tr class="memdesc:ab1ea95f7d40cb0bb16d089ae570c7261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time return the lesser value of the two integers  <a href="#ab1ea95f7d40cb0bb16d089ae570c7261">More...</a><br /></td></tr>
<tr class="separator:ab1ea95f7d40cb0bb16d089ae570c7261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd597db68ebafaf1ff7692a83a5ae5b"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:acdd597db68ebafaf1ff7692a83a5ae5b"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#acdd597db68ebafaf1ff7692a83a5ae5b">Compare</a> (const Array &amp;A, size_t AOffset, const Array &amp;B, size_t BOffset, size_t Length)</td></tr>
<tr class="memdesc:acdd597db68ebafaf1ff7692a83a5ae5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time comparison of two arrays segments with offset and length parameters  <a href="#acdd597db68ebafaf1ff7692a83a5ae5b">More...</a><br /></td></tr>
<tr class="separator:acdd597db68ebafaf1ff7692a83a5ae5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4bcdddade33d571467f06c6df92c79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e4bcdddade33d571467f06c6df92c79"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a9e4bcdddade33d571467f06c6df92c79">ConditionalCopy</a> (T Value, T *To, const T *From0, const T *From1, size_t Length)</td></tr>
<tr class="memdesc:a9e4bcdddade33d571467f06c6df92c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time conditional bit copy  <a href="#a9e4bcdddade33d571467f06c6df92c79">More...</a><br /></td></tr>
<tr class="separator:a9e4bcdddade33d571467f06c6df92c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e0bfe5b161d615d816cfaf2ec3921f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34e0bfe5b161d615d816cfaf2ec3921f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a34e0bfe5b161d615d816cfaf2ec3921f">ConditionalZeroMem</a> (T Condition, T *Array, size_t Length)</td></tr>
<tr class="memdesc:a34e0bfe5b161d615d816cfaf2ec3921f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time conditional bit erase  <a href="#a34e0bfe5b161d615d816cfaf2ec3921f">More...</a><br /></td></tr>
<tr class="separator:a34e0bfe5b161d615d816cfaf2ec3921f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf830361cde84d831ac16cae5effa7a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf830361cde84d831ac16cae5effa7a1"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#aaf830361cde84d831ac16cae5effa7a1">ExpandMask</a> (T X)</td></tr>
<tr class="memdesc:aaf830361cde84d831ac16cae5effa7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand an integer mask in constant time  <a href="#aaf830361cde84d831ac16cae5effa7a1">More...</a><br /></td></tr>
<tr class="separator:aaf830361cde84d831ac16cae5effa7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceca640e3b86508d4638f4889c04a634"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aceca640e3b86508d4638f4889c04a634"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#aceca640e3b86508d4638f4889c04a634">ExpandTopBit</a> (T A)</td></tr>
<tr class="memdesc:aceca640e3b86508d4638f4889c04a634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time last bit expansion  <a href="#aceca640e3b86508d4638f4889c04a634">More...</a><br /></td></tr>
<tr class="separator:aceca640e3b86508d4638f4889c04a634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e73b7b794f4787afce74a030727529c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e73b7b794f4787afce74a030727529c"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a4e73b7b794f4787afce74a030727529c">IsEqual</a> (T X, T Y)</td></tr>
<tr class="memdesc:a4e73b7b794f4787afce74a030727529c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time comparison of two integers for equality  <a href="#a4e73b7b794f4787afce74a030727529c">More...</a><br /></td></tr>
<tr class="separator:a4e73b7b794f4787afce74a030727529c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9295570fd5e4cde1126fb8f51faa0937"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9295570fd5e4cde1126fb8f51faa0937"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a9295570fd5e4cde1126fb8f51faa0937">IsLess</a> (T X, T Y)</td></tr>
<tr class="memdesc:a9295570fd5e4cde1126fb8f51faa0937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time test if X is less than Y  <a href="#a9295570fd5e4cde1126fb8f51faa0937">More...</a><br /></td></tr>
<tr class="separator:a9295570fd5e4cde1126fb8f51faa0937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea63c04a4aa83ea792ba74bb36e93da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adea63c04a4aa83ea792ba74bb36e93da"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#adea63c04a4aa83ea792ba74bb36e93da">IsLte</a> (T X, T Y)</td></tr>
<tr class="memdesc:adea63c04a4aa83ea792ba74bb36e93da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time test if X less or equal to Y  <a href="#adea63c04a4aa83ea792ba74bb36e93da">More...</a><br /></td></tr>
<tr class="separator:adea63c04a4aa83ea792ba74bb36e93da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509d204e871ce64f22793c0a023fc49a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a509d204e871ce64f22793c0a023fc49a"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a509d204e871ce64f22793c0a023fc49a">IsZero</a> (T X)</td></tr>
<tr class="memdesc:a509d204e871ce64f22793c0a023fc49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant time zero value check  <a href="#a509d204e871ce64f22793c0a023fc49a">More...</a><br /></td></tr>
<tr class="separator:a509d204e871ce64f22793c0a023fc49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fbe6d44b781d06cd1180fa8400dbd5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9fbe6d44b781d06cd1180fa8400dbd5"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ab9fbe6d44b781d06cd1180fa8400dbd5">Select</a> (T Mask, T A, T B)</td></tr>
<tr class="memdesc:ab9fbe6d44b781d06cd1180fa8400dbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the bits from two integers filtered by a mask value  <a href="#ab9fbe6d44b781d06cd1180fa8400dbd5">More...</a><br /></td></tr>
<tr class="separator:ab9fbe6d44b781d06cd1180fa8400dbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1829d129f2eb9d220eccfa7d9452944e"><td class="memTemplParams" colspan="2">template&lt;typename Array &gt; </td></tr>
<tr class="memitem:a1829d129f2eb9d220eccfa7d9452944e"><td class="memTemplItemLeft" align="right" valign="top">static uint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a1829d129f2eb9d220eccfa7d9452944e">ShiftLeft</a> (const Array &amp;Input, Array &amp;Output)</td></tr>
<tr class="memdesc:a1829d129f2eb9d220eccfa7d9452944e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shift an array of integers (OCB mode)  <a href="#a1829d129f2eb9d220eccfa7d9452944e">More...</a><br /></td></tr>
<tr class="separator:a1829d129f2eb9d220eccfa7d9452944e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8f7bc9e74e5f2ca3f971e71f5cfc2e"><td class="memTemplParams" colspan="2">template&lt;typename P , typename V &gt; </td></tr>
<tr class="memitem:aca8f7bc9e74e5f2ca3f971e71f5cfc2e"><td class="memTemplItemLeft" align="right" valign="top">static V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_int_utils.html#aca8f7bc9e74e5f2ca3f971e71f5cfc2e">ValueOrZero</a> (P Pred, V Value)</td></tr>
<tr class="memdesc:aca8f7bc9e74e5f2ca3f971e71f5cfc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an integer based on a mask  <a href="#aca8f7bc9e74e5f2ca3f971e71f5cfc2e">More...</a><br /></td></tr>
<tr class="separator:aca8f7bc9e74e5f2ca3f971e71f5cfc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa464bad4c6d20e0430850d66dd2a58c6"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#aa464bad4c6d20e0430850d66dd2a58c6">RotFL32</a> (uint Value, uint Shift)</td></tr>
<tr class="memdesc:aa464bad4c6d20e0430850d66dd2a58c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 32 bit integer to the left by a positive fixed non-zero increment  <a href="#aa464bad4c6d20e0430850d66dd2a58c6">More...</a><br /></td></tr>
<tr class="separator:aa464bad4c6d20e0430850d66dd2a58c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee72a2be5ee57fcb95b4f82b6c9de8b5"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#aee72a2be5ee57fcb95b4f82b6c9de8b5">RotFL64</a> (ulong Value, uint Shift)</td></tr>
<tr class="memdesc:aee72a2be5ee57fcb95b4f82b6c9de8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 64 bit integer to the left by a positive fixed non-zero increment  <a href="#aee72a2be5ee57fcb95b4f82b6c9de8b5">More...</a><br /></td></tr>
<tr class="separator:aee72a2be5ee57fcb95b4f82b6c9de8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade712c2f935ef581588089329529820c"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ade712c2f935ef581588089329529820c">RotFR32</a> (uint Value, uint Shift)</td></tr>
<tr class="memdesc:ade712c2f935ef581588089329529820c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 32 bit integer to the right by a positive fixed non-zero increment  <a href="#ade712c2f935ef581588089329529820c">More...</a><br /></td></tr>
<tr class="separator:ade712c2f935ef581588089329529820c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c56dad1580b37b025bda0491279cdb2"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a0c56dad1580b37b025bda0491279cdb2">RotFR64</a> (ulong Value, uint Shift)</td></tr>
<tr class="memdesc:a0c56dad1580b37b025bda0491279cdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 64 bit integer to the right by a positive fixed non-zero increment  <a href="#a0c56dad1580b37b025bda0491279cdb2">More...</a><br /></td></tr>
<tr class="separator:a0c56dad1580b37b025bda0491279cdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d1abcaa6c06409d2ff1cb3dd0b7eb3"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#ad5d1abcaa6c06409d2ff1cb3dd0b7eb3">RotL32</a> (uint Value, uint Shift)</td></tr>
<tr class="memdesc:ad5d1abcaa6c06409d2ff1cb3dd0b7eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 32 bit integer to the left  <a href="#ad5d1abcaa6c06409d2ff1cb3dd0b7eb3">More...</a><br /></td></tr>
<tr class="separator:ad5d1abcaa6c06409d2ff1cb3dd0b7eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f63b6981d59ccc5f1d04ca00e45fc2"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a13f63b6981d59ccc5f1d04ca00e45fc2">RotL64</a> (ulong Value, uint Shift)</td></tr>
<tr class="memdesc:a13f63b6981d59ccc5f1d04ca00e45fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 64 bit integer to the left  <a href="#a13f63b6981d59ccc5f1d04ca00e45fc2">More...</a><br /></td></tr>
<tr class="separator:a13f63b6981d59ccc5f1d04ca00e45fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfc41763b5b767307f30f993986049a"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a3cfc41763b5b767307f30f993986049a">RotR32</a> (uint Value, uint Shift)</td></tr>
<tr class="memdesc:a3cfc41763b5b767307f30f993986049a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift a 32 bit integer to the right  <a href="#a3cfc41763b5b767307f30f993986049a">More...</a><br /></td></tr>
<tr class="separator:a3cfc41763b5b767307f30f993986049a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6624645c60136f9396c7cb978e5baf1a"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_int_utils.html#a6624645c60136f9396c7cb978e5baf1a">RotR64</a> (ulong Value, uint Shift)</td></tr>
<tr class="memdesc:a6624645c60136f9396c7cb978e5baf1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate shift an unsigned 64 bit integer to the right  <a href="#a6624645c60136f9396c7cb978e5baf1a">More...</a><br /></td></tr>
<tr class="separator:a6624645c60136f9396c7cb978e5baf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An integer utility functions class </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0a3c13948de6e7ddcbb707b9b3931542"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::Abs </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the absolute positive value difference between two integers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first integer for comparison</td></tr>
    <tr><td class="paramname">B</td><td>The second integer for comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference between integers</dd></dl>

</div>
</div>
<a class="anchor" id="a8efbf3c8860b307a2c225da8099abaa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::Be16ToBytes </td>
          <td>(</td>
          <td class="paramtype">const ushort&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 16 bit word to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 16 bit integer</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56d85ddbaac5d3ec8ff395fd1745d43d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::Be32ToBytes </td>
          <td>(</td>
          <td class="paramtype">const uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 32 bit word to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 32 bit integer</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fba4c9c2ee604e118e2bbfe5759fa2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::Be64ToBytes </td>
          <td>(</td>
          <td class="paramtype">const ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 64 bit dword to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 64 bit word</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ff65fa40b9350c69018c892a9886b07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ushort IntUtils::BeBytesTo16 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte array to a Big Endian 16 bit word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16 bit integer in Big Endian format</dd></dl>

</div>
</div>
<a class="anchor" id="ac4f031677a5f3659f2a26ed95d933505"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntUtils::BeBytesTo32 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte array to a Big Endian 32 bit word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit integer in Big Endian format</dd></dl>

</div>
</div>
<a class="anchor" id="ad2b68be18c7b1f970bf5d4159328a713"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntUtils::BeBytesTo64 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte array to a Big Endian 64 bit dword </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64 bit integer in Big Endian format</dd></dl>

</div>
</div>
<a class="anchor" id="a2d414fee0f98d10647f1af2cec0581ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::BeIncrease8 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats an 8bit integer array as a large Big Endian integer, incrementing the total value by the specified length </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The initial array of bytes</td></tr>
    <tr><td class="paramname">Output</td><td>The modified output byte array</td></tr>
    <tr><td class="paramname">Length</td><td>The number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93d362099f18b2f0391703ba78fe6e0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::BeIncrement8 </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats a byte array as a large Big Endian integer, incrementing the total value by one </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The counter byte array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab585260f57cd4c4a6073f88261d6459"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::BeToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian integer array to a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The integer input array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b2e1775fc3df0d437f57139226ba4fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::BeUL256ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 8 * 32bit word array to a byte array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 32bit integer source array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cfe9774c06a5d048d271e70e50068ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::BeULL512ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Big Endian 8 * 64bit word array to a byte array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 64bit integer source array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac734794b722e5b631aa403e02f4409d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::BlockToBe </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert 8bit byte array to a Big Endian integer array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination integer array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76037504836ea5bf29014d53ea70607f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::BlockToLe </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian N * 8bit word array to an unsigned integer array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination integer array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to process</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cacb7ec2edb5bfdbc076d1b07541f6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Dimensions, size_t Length&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CEX_OPTIMIZE_IGNORE void IntUtils::ClearArray </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, Length &gt;, Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cond PRIVATE </p>
<p>endcond </p>
<p>Clear nested arrays of objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>A nested vector integer array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8a24dc9fcd3e76d30b272b06e34c7f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Length&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CEX_OPTIMIZE_RESUME static CEX_OPTIMIZE_IGNORE void IntUtils::ClearArray </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, Length &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cond PRIVATE </p>
<p>endcond cond PRIVATE endcond </p>
<p>Clear an array of objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>A byte vector array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af90595342700f9373c7850852df59f55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CEX_OPTIMIZE_RESUME static CEX_OPTIMIZE_IGNORE void IntUtils::ClearVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cond PRIVATE </p>
<p>endcond cond PRIVATE endcond </p>
<p>Clear nested vectors of objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>A nested vector integer array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5cac45df47e968e5c3b9ac9a0de092d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CEX_OPTIMIZE_RESUME static CEX_OPTIMIZE_IGNORE void IntUtils::ClearVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cond PRIVATE </p>
<p>endcond cond PRIVATE endcond </p>
<p>Clear a vector of objects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>A byte vector array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ec2f28b06ce0b953dc497c6503c6587"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::CMax </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time return the larger value of the two integers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first value to compare</td></tr>
    <tr><td class="paramname">B</td><td>The second value to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The larger value</dd></dl>

</div>
</div>
<a class="anchor" id="ab1ea95f7d40cb0bb16d089ae570c7261"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::CMin </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time return the lesser value of the two integers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first value to compare</td></tr>
    <tr><td class="paramname">B</td><td>The second value to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lesser value</dd></dl>

</div>
</div>
<a class="anchor" id="acdd597db68ebafaf1ff7692a83a5ae5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IntUtils::Compare </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>AOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>BOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time comparison of two arrays segments with offset and length parameters </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first array to compare</td></tr>
    <tr><td class="paramname">AOffset</td><td>The starting offset within the 'A' array</td></tr>
    <tr><td class="paramname">B</td><td>The second array to compare</td></tr>
    <tr><td class="paramname">BOffset</td><td>The starting offset within the 'B' array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of elements to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if arrays are equivalant</dd></dl>

</div>
</div>
<a class="anchor" id="a9e4bcdddade33d571467f06c6df92c79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::ConditionalCopy </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>To</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>From0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>From1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time conditional bit copy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The destination mask</td></tr>
    <tr><td class="paramname">To</td><td>The destination array</td></tr>
    <tr><td class="paramname">From0</td><td>The first value to copy</td></tr>
    <tr><td class="paramname">From1</td><td>The second value to copy</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bits to copy</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34e0bfe5b161d615d816cfaf2ec3921f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::ConditionalZeroMem </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time conditional bit erase </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Condition</td><td>The condition</td></tr>
    <tr><td class="paramname">Array</td><td>The array to wipe</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bits to copy</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfd084586562543793fbb03f9c7bd8b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntUtils::Crop </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crop a 64 bit integer value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bits in the new integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cropped integer</dd></dl>

</div>
</div>
<a class="anchor" id="aaf830361cde84d831ac16cae5effa7a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::ExpandMask </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand an integer mask in constant time </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The N bit word</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A N bit expanded word</dd></dl>

</div>
</div>
<a class="anchor" id="aceca640e3b86508d4638f4889c04a634"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::ExpandTopBit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time last bit expansion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The value to expand</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A expanded N bit integer</dd></dl>

</div>
</div>
<a class="anchor" id="a4bc014d9216b79b2822339f774bb0122"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;byte&gt; IntUtils::FromHex </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a hex formatted string to an array of bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The string to convert</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hex string copied to an array of bytes</dd></dl>

</div>
</div>
<a class="anchor" id="a16c87deec393da93722a080f41740a9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;byte&gt; IntUtils::FromString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>Input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a string to a byte array. </p>
<p>The output from this function is endian dependant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The string to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string copied to a byte array</dd></dl>

</div>
</div>
<a class="anchor" id="a8d7fa4c3fc69fb5b7de319c066807111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CEX_OPTIMIZE_RESUME byte IntUtils::GetByte </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cond PRIVATE </p>
<p>endcond </p>
<p>Extract an 8bit integer from a larger integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The parent integer value to extract from</td></tr>
    <tr><td class="paramname">Index</td><td>The byte position within the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted byte</dd></dl>

</div>
</div>
<a class="anchor" id="a0285419c5831bd4b0e9d3f6f5a27a456"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IntUtils::IsBigEndian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run time check for Little Endian byte order </p>

</div>
</div>
<a class="anchor" id="a4e73b7b794f4787afce74a030727529c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::IsEqual </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time comparison of two integers for equality </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The first value to test</td></tr>
    <tr><td class="paramname">Y</td><td>The second value to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer if equal</dd></dl>

</div>
</div>
<a class="anchor" id="a9295570fd5e4cde1126fb8f51faa0937"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::IsLess </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time test if X is less than Y </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The first value to test</td></tr>
    <tr><td class="paramname">Y</td><td>The second value to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer if less</dd></dl>

</div>
</div>
<a class="anchor" id="aa7e46efe94f45588ba9c80a31885a67f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IntUtils::IsLittleEndian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run time check for Little Endian byte order </p>

</div>
</div>
<a class="anchor" id="adea63c04a4aa83ea792ba74bb36e93da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::IsLte </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time test if X less or equal to Y </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The first value to test</td></tr>
    <tr><td class="paramname">Y</td><td>The second value to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer if less</dd></dl>

</div>
</div>
<a class="anchor" id="a9b056253ab5a4f271ce0107d1e19ecca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IntUtils::IsPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for power of 2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value is a power of 2</dd></dl>

</div>
</div>
<a class="anchor" id="a509d204e871ce64f22793c0a023fc49a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::IsZero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant time zero value check </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The value to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer if non-zero</dd></dl>

</div>
</div>
<a class="anchor" id="a6806f85d606a97b9670ec5fda0b6c157"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::Le16ToBytes </td>
          <td>(</td>
          <td class="paramtype">const ushort&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 16 bit word to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 16bit integer</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefc1dba1dfd43616b59dcef1fd1692dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::Le32ToBytes </td>
          <td>(</td>
          <td class="paramtype">const uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 32 bit word to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 32 bit integer</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d096a3f5618b96c141df530480d5893"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::Le64ToBytes </td>
          <td>(</td>
          <td class="paramtype">const ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 64 bit dword to bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The 64 bit integer</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99026f794bd6a9559c2d056a106e6eb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ushort IntUtils::LeBytesTo16 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte array to a Little Endian 16 bit word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16 bit integer in Little Endian format</dd></dl>

</div>
</div>
<a class="anchor" id="a52dfb460fc94a3416922b61fc286464d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntUtils::LeBytesTo32 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte array to a Little Endian 32 bit word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit word in Little Endian format</dd></dl>

</div>
</div>
<a class="anchor" id="a6d5e7cee7c87145a89935238bc766c67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntUtils::LeBytesTo64 </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte array to a Little Endian 64 bit dword </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64 bit word in Little Endian format</dd></dl>

</div>
</div>
<a class="anchor" id="a878bc95e59f46c13ddbfdf99404d11e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeBytesToUL512 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte array to a Little Endian 16 * 32bit word array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination 32bit integer array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b2952772f7cff9a01a3eb7b24b06cd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeBytesToULL1024 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte array to a Little Endian 16 * 64bit word array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination 64bit integer array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5ef4bdb5a4dda1e710ef98b1aba4699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeBytesToULL256 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte array to a Little Endian 4 * 64bit word array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination 64bit integer array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af00892f53a7523f929c74a946556c269"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeBytesToULL512 </td>
          <td>(</td>
          <td class="paramtype">const ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a byte array to a Little Endian 8 * 64bit word array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source byte array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination 64bit integer array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the output array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a695fa6e4ab1e3fa0adc5cb7729fc72cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeIncreaseW </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats an integer array as a large Little Endian integer, incrementing the total value by a defined length. </p>
<p>Uses only unsigned integer types; signed types are UB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The initial array of bytes</td></tr>
    <tr><td class="paramname">Output</td><td>The modified output array</td></tr>
    <tr><td class="paramname">Length</td><td>The number to increase by</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb625302dafeecb21eb755fdc26a6586"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeIncrement </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats an array as a large Little Endian integer, incrementing the total value by one </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The counter array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63ba4e45c551ccb4888720725cc1b77f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeIncrementW </td>
          <td>(</td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats an integer array as a large Little Endian integer, incrementing the total value by one. </p>
<p>Uses only the first two elements of the Output array; used by 32 or 64 bit integer types. Uses only unsigned integer types; signed types are UB.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Output</td><td>The counter array to increment</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29c2728bd777a0b3ba30e6ac6d80ce2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian unsigned integer array to a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The source integer array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
    <tr><td class="paramname">Length</td><td>The number of bytes to convert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3f9e998ce1bb3e8fcfb8a74b351f5a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeUL256ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 8 * 32bit word array to a byte array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 32bit integer array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4b44e6fca74952587712645635c0299"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeULL1024ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 16 * 64bit word array to a byte array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 64bit integer array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61c1dca1ad6e62cc959d57eee75be09e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeULL256ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 4 * 64bit word array to a byte array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 64bit integer array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1853dbc2cbbc44ff340e378f2a647c97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayA , typename ArrayB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IntUtils::LeULL512ToBlock </td>
          <td>(</td>
          <td class="paramtype">ArrayA &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>InOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayB &amp;&#160;</td>
          <td class="paramname"><em>Output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>OutOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Little Endian 8 * 64bit word array to a byte array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The 64bit integer array</td></tr>
    <tr><td class="paramname">InOffset</td><td>The starting offset within the source array</td></tr>
    <tr><td class="paramname">Output</td><td>The destination byte array</td></tr>
    <tr><td class="paramname">OutOffset</td><td>The starting offset within the destination array</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb7ae4ac54fdd2d889eb86c47fd8038e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::Max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the larger of two values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first comparison value</td></tr>
    <tr><td class="paramname">B</td><td>The second comparison value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The larger value</dd></dl>

</div>
</div>
<a class="anchor" id="a43b8101566ffe7034cc1921e325e9e90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::Min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smaller of two values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The first comparison value</td></tr>
    <tr><td class="paramname">B</td><td>The second comparison value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smaller value</dd></dl>

</div>
</div>
<a class="anchor" id="a5700f83536c7178f0207764e3a050dc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T2 IntUtils::ModPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mod a power of two integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The initial value</td></tr>
    <tr><td class="paramname">B</td><td>The modulus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value</dd></dl>

</div>
</div>
<a class="anchor" id="aa6f45e5ad4db91f56db20b2de10a29df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntUtils::Parity </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parity bit from a 64 bit integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parity value</dd></dl>

</div>
</div>
<a class="anchor" id="aa464bad4c6d20e0430850d66dd2a58c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntUtils::RotFL32 </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 32 bit integer to the left by a positive fixed non-zero increment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift, shift can not be zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The left shifted integer</dd></dl>

</div>
</div>
<a class="anchor" id="aee72a2be5ee57fcb95b4f82b6c9de8b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntUtils::RotFL64 </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 64 bit integer to the left by a positive fixed non-zero increment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift, shift can not be zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The left shifted integer</dd></dl>

</div>
</div>
<a class="anchor" id="ade712c2f935ef581588089329529820c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntUtils::RotFR32 </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 32 bit integer to the right by a positive fixed non-zero increment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift, shift can not be zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The right shifted integer</dd></dl>

</div>
</div>
<a class="anchor" id="a0c56dad1580b37b025bda0491279cdb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntUtils::RotFR64 </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 64 bit integer to the right by a positive fixed non-zero increment </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift, shift can not be zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The right shifted 64 bit integer</dd></dl>

</div>
</div>
<a class="anchor" id="ad5d1abcaa6c06409d2ff1cb3dd0b7eb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntUtils::RotL32 </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 32 bit integer to the left </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The left shifted integer</dd></dl>

</div>
</div>
<a class="anchor" id="a13f63b6981d59ccc5f1d04ca00e45fc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntUtils::RotL64 </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 64 bit integer to the left </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The left shifted integer</dd></dl>

</div>
</div>
<a class="anchor" id="a3cfc41763b5b767307f30f993986049a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntUtils::RotR32 </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift a 32 bit integer to the right </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The right shifted integer</dd></dl>

</div>
</div>
<a class="anchor" id="a6624645c60136f9396c7cb978e5baf1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong IntUtils::RotR64 </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>Shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate shift an unsigned 64 bit integer to the right </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The initial value</td></tr>
    <tr><td class="paramname">Shift</td><td>The number of bits to shift</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The right shifted integer</dd></dl>

</div>
</div>
<a class="anchor" id="ab9fbe6d44b781d06cd1180fa8400dbd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T IntUtils::Select </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine the bits from two integers filtered by a mask value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mask</td><td>The mask value</td></tr>
    <tr><td class="paramname">A</td><td>The first value</td></tr>
    <tr><td class="paramname">B</td><td>The second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A combined N bit integer</dd></dl>

</div>
</div>
<a class="anchor" id="a1829d129f2eb9d220eccfa7d9452944e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint IntUtils::ShiftLeft </td>
          <td>(</td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array &amp;&#160;</td>
          <td class="paramname"><em>Output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left shift an array of integers (OCB mode) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The value array to shift</td></tr>
    <tr><td class="paramname">Output</td><td>The output integer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit count</dd></dl>

</div>
</div>
<a class="anchor" id="a1ad7a8dceacb0dc46b7ef4f120df0303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string IntUtils::ToHex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an array of T to a hexadecimal string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The array of T to convert</td></tr>
    <tr><td class="paramname">Offset</td><td>The initial input offset</td></tr>
    <tr><td class="paramname">Length</td><td>The number of T values to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hex string representation</dd></dl>

</div>
</div>
<a class="anchor" id="aaaa016720aa9e3c578c8ed6dd9ffad57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string IntUtils::ToHex </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a value of T to a hexadecimal string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The value of T to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hex string representation</dd></dl>

</div>
</div>
<a class="anchor" id="a61581b57a1d6a1a3f253668bd3f3e7db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string IntUtils::ToString </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an integer to a string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>The integer to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation</dd></dl>

</div>
</div>
<a class="anchor" id="a720cf7af352cb02662a7012b4d9e2a94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string IntUtils::ToString </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an array of T to a string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>The integer array to convert</td></tr>
    <tr><td class="paramname">Offset</td><td>The initial input offset</td></tr>
    <tr><td class="paramname">Length</td><td>The number of T values to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation</dd></dl>

</div>
</div>
<a class="anchor" id="aca8f7bc9e74e5f2ca3f971e71f5cfc2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static V IntUtils::ValueOrZero </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an integer based on a mask </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pred</td><td>The mask value</td></tr>
    <tr><td class="paramname">Value</td><td>The value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A masked N bit integer</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>CEX/<a class="el" href="_documentation_8h_source.html">Documentation.h</a></li>
<li>CEX/<a class="el" href="_int_utils_8h_source.html">IntUtils.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
