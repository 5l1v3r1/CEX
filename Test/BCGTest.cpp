#include "BCGTest.h"
#include "RandomUtils.h"
#include "../CEX/BCG.h"
#include "../CEX/CTR.h"
#include "../CEX/HKDF.h"
#include "../CEX/IntegerTools.h"
#include "../CEX/RHX.h"
#include "../CEX/SecureRandom.h"
#include "../CEX/SHX.h"
#include "../CEX/SymmetricKey.h"

namespace Test
{
	using Drbg::BCG;
	using Enumeration::BlockCiphers;
	using Exception::CryptoGeneratorException;
	using Utility::IntegerTools;
	using Enumeration::Providers;
	using Prng::SecureRandom;
	using Cipher::SymmetricKeySize;

	const std::string BCGTest::CLASSNAME = "BCGTest";
	const std::string BCGTest::DESCRIPTION = "Block Cipher Generator implementations vector comparison tests.";
	const std::string BCGTest::SUCCESS = "SUCCESS! All BCG tests have executed succesfully.";

	BCGTest::BCGTest()
		:
		m_expected(0),
		m_key(0),
		m_nonce(0),
		m_progressEvent()
	{
		Initialize();
	}

	BCGTest::~BCGTest()
	{
		IntegerTools::Clear(m_expected);
		IntegerTools::Clear(m_key);
		IntegerTools::Clear(m_nonce);
	}

	const std::string BCGTest::Description()
	{
		return DESCRIPTION;
	}

	TestEventHandler &BCGTest::Progress()
	{
		return m_progressEvent;
	}

	std::string BCGTest::Run()
	{
		try
		{
			Exception();
			OnProgress(std::string("BCGTest: Passed Block Cipher Generator exception handling tests.."));

			Reseed();
			OnProgress(std::string("BCGTest: Passed Block Cipher Generator auto-reseed tests.."));

			Stress();
			OnProgress(std::string("BCGTest: Passed Block Cipher Generator stress tests.."));

			// rijndael engine
			BCG* genrhxs = new BCG(BlockCiphers::AES, Providers::None);
			Kat(genrhxs, m_key[0], m_nonce[0], m_expected[0]);
			OnProgress(std::string("BCGTest: Passed BCG-AES known answer test.."));
			// extended ciphers
			BCG* genrhxh256 = new BCG(BlockCiphers::RHXH256, Providers::None);
			Kat(genrhxh256, m_key[0], m_nonce[0], m_expected[1]);
			BCG* genrhxh512 = new BCG(BlockCiphers::RHXH512, Providers::None);
			Kat(genrhxh512, m_key[1], m_nonce[0], m_expected[2]);
			BCG* genrhxs256 = new BCG(BlockCiphers::RHXS256, Providers::None);
			Kat(genrhxs256, m_key[0], m_nonce[0], m_expected[3]);
			BCG* genrhxs512 = new BCG(BlockCiphers::RHXS512, Providers::None);
			Kat(genrhxs512, m_key[1], m_nonce[0], m_expected[4]);
			OnProgress(std::string("BCGTest: Passed BCG-RHX variants known answer tests.."));
			// serpent engine
			BCG* genshxs = new BCG(BlockCiphers::Serpent, Providers::None);
			Kat(genshxs, m_key[0], m_nonce[0], m_expected[5]);
			OnProgress(std::string("BCGTest: Passed BCG-Serpent known answer test.."));
			// extended ciphers
			BCG* genshxh256 = new BCG(BlockCiphers::SHXH256, Providers::None);
			Kat(genshxh256, m_key[0], m_nonce[0], m_expected[6]);
			BCG* genshxh512 = new BCG(BlockCiphers::SHXH512, Providers::None);
			Kat(genshxh512, m_key[1], m_nonce[0], m_expected[7]);
			BCG* genshxs256 = new BCG(BlockCiphers::SHXS256, Providers::None);
			Kat(genshxs256, m_key[0], m_nonce[0], m_expected[8]);
			BCG* genshxs512 = new BCG(BlockCiphers::SHXS512, Providers::None);
			Kat(genshxs512, m_key[1], m_nonce[0], m_expected[9]);
			OnProgress(std::string("BCGTest: Passed BCG-SHX variants known answer tests.."));

			OnProgress(std::string("BCGTest: Evaluate random qualities using ChiSquare, Mean, and Ordered Runs for each generator variant"));
			Evaluate(genrhxs);
			Evaluate(genrhxh256);
			Evaluate(genrhxh512);
			Evaluate(genrhxs256);
			Evaluate(genrhxs512);
			Evaluate(genshxs);
			Evaluate(genshxh256);
			Evaluate(genshxh512);
			Evaluate(genshxs256);
			Evaluate(genshxs512);

			delete genrhxs;
			delete genrhxh256;
			delete genrhxh512;
			delete genrhxs256;
			delete genrhxs512;
			delete genshxs;
			delete genshxh256;
			delete genshxh512;
			delete genshxs256;
			delete genshxs512;

			OnProgress(std::string("BCGTest: Passed Block Cipher Generator random evaluation tests.."));

			return SUCCESS;
		}
		catch (TestException const &ex)
		{
			throw TestException(CLASSNAME, ex.Function(), ex.Origin(), ex.Message());
		}
		catch (CryptoException &ex)
		{
			throw TestException(CLASSNAME, ex.Location(), ex.Origin(), ex.Message());
		}
		catch (std::exception const &ex)
		{
			throw TestException(CLASSNAME, std::string("Unknown Origin"), std::string(ex.what()));
		}
	}

	void BCGTest::Evaluate(IDrbg* Rng)
	{
		Cipher::SymmetricKeySize ks = Rng->LegalKeySizes()[1];
		std::vector<byte> key(ks.KeySize());
		std::vector<byte> cust(ks.NonceSize());
		SecureRandom rnd;
		size_t i;

		rnd.Generate(key, 0, key.size());
		rnd.Generate(cust, 0, cust.size());
		SymmetricKey kp(key, cust);
		Rng->Initialize(kp);

		try
		{
			const size_t SEGLEN = SAMPLE_SIZE / 8;
			std::vector<byte> smp(SAMPLE_SIZE);

			for (i = 0; i < 8; ++i)
			{
				Rng->Generate(smp, i * SEGLEN, SEGLEN);
			}

			RandomUtils::Evaluate(Rng->Name(), smp);
		}
		catch (TestException const &ex)
		{
			throw TestException(std::string("Evaluate"), Rng->Name(), ex.Message() + std::string("-BE1"));
		}
	}

	void BCGTest::Exception()
	{
		// test constructor -1
		try
		{
			// invalid block cipher choice
			BCG gen(BlockCiphers::None);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE1"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test constructor -2
		try
		{
			// invalid null block cipher instance
			BCG gen(nullptr);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE2"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test initialization
		try
		{
			BCG gen(BlockCiphers::AES);
			// invalid key size
			std::vector<byte> key(1);
			SymmetricKey kp(key);
			gen.Initialize(kp);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE3"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test parallel degree
		try
		{
			BCG gen(BlockCiphers::AES);
			SymmetricKeySize ks = gen.LegalKeySizes()[0];
			std::vector<byte> key(ks.KeySize());
			SymmetricKey kp(key);
			gen.Initialize(kp);
			// invalid max parallel -99
			gen.ParallelMaxDegree(99);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE4"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test invalid generator state -1
		try
		{
			BCG gen(BlockCiphers::AES);
			std::vector<byte> m(16);
			// cipher was not initialized
			gen.Generate(m);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE5"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test invalid generator state -2
		try
		{
			BCG gen(BlockCiphers::AES);			
			SymmetricKeySize ks = gen.LegalKeySizes()[0];
			std::vector<byte> key(ks.KeySize());
			std::vector<byte> nonce(ks.NonceSize());
			SymmetricKey kp(key, nonce);
			gen.Initialize(kp);
			std::vector<byte> m(16);
			// array is too small
			gen.Generate(m, 0, m.size() + 1);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE6"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test max reseed exceeded
		try
		{
			BCG gen(BlockCiphers::AES, Providers::CSP);
			SymmetricKeySize ks = gen.LegalKeySizes()[0];
			std::vector<byte> key(ks.KeySize(), 0x32);
			std::vector<byte> nonce(ks.NonceSize(), 0x64);
			SymmetricKey kp(key, nonce);
			gen.Initialize(kp);
			
			for (size_t i = 0; i < gen.MaxReseedCount() + 1; ++i)
			{
				gen.Update(key);
			}

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE7"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}
	}

	void BCGTest::Initialize()
	{
		/*lint -save -e417 */

		const std::vector<std::string> key =
		{
			std::string("0053A6F94C9FF24598EB3E91E4378ADD3083D6297CCF2275C81B6EC11467BA0D"),
			std::string("0053A6F94C9FF24598EB3E91E4378ADD3083D6297CCF2275C81B6EC11467BA0D0558ABFE51A4F74A9DF04396E93C8FE23588DB2E81D4277ACD2073C6196CBF12")
		};
		HexConverter::Decode(key, 2, m_key);

		const std::vector<std::string> nonce =
		{
			std::string("00000000000000000000000000000080")
		};
		HexConverter::Decode(nonce, 1, m_nonce);

		const std::vector<std::string> expected =
		{
			std::string("4F48B3FEC548525A5E64182A29A1D035EE7A491436D49D8639E9B8AE77176CCBAFB3CA08D062D6BD5505851531BBA5DCC2543FE3CCF62B9422E369440D19B6E0"
				"A6D1F7E35C65800EFF598C9CFF5EC89C3C788960C708EF338BFD8A8200FBEC0BDD23527859D218722349BBF2378579509344CF1AD814E57E591C2923A81E19E8"
				"BDF277F6FB43E402703E032798C69F4FD79B11FCBEB400E1CC4E83B620F1DAEF7E0403A10EE341AE060B46936D24240DFC95A9392D1ADA1581BB9EFB8F1D838E"
				"DF878E064505EF3D1D7796F6804171DDEA5A84BAC2AF7A7D23F3073BC9D7E8A837DCE1014CD29F596BE166BC5DCE13028FD92B1AE84E926A933859DEA3D329BE"
				"DDD10825841E7B0E10A8A2F95A3B238753A1613A96D9B93AA209F8A02B33EAAF2EDD3AE155E94A080822808C662F0A477A788A2FFAA2A74D0BBFFF9F3A93EE93"
				"6D67871EE04060DC6054A5E42F9EAC00759C40D48FB25BA06675E51078E3083D50BD41D9077000CE98EC948D94649FCE8EACAF6FB527FDCD2B3DD38C58CF6C14"
				"ABCF415C21DD3AA29B0EEA42D2210F93D4D46B7522A1346E524F1126F565434A618FAA2C0BC94DAC772EF9B1C2C3C7FEDAC144A9A9A66B801378F7E2428AC073"
				"78503528381AC4B38FA8D980EB0C7902EF9EEB5D938622ED2AE4E69CA3ACB7F7274FF92549C9370EC530AE0B58C625EAE8DA2A90E6291C3883E0E01C98EBC2C8"), // aes256
			std::string("C9CF5D7F4B077B4A5F55EB28BE4FADA35FFACFFC24A3C94EB1254E8EDAAFDB5AB19E9788B81426B718CB34B8EEB805726A01398E94B2125B2F0A51EC6559A0D8"
				"E4EC866DFD1C10267CDC00FA14E1E19B99E7C09AF6A158D4BD3FAC24CE063A3CD4A464AB32B6DEF07DADA3ED697D44973B103A0AAA609C95A154E505BD5EE611"
				"B9469EAA720F2F78DA023769FDD8EEE9CBEC143C2A085DFEBDEFDD82BA2C637973DBEAA224240DEAF07DE220179F45F814FC35A4D57D5B5E44154BA30E6AFFA4"
				"FB62AFBD04C568C9BBAA01A34135610F52D031C0D5DE2FF690694EED0CE209E47B7A536332F40B695DB9F73D5DDF4DCC6F26A013834B0A4CD356AA85AA145B70"
				"AF13119B1C4532C2DB68A71EEF62D37A45AE3A977467F12F134B90A6DAF941D9258031A448C93A667C0FEE2A77673926EEC024E05E9F32886E10EA90B5F0C018"
				"211F3829D2CA699438744C01BF25183677E9C6E04EE62D121F0CBEFFC38781E671972EAB77C51E39D46A0F87132085F07738830EED08FE9695B83AC295A6C7C2"
				"9B026AFE06341E172487D55D3254E87C6675F7756D105160143FD40910DD3502D4CCB271C6A0F7B568533E37DE716F5DC0039C80911FCA7D26C9E694499BB5E4"
				"EFA3A973047F45DF407FD10644343D0035DD33BEB5AB2883D51792356AD6E3ED5F34C1E670155E22A81F51984764CD7F29D363F2F1F8353BEA1C3D978510E150"), // rhx-hkdf-256
			std::string("D37726868E499AE76A8046E18E409D2E18BF4EBB9DDEF6E89D9F229B4339B319383A0E97E2D39EA85A6C1425E76018091ABBEA14D02822878D8B7E6756180125"
				"00880A9F85B2B405EE07D589903DF4141788EDA73017CEFBDDAB16540DD0836906E1F2804E4A8B316A8CA7755D958EB99B2371FDF120E51905F2E56E0E07C492"
				"869405496A40498B7AD7BC74ABE00F03464FC4481D451F3C4B9AE8B7944F119925A2777B0ABD87A7DE026B7418C13D9AC2048430DA3ED549855F6835B6C4E995"
				"E4B025A3ACE90965815F26C971F8DA717AF219131943215353D7B17DC642DBE6749EA9E01B2442BFB18C6A2754C5B69771177A92AFF140D0669DB4717C2DFF69"
				"655E7E9689641DC3111AC439D14ACEC81DD0BD137D212F52682DCBC4F8FBFA534D82E0FF366779428FA5E887568C882E9FB28F5ED12B70F7B1B1166D11FFCD95"
				"823793ED1E129321911767638C4FE9C7E9980D6C74747EBCFD0002B98FB4C99A4CAC780772B14002EDF233FCDB35EB0A6BF1D8D17A6CBE302EED27386BBAB0F4"
				"FC7CF1190A5569BF6B0EBF41E20ECCE922FFC38390A7F233E172BDCCF72BC132D279E53CF163A845944C39CBC5170B02B1429F2EB833C3D45287D6B8DC5AAF56"
				"B1F9D1D7C2BD20C8E54DB9E4A187E7056C92D9B4C3291B007F0BB1F71B2AE97A6E785E9F8637DDDFD772F271FA7BFBF8901BB034D0732DEB0AF006218AA029C9"), // rhx-hkdf-512
			std::string("0C22A85505046FDF17D3968B6BDE2AF95274A329B844686EE82C7C7A5CC7AB20598CA5D484091892968FA65835BB67CEDBD15D12984EB7836F0E32239B3AFB35"
				"1417382E3CCFBFCC42A9C6D0E946AFF38DFF7F5C4BEFD75E79348633271627309922032911F464812144F79F32D324813C7C8F103CEE0C19450354F0A03D24F1"
				"8B244E4A5492931748B88DA1F2DB36AD39B9323FBE9D52AE7705421981A1C9B615D2658B861B91CFED78022DBE70783D3D53552DBB52676A40DEE17AA3281400"
				"53A63E2029F8D31C3C9B2887AAEDBFE1EDD344158B48E23B4142BD7553575B40FFAD19511A5F391AC078FAE938FE74CC8C2DE1EBCA1DE73926B7EFA86ABA84A5"
				"278F39CAB189D60DDBDF7DF68987B973593F0259FE385DFAC0BA5BA6C750850ECDEBF713F59F81343D518B1254C087B55289A725118095C416C0BAF70D6C140A"
				"A04433071E63BDE9E61DD7A3534EF5BE0F2DAA31222956725D24D516BF5E41D133F735DF4EDE341649332AB593B830BFDA8C9618BBABBAB280C681DD9D61DFDF"
				"4ACF0E00AF5E0AE3E9579738CDF2505A48AE52FA69C721E0AE1CC8CFFC6FEEB4C6B33B4A2680531034E34AC1B08155A594E1529B610189F9591748F2744EB846"
				"1D2CD509A1E67B8C0E9DB56970E003B0C984C4ADB8613D975759F2F081F27EB98798D1A467780F8CB6B46F1A8D3292605DE9D1D853CC79195B8C67F29A8216C8"), // rhx-shake-256
			std::string("60A95DE7B5BA9697AF3E9B7278F41543D0465C18D14DACA3A23649786E2A32015E321FF104A2034B6EF322291F52C0BFA31AC67E9AB991DFEB0B0C74157221BB"
				"F6184A5C105818483ADA785937C7892EE8AA4F2E3957306B06618FCB81AB34F333A2B6944854CF1B34F226BEBFACC62A3FA6D25441AA64EAF2C4CC01EF60BE56"
				"893A22B307810509F38B57D2C9DE755595F8DCD9DFD655EFB34348DF653C5037B80A5FC5F2C08D275A65D1767261F430DE50D133D0FCF25CD25A667DB0CDF2F7"
				"30D479B4F54713285D6563536CEE593EA549C0637FAEEF463A53F92724450DF6CA736F8AD3CD90D6FB17DB134801AA47F6E754CB90EC10ED1E5DC9F487A05369"
				"98EE09CA5948643AF29D9C715BC2458AF34ECC64EEC3C0C27DAAC5DBCFAC2941BC9DAEF85E0ECC6EA5249ECA8CB36761E025FB48AC45F39E19392894EC15FC4A"
				"F10117FA51CBC8A5E7E121229C1F434E3C9DF12B424881D694E646D02FFE89D5DCF9BCD527CA0627F5C901BE0737677F66B3159719DDB7EA57179A2347E8F572"
				"958F72D7C78D86D00A034E924F687666059127B7CE33F3C85DD88871A58AB76C1B845178BB8B59EA37F81DB4FCA5D5FEC5696001F905ED36DF441D4A9086E91D"
				"D4059BCF2E10D28B92051801CE02007873A6D6B5CEC0D76EB9B12380D3C566FB975EF2D4ECBE3971EB9FD2B88B3307125048EFF91EEC051626A913DA6B898507"), // rhx-shake-512
			std::string("4AF4B64FD67455988C903464D0F50DFF2537342A895B5AFC4A09F16903D944A1C88D6BB3304EAE36543D2263FA90FD6B93240595E2D0FEC81173445A38B2D022"
				"74FF8DDA8E75CD8CC44C8C5085FC4732419A8CE63B4D3F0CF0C04AE3EEEED770111C37F43D733B9E925E42F5035124C02A3190AB936886AE7C785C436695588E"
				"1534F0C4EF3A6AF10B1F077595336BF07976DC533C9631C1C450ED65836499F69353923A4B073149692C8978C3A15408D07AB5626295C67880AAB991AF979D82"
				"A6184F969C37638859429C9D1AC9FFD87760318E1A86DBB1166ED80DC22B6213DB5E1B571D12D0FFE0F40E4B32418B36F647E548732BC78A927B5760EAE4A98F"
				"5A8E724055AAB423C8EDBA32071CF74AE7F0704B4FB06B6D2D2CD9F9F30CAAC6D2FF3FC1700D0E2C00F2AC652386444453DE684CFA0449CFF1FF1B010751BC6D"
				"7E646053EDA5E9CB8EC2D19A22DC6A42B8B0D39C77AFBE189F434A28539AAC77E45F5F85A7DE53AA211F06D07A831ED475D5D943C2C6191120B6A9AAA557BC98"
				"3EBFA469F25950BED19221015A818EF9CA7ED3D8E37C0A9BAA348D459A3C4406030506B73F795B89A22E24DD6520B89FFC5FA2D25C54639F5B65C229EC8668D6"
				"ABC156C91C11529EBE79773CC9B41CE1EEB9B591336177570286CDEA1B9C308949A8FEE59479266B0ECD61F84D6EE79AFC1A4EE214A7EFC1DBB544FDB0B9332D"), // sepent256
			std::string("BB5DA5E7BD1AF465B9E89F33F1687FBF8FC63CCDDAD75D1CCA7D3127CAACCFE6D1A163B7672DB2064E86BCD63245CC986DBA07B786A4793D918D5D0ABE05A8A3"
				"F8AC1B1C0B7400E24AA3D8375D4BD67294B0294DF7BA93C00866A3656100D064D5311CC0EC2E59EBBA926775E5B2497BE70B55A5C46ADF0F8CC6CBF0D586831D"
				"E96F2FFA8B0DB884D5C8E167BB92889ABA2D45A5545B72E985D1472C878BF52C14D9C9FF0F1C96521295EDA46C02E6DEFE630166D316B63257BCA16F2B5CD577"
				"65D0F7BB20FD1813917B940AC1887212B9A7E7BFD9BD10C517AB4C6316632B9FA45F487872CC65F8B23404BC1F1C7197DDD4A4BD0476D5919BBD95FB3276AB5E"
				"5229BA3FA22C82250ACCA8AC7C7849ABB5B8C590D1B8A5BBBCE1528323A2A60E887F3ED1E6CE7695F731B19B5CA8573F02E474F8588DD8CDA206D5B31A5C6638"
				"766B0872305CDB9DFC23625BC23E062406E5448E88BDEB6FFAF5BEA6DB6A1C97EF95E8977511F368A797C0ED6B309E6EFA921EF29FE018F86B017E6127833665"
				"352101C7B8B77A06B87ABCC1E71C1515769FF8EED4B910701C208A26D922DD1AA9FDE674A6828E2FC56AF8FF50A5D9FE3D3CE809A97E0D07DA8C15A29A20FBF5"
				"7B8DD8F1926719B3152D692C69454EED0A415B8DA69162EABF4C353CE701FA6340F00E6A989F7F796FF11837B7A20A5169D5B4A587F350F760385331018F84E3"), // shx-hkdf-256
			std::string("45D16B507A5F0B848B842A63C79B53C61419ABE0BFE18578BC18FE9FB174531044FD334CFC6DBB0AF3E31C2C494C2AD8D7712FDC8C0BF4D607304A2CFB8CCC1A"
				"9AFC622693BCBDA23F120A217465002412CF97E3BAE580A708D619B57C452AEBB01FD517244CE2179A0AEF2341F8DA9F894195B2378F09EA00BD3B5E47CDAFF6"
				"979599B057ABF06BB8775DAC822A1159340C1793BF4C406AE06ADA869BBBDC1542C1C385B9A9DE65D1C6ED7D99D5021DD09ECE0C0D0BA38DC83501EDE7FB89FD"
				"EAA8510FC71D0917CBA13BFD57F6A4CA5A3A6B98DFEBEFE25AD852DEB0148493BF94B31005B339F1B826D83A447E30408FF9EC4B4CA43D16DA6391A22008C76E"
				"870BB025E083DA9C468DDF51938B5F36C15E46661815F25D26C39ACDB155D9B0A23D118AEF5E59FCAA2E50669016F09F61158D238C24CC69AEAF34B2F38A2E24"
				"0F625E0267C8D1A4CCC2C2B3C1C3393820E17FD46D743E25C3D12052924A78010E2D7E63175A0983F093C6251316AF570A94CE6D10E9B6FA959CA1D993C26585"
				"7292D2DAEF8782397B7235533A584B18C25000C71365E140D66F1642AA098936215A9960E51163852D79D6483137093D17735635483AB6A8F9D40748C881C20F"
				"897BE74CD9FB6CFA2C92EDCBFB81DAFD862680E68099DE6FDD7338E351BF3E92EDF96274F5994BEABB379270B1858FC3CE10DF59DFFC9C9BCA8DD0A4FB2F0917"), // shx-hkdf-512
			std::string("8C975A9C35104588B60C76D17BE4BF84DC7AA367A2954DFE9514FA4C4E87B1546C849320932CEF4FBACBB83437A62E31EA769CBFB34B15CE078222A60B3B8285"
				"9D059A09171858FA0F94A2599B00AFFCE0F7AB4008633DA826CD4DA2C17F8D706492A77AFC4FBE7268F650E085AF7C1B19144DF5C9465BD59FBCCB4C0931AAD3"
				"60F4122056ACEA6CFDEFFC91B91D735C2FF436B8984FA3A97BD57584F9EE9AEB0FB198706BB4CCA3EBDEF3AFDAF973E4142B925DB88E157CF3B585B6661E1508"
				"97A7671B388CF6E9A3386EEC771FB95291FCF9F4001F8E9B29A0AD4CD27A6C991F3B2213A0C32A81BAA0DA881ECA7DB54BAB31D23146952208B94A13F5CA1226"
				"02B8268C16ABF59C8D9251F71001435CC616A1108D897F05B44852217B028612920DCA751189D711A033982C81C8AA3DFDAAA188605D7008760D5218DE049557"
				"DD687513D2BDF7FFB7DA0FFB8D90F8989EBD6A408FDEDCC23B5CBA845F88C7C20A8DFDA6131C0DB8DBB43B328D06A53AD6B76FBBB4B29831A4D5B2ACA136391C"
				"E8128E0833B4B3DFD4A1B58519125EF16169CB87C8F093AE98554257CFF5194091D71B5AC15E14981AA2D9B7A4143A305A26DA0332F61008CBA75EE6FA97E7BB"
				"60B1A60B97F64A08399D07281380A7BCCC94E0C1088200A75E2E0BD197E8C0021457216F722222F7BE711BB353AF2B859F80C83BFA044FEF2F1ADE65D8965EBF"), // shx-shake-256
			std::string("86574FABC40DC40D2951DD97A8D31010482A11B49C024F6AE46DA41F63F5FC5A8DA12CD7113D09FF7DC0A898D7CED764503636AF702AC0D4DD808C0ED9ABFFC3"
				"B3122E568ADF4F8B40E6F3FBF460B8742B6C0B11691E0365C9595903FE0D7F2DA480135AE5AD98B2BE476AF8BF906DF42FEE021E279E41E0F7BF7F575B5A7520"
				"99EE457DC395E4D8D0DF94EF9533C7C7B70BF2B07CC7AFE186089628FAFF9DAB93FFA99EB33E871BC2576D8A39FE657138C27F99CE43EEF1EECF3E1F926D205D"
				"B9A6FACDB9D39FDBAC9F9A0BD7B67D7B7BEA540F366D09D005B101D5DFBD3D7927ED348EBE77EF66F37E5B43FE761D5CC58D02232CAC36584F097CF657CB9A5C"
				"188DFF903BEEA2BE3B4EB8B63286BB12D1D2CDED30BECE954C4A1CEA988C18524D873FDC2B8D13ABE191F45E20EDBA870E7DB73CA376D87BD0B97CCB40794064"
				"6A2F21E4A619C1A4B8B4DF3522D925559D231345C2E561273407B332B625CDD0D16B195ACD78A3D91C2D02AC22E6C4FA92ECB2A4555E0686E6B3CC9E2209712B"
				"4B9F87AFB7F2DF37ED96324D5C2A63620384C45273083831A0009CED1A8EA223ED41F2EAEEAF853FC127D2ECDF3C16ADBEBD7AA83466565015FDA3B7473D7AE4"
				"69FDA3AF1081EE6BBA2B980D7AF0416315493726262DC3D4391E56EED8144E5803D575DB048D8D8A1B057B5EF1A82F0B690843FFA53FE7F54294F1346082C111")  // shx-shake-512
		};
		HexConverter::Decode(expected, 10, m_expected);

		/*lint -restore */
	}

	void BCGTest::Kat(IDrbg* Rng, std::vector<byte> &Key, std::vector<byte> &Nonce, std::vector<byte> &Expected)
	{
		const size_t EXPLEN = Expected.size();
		std::vector<byte> exp(EXPLEN);
		SymmetricKey kp(Key, Nonce);

		// generate
		Rng->Initialize(kp);
		Rng->Generate(exp, 0, EXPLEN);

		if (exp != Expected)
		{
			throw TestException(std::string("Kat"), Rng->Name(), std::string("Output does not match the known answer! -BK1"));
		}
	}

	void BCGTest::OnProgress(const std::string &Data)
	{
		m_progressEvent(Data);
	}

	void BCGTest::Reseed()
	{
		const size_t SMPLEN = 10240;
		const size_t SMPCNK = 1024;

		BCG gen(BlockCiphers::AES, Providers::CSP, false);
		Cipher::SymmetricKeySize ks = gen.LegalKeySizes()[1];
		std::vector<byte> key(ks.KeySize(), 0x32);
		std::vector<byte> iv(ks.NonceSize(), 0x64);
		std::vector<byte> otp(SMPLEN);
		SymmetricKey kp(key, iv);
		size_t i;
		size_t j;

		// set a low reseed threshold
		gen.ReseedThreshold() = SMPCNK;

		for (i = 0; i < TEST_CYCLES; ++i)
		{
			try
			{
				// re-initialize
				gen.Initialize(kp);

				// generator will re-seed itself 10x on every test cycle
				for (j = 0; j < SMPLEN / SMPCNK; ++j)
				{
					gen.Generate(otp, j * SMPCNK, SMPCNK);
				}
			}
			catch (CryptoException &ex)
			{
				throw TestException(std::string("Reseed"), gen.Name(), ex.Message());
			}
		}
	}

	void BCGTest::Stress()
	{
		Cipher::Block::Mode::CTR cpr(BlockCiphers::AES);
		BCG gen1(BlockCiphers::AES, Providers::None, false);
		BCG gen2(BlockCiphers::AES, Providers::None, true);
		Cipher::SymmetricKeySize ks = cpr.LegalKeySizes()[1];
		std::vector<byte> cpt;
		std::vector<byte> inp;
		std::vector<byte> key(ks.KeySize());
		std::vector<byte> iv(ks.NonceSize());
		std::vector<byte> otp1;
		std::vector<byte> otp2;
		SecureRandom rnd;
		size_t i;

		const uint MINPRL = static_cast<uint>(cpr.ParallelProfile().ParallelMinimumSize());
		const uint MAXPRL = static_cast<uint>(cpr.ParallelProfile().ParallelBlockSize());

		cpt.reserve(SAMPLE_SIZE);
		inp.reserve(SAMPLE_SIZE);
		otp1.reserve(SAMPLE_SIZE);
		otp2.reserve(SAMPLE_SIZE);

		for (i = 0; i < TEST_CYCLES; ++i)
		{
			const size_t SMPLEN = static_cast<size_t>(rnd.NextUInt32(MAXPRL, MINPRL));
			cpt.resize(SMPLEN, 0x00);
			inp.resize(SMPLEN, 0x00);
			otp1.resize(SMPLEN, 0x00);
			otp2.resize(SMPLEN, 0x00);
			gen2.ParallelProfile().ParallelBlockSize() = SMPLEN - (SMPLEN % MINPRL);

			// fill parameters with random
			IntegerTools::Fill(key, 0, key.size(), rnd);
			IntegerTools::Fill(iv, 0, iv.size(), rnd);
			SymmetricKey kp(key, iv);

			// encrypt with CTR(AES)
			cpr.Initialize(true, kp);
			cpr.Transform(inp, 0, cpt, 0, SMPLEN);

			// sequential generator output
			gen1.Initialize(kp);
			gen1.Generate(otp1, 0, SMPLEN);

			if (otp1 != cpt)
			{
				throw TestException(std::string("Stress"), gen1.Name(), std::string("Transformation output is not equal! -TS1"));
			}

			// parallelized generator output
			gen2.Initialize(kp);
			gen2.Generate(otp2, 0, SMPLEN);

			if (otp1 != otp2)
			{
				throw TestException(std::string("Stress"), gen1.Name(), std::string("Generation output is not equal! -TS2"));
			}
		}
	}
}
