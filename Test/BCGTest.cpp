#include "BCGTest.h"
#include "RandomUtils.h"
#include "../CEX/BCG.h"
#include "../CEX/CTR.h"
#include "../CEX/HKDF.h"
#include "../CEX/IntegerTools.h"
#include "../CEX/RHX.h"
#include "../CEX/SecureRandom.h"
#include "../CEX/SHX.h"
#include "../CEX/SymmetricKey.h"

namespace Test
{
	using Drbg::BCG;
	using Enumeration::BlockCiphers;
	using Exception::CryptoGeneratorException;
	using Utility::IntegerTools;
	using Enumeration::Providers;
	using Prng::SecureRandom;
	using Cipher::SymmetricKeySize;

	const std::string BCGTest::CLASSNAME = "BCGTest";
	const std::string BCGTest::DESCRIPTION = "Block Cipher Generator implementations vector comparison tests.";
	const std::string BCGTest::SUCCESS = "SUCCESS! All BCG tests have executed succesfully.";

	BCGTest::BCGTest()
		:
		m_expected(0),
		m_key(0),
		m_nonce(0),
		m_progressEvent()
	{
		Initialize();
	}

	BCGTest::~BCGTest()
	{
		IntegerTools::Clear(m_expected);
		IntegerTools::Clear(m_key);
		IntegerTools::Clear(m_nonce);
	}

	const std::string BCGTest::Description()
	{
		return DESCRIPTION;
	}

	TestEventHandler &BCGTest::Progress()
	{
		return m_progressEvent;
	}

	std::string BCGTest::Run()
	{
		try
		{
			Exception();
			OnProgress(std::string("BCGTest: Passed Block Cipher Generator exception handling tests.."));

			Reseed();
			OnProgress(std::string("BCGTest: Passed Block Cipher Generator auto-reseed tests.."));

			Stress();
			OnProgress(std::string("BCGTest: Passed Block Cipher Generator stress tests.."));

			// rijndael engine
			BCG* genrhxs = new BCG(BlockCiphers::AES, Providers::None);
			Kat(genrhxs, m_key[0], m_nonce[0], m_expected[0]);
			OnProgress(std::string("BCGTest: Passed BCG-AES known answer test.."));
			// extended ciphers
			BCG* genrhxh256 = new BCG(BlockCiphers::RHXH256, Providers::None);
			Kat(genrhxh256, m_key[0], m_nonce[0], m_expected[1]);
			BCG* genrhxh512 = new BCG(BlockCiphers::RHXH512, Providers::None);
			Kat(genrhxh512, m_key[1], m_nonce[0], m_expected[2]);
			BCG* genrhxs256 = new BCG(BlockCiphers::RHXS256, Providers::None);
			Kat(genrhxs256, m_key[0], m_nonce[0], m_expected[3]);
			BCG* genrhxs512 = new BCG(BlockCiphers::RHXS512, Providers::None);
			Kat(genrhxs512, m_key[1], m_nonce[0], m_expected[4]);
			OnProgress(std::string("BCGTest: Passed BCG-RHX variants known answer tests.."));
			// serpent engine
			BCG* genshxs = new BCG(BlockCiphers::Serpent, Providers::None);
			Kat(genshxs, m_key[0], m_nonce[0], m_expected[5]);
			OnProgress(std::string("BCGTest: Passed BCG-Serpent known answer test.."));
			// extended ciphers
			BCG* genshxh256 = new BCG(BlockCiphers::SHXH256, Providers::None);
			Kat(genshxh256, m_key[0], m_nonce[0], m_expected[6]);
			BCG* genshxh512 = new BCG(BlockCiphers::SHXH512, Providers::None);
			Kat(genshxh512, m_key[1], m_nonce[0], m_expected[7]);
			BCG* genshxs256 = new BCG(BlockCiphers::SHXS256, Providers::None);
			Kat(genshxs256, m_key[0], m_nonce[0], m_expected[8]);
			BCG* genshxs512 = new BCG(BlockCiphers::SHXS512, Providers::None);
			Kat(genshxs512, m_key[1], m_nonce[0], m_expected[9]);
			OnProgress(std::string("BCGTest: Passed BCG-SHX variants known answer tests.."));

			OnProgress(std::string("BCGTest: Evaluate random qualities using ChiSquare, Mean, and Ordered Runs for each generator variant"));
			Evaluate(genrhxs);
			Evaluate(genrhxh256);
			Evaluate(genrhxh512);
			Evaluate(genrhxs256);
			Evaluate(genrhxs512);
			Evaluate(genshxs);
			Evaluate(genshxh256);
			Evaluate(genshxh512);
			Evaluate(genshxs256);
			Evaluate(genshxs512);

			delete genrhxs;
			delete genrhxh256;
			delete genrhxh512;
			delete genrhxs256;
			delete genrhxs512;
			delete genshxs;
			delete genshxh256;
			delete genshxh512;
			delete genshxs256;
			delete genshxs512;

			OnProgress(std::string("BCGTest: Passed Block Cipher Generator random evaluation tests.."));

			return SUCCESS;
		}
		catch (TestException const &ex)
		{
			throw TestException(CLASSNAME, ex.Function(), ex.Origin(), ex.Message());
		}
		catch (CryptoException &ex)
		{
			throw TestException(CLASSNAME, ex.Location(), ex.Origin(), ex.Message());
		}
		catch (std::exception const &ex)
		{
			throw TestException(CLASSNAME, std::string("Unknown Origin"), std::string(ex.what()));
		}
	}

	void BCGTest::Evaluate(IDrbg* Rng)
	{
		Cipher::SymmetricKeySize ks = Rng->LegalKeySizes()[1];
		std::vector<byte> key(ks.KeySize());
		std::vector<byte> cust(ks.NonceSize());
		SecureRandom rnd;
		size_t i;

		rnd.Generate(key, 0, key.size());
		rnd.Generate(cust, 0, cust.size());
		SymmetricKey kp(key, cust);
		Rng->Initialize(kp);

		try
		{
			const size_t SEGLEN = SAMPLE_SIZE / 8;
			std::vector<byte> smp(SAMPLE_SIZE);

			for (i = 0; i < 8; ++i)
			{
				Rng->Generate(smp, i * SEGLEN, SEGLEN);
			}

			RandomUtils::Evaluate(Rng->Name(), smp);
		}
		catch (TestException const &ex)
		{
			throw TestException(std::string("Evaluate"), Rng->Name(), ex.Message() + std::string("-BE1"));
		}
	}

	void BCGTest::Exception()
	{
		// test constructor -1
		try
		{
			// invalid block cipher choice
			BCG gen(BlockCiphers::None);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE1"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test constructor -2
		try
		{
			// invalid null block cipher instance
			BCG gen(nullptr);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE2"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test initialization
		try
		{
			BCG gen(BlockCiphers::AES);
			// invalid key size
			std::vector<byte> key(1);
			SymmetricKey kp(key);
			gen.Initialize(kp);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE3"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test parallel degree
		try
		{
			BCG gen(BlockCiphers::AES);
			SymmetricKeySize ks = gen.LegalKeySizes()[0];
			std::vector<byte> key(ks.KeySize());
			SymmetricKey kp(key);
			gen.Initialize(kp);
			// invalid max parallel -99
			gen.ParallelMaxDegree(99);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE4"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test invalid generator state -1
		try
		{
			BCG gen(BlockCiphers::AES);
			std::vector<byte> m(16);
			// cipher was not initialized
			gen.Generate(m);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE5"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test invalid generator state -2
		try
		{
			BCG gen(BlockCiphers::AES);			
			SymmetricKeySize ks = gen.LegalKeySizes()[0];
			std::vector<byte> key(ks.KeySize());
			std::vector<byte> nonce(ks.NonceSize());
			SymmetricKey kp(key, nonce);
			gen.Initialize(kp);
			std::vector<byte> m(16);
			// array is too small
			gen.Generate(m, 0, m.size() + 1);

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE6"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}

		// test max reseed exceeded
		try
		{
			BCG gen(BlockCiphers::AES, Providers::CSP);
			SymmetricKeySize ks = gen.LegalKeySizes()[0];
			std::vector<byte> key(ks.KeySize(), 0x32);
			std::vector<byte> nonce(ks.NonceSize(), 0x64);
			SymmetricKey kp(key, nonce);
			gen.Initialize(kp);
			
			for (size_t i = 0; i < gen.MaxReseedCount() + 1; ++i)
			{
				gen.Update(key);
			}

			throw TestException(std::string("Exception"), gen.Name(), std::string("Exception handling failure! -BE7"));
		}
		catch (CryptoGeneratorException const &)
		{
		}
		catch (TestException const &)
		{
			throw;
		}
	}

	void BCGTest::Initialize()
	{
		/*lint -save -e417 */

		const std::vector<std::string> key =
		{
			std::string("0053A6F94C9FF24598EB3E91E4378ADD3083D6297CCF2275C81B6EC11467BA0D"),
			std::string("0053A6F94C9FF24598EB3E91E4378ADD3083D6297CCF2275C81B6EC11467BA0D0558ABFE51A4F74A9DF04396E93C8FE23588DB2E81D4277ACD2073C6196CBF12")
		};
		HexConverter::Decode(key, 2, m_key);

		const std::vector<std::string> nonce =
		{
			std::string("00000000000000000000000000000080")
		};
		HexConverter::Decode(nonce, 1, m_nonce);

		const std::vector<std::string> expected =
		{
			std::string("4F48B3FEC548525A5E64182A29A1D035EE7A491436D49D8639E9B8AE77176CCBAFB3CA08D062D6BD5505851531BBA5DCC2543FE3CCF62B9422E369440D19B6E0"
				"A6D1F7E35C65800EFF598C9CFF5EC89C3C788960C708EF338BFD8A8200FBEC0BDD23527859D218722349BBF2378579509344CF1AD814E57E591C2923A81E19E8"
				"BDF277F6FB43E402703E032798C69F4FD79B11FCBEB400E1CC4E83B620F1DAEF7E0403A10EE341AE060B46936D24240DFC95A9392D1ADA1581BB9EFB8F1D838E"
				"DF878E064505EF3D1D7796F6804171DDEA5A84BAC2AF7A7D23F3073BC9D7E8A837DCE1014CD29F596BE166BC5DCE13028FD92B1AE84E926A933859DEA3D329BE"
				"DDD10825841E7B0E10A8A2F95A3B238753A1613A96D9B93AA209F8A02B33EAAF2EDD3AE155E94A080822808C662F0A477A788A2FFAA2A74D0BBFFF9F3A93EE93"
				"6D67871EE04060DC6054A5E42F9EAC00759C40D48FB25BA06675E51078E3083D50BD41D9077000CE98EC948D94649FCE8EACAF6FB527FDCD2B3DD38C58CF6C14"
				"ABCF415C21DD3AA29B0EEA42D2210F93D4D46B7522A1346E524F1126F565434A618FAA2C0BC94DAC772EF9B1C2C3C7FEDAC144A9A9A66B801378F7E2428AC073"
				"78503528381AC4B38FA8D980EB0C7902EF9EEB5D938622ED2AE4E69CA3ACB7F7274FF92549C9370EC530AE0B58C625EAE8DA2A90E6291C3883E0E01C98EBC2C8"), // aes256
			std::string("57191C3C787A267EFABA45DD479AF098F0173D4221619A24D888CCFBF6D9ACDDF12ACB8E434F4D2D4B464ED7B4D9D2D76A9FA2178A236074E6D2E7065E327BAF"
				"B902B69BA8A6B8B747DFC82BC4EB2F3BA25360BA4F2EF989C183DBAA51F6F8E4B387885993D65D4918856CED2E028E9C09DFF8FE9BD42BB6904B7D8A7983E554"
				"9247AC5FB9FF99A791A6F04DE6E2EB7CB5F59C0518792760EEB81F61A98826856180DC131236365081871D1335A432A9007D5BB4683A4D2AE52F309ED898F5EA"
				"E02A691B58C83506E16A28686E988B976D41175DD37EE663B6CF8D28C8E1C4CB421DEB6638D06F1117C7979569668B7946699CFA96654640C10234A4E71ABE9D"
				"A57E6A42A2725DD9A0518CF7BE6A798371BD31E24B55F150F53062C95AC223069B191AE97417C6594C5F683CCB24E8DF2E10321839141152B2BE18FFBC533B5A"
				"3E18D87B517B1A19DB76BB22203CC7177B04FF0D152E31DFA0A10C3A172645F20ADC47E9A4DAF94BD38976753DCF151FF6185C817A4D51E2D7179FBC36CD80FF"
				"2097538618DC54E70DE811749F8EB06DDB2379E2BEC3B28F6F788F2DCFB0F21BBCB20DD32AC4415E1A379D2CFB985A8C63C56B7652AA3902DA22F14BF97B7F48"
				"09BD079778AD0CD4B14A813669AE666C28D32B1B43951C5AC3D0467E405D3AE6CD696FF1F06A1B5A9A7240F1F1BA89CFA653D2495EF8F7601A56435CABCB0BE4"), // rhx-hkdf-256
			std::string("63D1087B92F58330D1345D5DECF6EFD39070E7A357CD6C67266E4A481995685AC8B9F9D27246ACAF3BDAE5223277447675D2A83BC72D56895852BEE3DCF8A371"
				"D0B1D236005FCEF5EBE97B7E6301DD076AA84F21136040BF1F573F53CB00A7B040B7636DCF99D5E4A4A32BA7E737DA19B90642179E5349FF233671A9C950850E"
				"41B908BD4FC79C9693BDB02CEFB7A73FB133A7DF7CD7C83B63DCC42FC1D6614F87C5A69FDEFB38537C05B8BD0E36CD962BA4A4FB62ADA686E14C80487F0F645A"
				"84A6DE41F9CE4BD339E3753A61AC7AE44A6B398B1778D7047CAA59BE54975D414DA36882A8AB1CA9EDB70DB98DA817EAE484C8D8C604452C8871A3E9AADD3DB2"
				"13446876EBD32A0D9ADC9027133B4491DBD71831FA1E3E8A5EAA7C9EDEADD52FC65B84CEABF60771B9A5F2248085EF32D758521D2E6C51432ED559DAB679D9D1"
				"40498228520E8679884E5D26B0B385F115FE7CE237971CC9A75EDC16133F3B6E89ECB9A315561E22E7287474F71486E2E9E2BD7FCEF2F1FBDC52F1062D4F8CEE"
				"92D6E1C2CF99DC4F5AD0411E690B579A6484BF78F98349427AF3A492F8CE09B32F13940C707DBCCC0B764FE00F1F1A39D2C37A7B8B0F9FD60E063DF54A0BA215"
				"739A4E093016F2B4D33C04FDD0F49470A773BAF1F3DE5535E02799362C9F41F982CF4F3E4A1C28FB8065CB0F19A36E3241752A4AD657212C5CDB0D9917AF3DAA"), // rhx-hkdf-512
			std::string("3F45A8ECB1B02C2DB4A6FBA15FBEA13799C853454595FB4531851CB5D6F92460BB5D29C43074D0AB1AA9CC62A023A04FB02073A9A2476DBA7E7DEF897EA4C168"
				"C8A4F300FE8BC1A7E9BDA300E40AF77E16C4BD91AA659403EC71C0CBD091FD1F89F6F67BEE08D532A9D3E49F6059DE087E16A15B81A9C0601497F95748853B19"
				"4FFA65CA5B4C72963ED31F92590EBF066E63D857E33E7D1CE8B45DCA7F0F717F4F3E4BC8C01CE935C224AE549DEFA0B6E280C37DBE77E5C6E47BC688D896E74E"
				"0B774C74FD40939B5AEF1091D724FC0A8BCEAE5163FE1948BD8CE12220324155BE98CA0E4B09C121AFC09C059BA45F62BC05E81759E963F9CFD3D3E1E44237C1"
				"936C33A14D755E7C976B61A83E77FA4EC5F3C58959A5C9C3794348467EBBB3AC2052F83727CD320A3B4681D3C1EA5101868DB79EE72000697B348CFFCCCC10FF"
				"2FF36C356C85D0CADA58FD9F92ABF27A126575F56870868E30A2381EDB60BC84C000811A60CEC23A13657B82C7BF62A5C09BCD8C0AFB581637331C85050A6ECF"
				"0D2150453CA337626EFC2CE1B6152668205BB33776323C00FFEB9CB1953EEDA43972612E066A7454490425A75F871AD471BB8B318791FF1BB5B649465502B876"
				"6A1D489ED1FB0D133A44826D92D74700C57F1B52258500676A84D3FC67F6E282F8D5FF4FEA4BE70DD87A46C4D71C1029457ABE7A4D673EBB19A8FD766E4B8E06"), // rhx-shake-256
			std::string("85C4FFC6320EA3CDC1E84C3765B40C016AA87714EE6E284F330B335B896B8B3F21482E371299FE3B65C27CFD918172AD6ABBA4523E1FDC0B707E91D8AC007D68"
				"D679BB447C390BE13EE23CD382020459895CDF37B608675FE8A38D1CE403A7912A9405253C68249A0A67E09890E5DD6B36249EFF4DAA8004AEF3B168DA33B2C2"
				"6EF9DE76D09C6F52E136D3BA05319F2163996E57FB92656FCDA879389C44D7B17DAD51027C1432BB547DFB0557084CDF8FA8B1C4A66EA8441668E363E05F1503"
				"AFEFA4107A10B1AA67E105431082C0E175D0FA650FD04C21AF0AF9204408E6846484F7068B15D72C10732996CDF415FEDA328514D17F93ABE46644A28B359F60"
				"446AED4925F9B9718B23783E021C29194D68DDB27F4758FA9F04F1B0D27C6C97F233785CD9829D1CDDC13CA027A560EF9FA937D9D4E0B3AF23182DC3BFC826BF"
				"5F0270F7AB9472A2A44FF0C7F5851500C9783E969E0B25E06B7956AEBADC4949A61E754B89DB0897C1AA85DF416E5BEA4B20C737884D0485F51121346FEB260B"
				"A15D1F90AD35700567650B5910F4359819F98CA8F1109245D72AF061EF299A310BCE534A8E033026E0B7F0D7A37D3F93C464BDB252F5501961FEC62B0B1AE63C"
				"1EC385B42EC0ACA39C6C02219E5E7BD53DC5342466518EFAAFA5870D46983A3D52D2849F3A6B558B36FE462C3CD247A0094F0A3E972CDE23B893DC7C775A34BC"), // rhx-shake-512
			std::string("4AF4B64FD67455988C903464D0F50DFF2537342A895B5AFC4A09F16903D944A1C88D6BB3304EAE36543D2263FA90FD6B93240595E2D0FEC81173445A38B2D022"
				"74FF8DDA8E75CD8CC44C8C5085FC4732419A8CE63B4D3F0CF0C04AE3EEEED770111C37F43D733B9E925E42F5035124C02A3190AB936886AE7C785C436695588E"
				"1534F0C4EF3A6AF10B1F077595336BF07976DC533C9631C1C450ED65836499F69353923A4B073149692C8978C3A15408D07AB5626295C67880AAB991AF979D82"
				"A6184F969C37638859429C9D1AC9FFD87760318E1A86DBB1166ED80DC22B6213DB5E1B571D12D0FFE0F40E4B32418B36F647E548732BC78A927B5760EAE4A98F"
				"5A8E724055AAB423C8EDBA32071CF74AE7F0704B4FB06B6D2D2CD9F9F30CAAC6D2FF3FC1700D0E2C00F2AC652386444453DE684CFA0449CFF1FF1B010751BC6D"
				"7E646053EDA5E9CB8EC2D19A22DC6A42B8B0D39C77AFBE189F434A28539AAC77E45F5F85A7DE53AA211F06D07A831ED475D5D943C2C6191120B6A9AAA557BC98"
				"3EBFA469F25950BED19221015A818EF9CA7ED3D8E37C0A9BAA348D459A3C4406030506B73F795B89A22E24DD6520B89FFC5FA2D25C54639F5B65C229EC8668D6"
				"ABC156C91C11529EBE79773CC9B41CE1EEB9B591336177570286CDEA1B9C308949A8FEE59479266B0ECD61F84D6EE79AFC1A4EE214A7EFC1DBB544FDB0B9332D"), // sepent256
			std::string("E40CE147D6DA0BA5CFFD94E81679AD2BFC42DF651AC30DDCE857284B7971EFDEB3E44FD695CD31DC963302104DD6D43337569C4C979EDF6B5CE44D1040D2C706"
				"B4C23A1CA91CA25768A89D0B82EE8D52A2D3C423E2D4CDC943397794A35CD4AB2860050EFADDFE76F6761BFBA16CF073D6F2AC0DBF7E056A1620EDD2BB663590"
				"16EB24341444E79F4B68F1C251F3F07E6A9AFA3A1E3C87609F42184ED1BBE5EEA05A5D0159F202419228CF428273FFD7CF39382947C8B6836C29ACCEE05364A1"
				"48DD9D3D7D3087753792EFBD4F389F16A3EE8D0D14E0B84015EFB7079F260B1B986C26356F526BE16A4592336B7CE366CBAAC7EC77E834A1E928960AB9D1F218"
				"D935AB80A145E88063D2A2B29243E4196211344A665BF334492EE60DB297E4662D05D219F79A5231B2460E5F86049E24686E791295C2CE9B0BDDE78A3F3F2167"
				"5CD4CBBC37002666C0FDCBBC14730F7B1437F72E8F086023AD4CE9CB77B50A2247C100408683C39411968D4E9206C2B26E3136A63DF3909CFBB8C5CBEAEE076D"
				"6ED1E7501394B2CE4A457C7EACAAB82866B9D52A7C5918AE6A7EBBCA836A83493BE723A01D929AE3D135C2DE561EEAC91277F02DAAA2B8D26626A3FD1287636F"
				"29C09D1A2FBDF5083E8813A78B55CBCE1A4B1CEF0768C695967B0CE89A17F7E8518C43C8F95E75FD212D48F5376394F151E16B9F6796B110C617BD39B4D0FD97"), // shx-hkdf-256
			std::string("F5A1FE9C8CA56D024FF63F819C89BA7E894B41E39CB836CD6EEE9E8F48A2C7E535F89D2081B425A281DD0EB10391B937BA073512F3A79F8C0715473774EFEBAE"
				"E67EF133B8D842A78393B709CDCFF20BC1F1A8ED90CBD0317A9A79B97F375637D0006B109085E1DD7D2A11080C765F01821084A0575B0A4A3E822C6F0FCDD9F6"
				"E4D7C400FDE433FBCC7CB14E34ABDFB279DA332C7AE39D028C709D3B94E4BD6A01D639BF07A3D35E9405438BCB1C4BFF8BBE7C25D0B43F3861CEB34A0D8CDE50"
				"408C8582558E734E12E02696A011586D1A95F5DD7693DAB3F9B27C93A6325C2D0F844DAD8AF457D006822F839BB5F3BAFA8E9059A8B16D9084BB90539D4A8720"
				"ACBE540F17B7B5554EEEA84212ABBEEF1077650D4F2F4F6D13CE22A74C779E52416EBD8EF032AEBD4A03993742C61F4875B0D6180778629887A39122D1F63C24"
				"53B0550FD913D22E1EF74B611959F72CEE495A8CC4F46BD771954B742CCA70FC4311F5FFC11F9CE46E758D613668D5E5125C11C70AF7E9CAD79AE2B0484E598E"
				"ECA276CA62D11011684A29F5FE46DD6058A7535C91E80AFAAE381B3EF7537724F31B2DD2607F2ECB0C5ED94292661875EB879FF98893D26B706A07A96BFECD9E"
				"F4581E08308F5DF212A58A61275E1F60862B90BAD0A0F1083F7F07953580B1CFD0B354375377A233334A73469A86DC8A66DBF2B6B86C89F53536FB31FA9353C7"), // shx-hkdf-512
			std::string("161B6D3F9CBF34957570D49FDE3806F05BD6FB54F25CA1A58E4B4CB243003466723C7FCC3D23DD936838D3139D87B4907D8F5C2A46000A53D040179403DB8AA5"
				"48FC6AE9F55AE10FE675F44A244E3E1FDBF877C5173E15D6983EE9484B541D4E01980C4DE1769BB32422C18643DB73E010333EB92B91B3F84411227A8C21D597"
				"A8C32481D49BBEADC609F63C059C9CEFCBFAC829247EC4052FDD5AC23AE4FCC09E96ACD1709E29C63253AEB13D5A4827902A6F78F7D0A422B3D2D35DACB8BD61"
				"D2FE3AB9296BF88D2D3869D2D893E9E256281243A4538C004853A514AEDF0518CB059D3EEAED6CF28AA443E607C99460169C21667469F3CBD4AF174A3D5DCA11"
				"A3A23E17140DAE6D0C02F92370CA010B3A71CA56A569A647E61FFEC6236256F1A7D9162156762EAA7BE6EDC380514D9ACB63C4B1798D88E584FF716DE8E37015"
				"5D06FF9CA53CCB80BAE2DA4D094FB12A0FC28AF0D078782EAF410E0B687973176D377C1EE5BA145A7BCDE7EA25B74140ED4113D12ADB63C9702D4E66BEE5EE8D"
				"D12BBD49B4BB7A41B2028A05C0330ED9A4AA3F9DE7CFA19487D6F85681F2BC63AB24D1CD02E3C0C1A996E9D4BD0462B0A14C196595AAC2223DBF6CDEDF8EB6F5"
				"D35E90B29E26C018FD034CB49B38DF17C4C2BA26B292F1DEC59D344754E7B6AC8AAD3FDC4DA6B9FEF1B3222622890B26A64C65B7FD17A958C1E4EDEA5E415CF8"), // shx-shake-256
			std::string("B45A8B2999FF8BDB8857428B4E20E1574C376A52FB95AAAFBF569FA1B4FA76A6F05575E0F7A19595778BFED4AA6CDD52F922F8751F71DA4B91AD2980707E8EE6"
				"D9CD748ADD804561AFC1DC4AFC27E9B0A77498B33065E4C63F8B560B8E918937F10486E831FE0C509F7271775442FEEB44915415D907B88A7D798F18D365DEC0"
				"A7A83AEA67BFD3F85DF15CF57CBB4BA9C4D38C64312654DB24296249CEF0447FB3FD6BA26F379D797B09AD7227832A5DDFE9A9D6EB75BEB6A603E67F493150DC"
				"CCC740407CC02C157D6407A5D5A5DECD1C17478E9853EC6482A1A878BFBAF5BCDDDE95C02BAA7DF87793EFBDE832D665D13D0B3A471A524EFE7A08014F4E281A"
				"D18E3AC5E96FCC77B825993C13EBC69D78C052FE34F1FB2A372A52EBD80C9A20F812CA69C1C6F49D6A4A92A527B497407AC16D956288E46D6E1DDCA76AC18D4E"
				"FAEFFC2352AAF114DC6AE4BCE762B456FFFFE3FFA4B1535945DE4F05DF1A55415AC1060CCF06675A1A89E704E403AAB52AFC49214B4EA96039B47CEC5D601E76"
				"D37876569A80E86C9366B99EBD466894691B766388F3F9C087E1949FABFB127CC7F7B7EB18C96924EF24CA3A7643E295A4311531560272FA75270AAC8CBC3083"
				"E5FAF445046E259294E806A19022D6B904D76DE61A955E956568435E847368969E33EBD12F65100FDD741369D567BEF00C0C40287BC03D25249E086FC5E61812")  // shx-shake-512
		};
		HexConverter::Decode(expected, 10, m_expected);

		/*lint -restore */
	}

	void BCGTest::Kat(IDrbg* Rng, std::vector<byte> &Key, std::vector<byte> &Nonce, std::vector<byte> &Expected)
	{
		const size_t EXPLEN = Expected.size();
		std::vector<byte> exp(EXPLEN);
		SymmetricKey kp(Key, Nonce);

		// generate
		Rng->Initialize(kp);
		Rng->Generate(exp, 0, EXPLEN);

		if (exp != Expected)
		{
			throw TestException(std::string("Kat"), Rng->Name(), std::string("Output does not match the known answer! -BK1"));
		}
	}

	void BCGTest::OnProgress(const std::string &Data)
	{
		m_progressEvent(Data);
	}

	void BCGTest::Reseed()
	{
		const size_t SMPLEN = 10240;
		const size_t SMPCNK = 1024;

		BCG gen(BlockCiphers::AES, Providers::CSP, false);
		Cipher::SymmetricKeySize ks = gen.LegalKeySizes()[1];
		std::vector<byte> key(ks.KeySize(), 0x32);
		std::vector<byte> iv(ks.NonceSize(), 0x64);
		std::vector<byte> otp(SMPLEN);
		SymmetricKey kp(key, iv);
		size_t i;
		size_t j;

		// set a low reseed threshold
		gen.ReseedThreshold() = SMPCNK;

		for (i = 0; i < TEST_CYCLES; ++i)
		{
			try
			{
				// re-initialize
				gen.Initialize(kp);

				// generator will re-seed itself 10x on every test cycle
				for (j = 0; j < SMPLEN / SMPCNK; ++j)
				{
					gen.Generate(otp, j * SMPCNK, SMPCNK);
				}
			}
			catch (CryptoException &ex)
			{
				throw TestException(std::string("Reseed"), gen.Name(), ex.Message());
			}
		}
	}

	void BCGTest::Stress()
	{
		Cipher::Block::Mode::CTR cpr(BlockCiphers::AES);
		BCG gen1(BlockCiphers::AES, Providers::None, false);
		BCG gen2(BlockCiphers::AES, Providers::None, true);
		Cipher::SymmetricKeySize ks = cpr.LegalKeySizes()[1];
		std::vector<byte> cpt;
		std::vector<byte> inp;
		std::vector<byte> key(ks.KeySize());
		std::vector<byte> iv(ks.NonceSize());
		std::vector<byte> otp1;
		std::vector<byte> otp2;
		SecureRandom rnd;
		size_t i;

		const uint MINPRL = static_cast<uint>(cpr.ParallelProfile().ParallelMinimumSize());
		const uint MAXPRL = static_cast<uint>(cpr.ParallelProfile().ParallelBlockSize());

		cpt.reserve(SAMPLE_SIZE);
		inp.reserve(SAMPLE_SIZE);
		otp1.reserve(SAMPLE_SIZE);
		otp2.reserve(SAMPLE_SIZE);

		for (i = 0; i < TEST_CYCLES; ++i)
		{
			const size_t SMPLEN = static_cast<size_t>(rnd.NextUInt32(MAXPRL, MINPRL));
			cpt.resize(SMPLEN, 0x00);
			inp.resize(SMPLEN, 0x00);
			otp1.resize(SMPLEN, 0x00);
			otp2.resize(SMPLEN, 0x00);
			gen2.ParallelProfile().ParallelBlockSize() = SMPLEN - (SMPLEN % MINPRL);

			// fill parameters with random
			IntegerTools::Fill(key, 0, key.size(), rnd);
			IntegerTools::Fill(iv, 0, iv.size(), rnd);
			SymmetricKey kp(key, iv);

			// encrypt with CTR(AES)
			cpr.Initialize(true, kp);
			cpr.Transform(inp, 0, cpt, 0, SMPLEN);

			// sequential generator output
			gen1.Initialize(kp);
			gen1.Generate(otp1, 0, SMPLEN);

			if (otp1 != cpt)
			{
				throw TestException(std::string("Stress"), gen1.Name(), std::string("Transformation output is not equal! -TS1"));
			}

			// parallelized generator output
			gen2.Initialize(kp);
			gen2.Generate(otp2, 0, SMPLEN);

			if (otp1 != otp2)
			{
				throw TestException(std::string("Stress"), gen1.Name(), std::string("Generation output is not equal! -TS2"));
			}
		}
	}
}
